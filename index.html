

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />



  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="ElderToKing">



  <link rel="apple-touch-icon" sizes="180x180" href="icons/icon-180.png">
  <link rel="apple-touch-icon" href="apple-touch-icon.png">



  <title>ElderToKing</title>
  <style>

@font-face{
      font-family:'Alagard';
      src:url('font/Font%20to%20use/alagard.ttf') format('truetype');
      font-weight:normal;
      font-style:normal;
    }
:root{
      --bg:#0b0f0c;
      --panel:#101a14;
      --panel2:#0d1511;
      --text:#e9f6ea;
      --muted:#a6d4ac;
      --accent:#f4d06f;
      --ok:#6be675;
      --warn:#ffcc66;
      --danger:#ff6b6b;
      --line:#1f3a2a;
      --shadow: 0 14px 36px rgba(0,0,0,.38);
      --radius:22px;
      --mono:'Alagard', monospace;
      --sans:'Alagard', sans-serif;
    }
    *{box-sizing:border-box;}
    html{font-size:20px;-webkit-text-size-adjust:100%;text-size-adjust:100%;}
    body{
      margin:0;
      min-height:100vh;
      padding: calc(6px + env(safe-area-inset-top)) 14px calc(92px + env(safe-area-inset-bottom));
      font-family:var(--sans);
      color:var(--text);
      background:
        url("Sprites/Game Background ElderToKing.png") center/cover fixed no-repeat,
        radial-gradient(900px 700px at 18% 0%, rgba(244,208,111,.13), transparent 55%),
        radial-gradient(900px 650px at 92% 25%, rgba(192,108,59,.10), transparent 55%),
        linear-gradient(180deg, #070a08, var(--bg));
      -webkit-tap-highlight-color: transparent;
    }
body::after{
      content:"";
      position:fixed;
      inset:0;
      pointer-events:none;
      background: radial-gradient(circle at center,
                  rgba(0,0,0,0) 40%,
                  rgba(0,0,0,0.45) 100%);
      z-index: 0;
    }


    .wrap{max-width:760px;margin:0 auto;display:flex;flex-direction:column;gap:12px;}
    header{
      position:sticky;
      top:0;
      z-index:20;
      padding-bottom:10px;
      background:
        linear-gradient(180deg,
          rgba(247,240,226,.98),
          rgba(242,224,196,.96)
        );
      border-bottom:1px solid rgba(158,104,54,.55);
    }
    .top{display:flex;align-items:flex-end;justify-content:space-between;gap:10px;padding:10px 2px 10px;}
    .top > div:first-child{display:none;}
    h1{margin:0;font-family:var(--mono);font-size:.85rem;letter-spacing:.5px;color:var(--accent);text-shadow: 0 0 14px rgba(244,208,111,.16);}
    .sub{margin:4px 0 0;color:var(--muted);font-size:.78rem;line-height:1.3;max-width:52ch;}
    .hud{display:flex;flex-wrap:wrap;gap:8px;align-items:center;justify-content:flex-start;overflow:visible;scrollbar-width:none;}
    .hud::-webkit-scrollbar{display:none;}
    .pill{
      border:1px solid rgba(244,170,92,.7);
      background: rgba(255,255,255,0.05);
      border-radius:999px;
      padding:10px 12px;
      box-shadow: var(--shadow);
      font-family:var(--mono);
      font-size:.78rem;
      white-space:nowrap;
      user-select:none;
    }
    
/* Main resource pill (Renown) */
.pill--main{
  padding:10px 14px;
  border-color: rgba(244,208,111,.95);
  box-shadow: 0 14px 30px rgba(0,0,0,.25), 0 0 18px rgba(244,208,111,.22);
  transform: translateY(-1px);
}
.pill--main b{ font-size: 18px; letter-spacing:.2px; }
.pillSub{
  display:block;
  margin-top:2px;
  font-size:11px;
  color: var(--muted);
  line-height:1.1;
}
.pill b{color:var(--accent);font-weight:900;font-size:.9rem;letter-spacing:.03em;}
    .card{
      background: rgba(255,255,255,0.06);
      border:1px solid rgba(244, 170, 92, 0.55);
      border-radius: var(--radius);
      box-shadow: 0 16px 40px rgba(0,0,0,.45);
      backdrop-filter: blur(10px);
      overflow:hidden;
    }
    .cardBody{padding:14px;}
    .sectionTitle{
      display:flex;align-items:center;justify-content:space-between;gap:12px;
      font-family:var(--mono);
      color:var(--muted);
      font-size:.78rem;
      padding: 12px 14px;
      border-bottom:1px solid rgba(244,170,92,.5);
      background: linear-gradient(180deg,
                   rgba(255,255,255,0.12),
                   rgba(244,170,92,0.10));
    }
    .sectionTitle b{color:var(--text);}
    .bigBtn{
      width:100%;
      border:1px solid rgba(244,170,92,.85);
      background: linear-gradient(180deg,
                    rgba(255,255,255,0.22),
                    rgba(244,170,92,0.20));
      color:var(--text);
      border-radius: 22px;
      padding:18px 16px;
      font-family:var(--mono);
      cursor:pointer;
      box-shadow: 0 16px 40px rgba(0,0,0,.45);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      min-height:86px;
      transition: transform .08s ease, border-color .2s ease, filter .2s ease;
      touch-action: manipulation;
      user-select:none;
    }
    .bigBtn:active{transform: translateY(1px) scale(.99);}
    .bigBtn[disabled]{opacity:.55;cursor:not-allowed;transform:none;filter:saturate(.7);}
    .bigBtn:hover{border-color: rgba(244,208,111,.60);}
    .bigLeft{display:flex;flex-direction:column;gap:4px;min-width:0;}
    .bigName{font-size:1.06rem;color:var(--accent);font-weight:1000;letter-spacing:.3px;}
    .bigDesc{font-family:var(--sans);font-size:.84rem;line-height:1.3;color:var(--text);opacity:.78;}
    .bigRight{font-family:var(--mono);text-align:right;}
    .bigRight .gain{font-size:.90rem;}
    .bigRight .hint{font-size:.72rem;color:var(--muted);margin-top:2px;}
    .row2{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px;}
    .row2.battleRow{grid-template-columns:1fr;}
    .row3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px;margin-top:10px;}
    @media (max-width: 520px){ .row3{grid-template-columns:1fr;} }

    .smallBtn{
      border:1px solid rgba(244,170,92,.9);
      background: linear-gradient(180deg,
                   rgba(255,255,255,0.32),
                   rgba(244,170,92,0.28));
      color:var(--text);
      border-radius: 18px;
      padding:14px 14px;
      cursor:pointer;
      font-family:var(--mono);
      min-height:64px;
      display:flex;flex-direction:column;justify-content:center;gap:4px;
      transition: transform .08s ease, border-color .2s ease, opacity .2s ease, filter .2s ease;
      touch-action: manipulation;
      user-select:none;
    }    .smallBtn:active{transform: translateY(1px) scale(.99);}
    .smallBtn[disabled]{opacity:.55;cursor:not-allowed;transform:none;filter:saturate(.75);}
    .smallBtn:hover{border-color: rgba(244,208,111,.38);}
    .smallBtn .t{font-weight:900;color:var(--accent);font-size:.92rem;}
    .smallBtn .d{font-family:var(--sans);color:var(--muted);font-size:.74rem;line-height:1.25;opacity:.82;}

    /* Minimal battle cards (Variant C) */
    .smallBtn.battleCard{
      align-items:flex-start;
      justify-content:flex-start;
      gap:2px;
      padding:8px 11px;
      border-radius:16px;
      border:1px solid rgba(158,104,54,.45);
      background:linear-gradient(180deg,#fbf5ea,#f3e4cf);
      box-shadow:none;
    }

    .smallBtn.battleCard .t{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:6px;
      font-size:.82rem;
      font-weight:700;
      letter-spacing:.01em;
      color:var(--text);
    }
    .battleTitleText{
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .battleStars{
      font-size:.78rem;
      opacity:.9;
    }

    .smallBtn.battleCard .d{
      font-family:var(--sans);
      font-size:.7rem;
      line-height:1.35;
      color:var(--muted);
      white-space:pre-line; /* so \n in JS becomes a second line */
    }

    .smallBtn.battleCard .d::first-line{
      font-weight:600;
    }


    .bar{margin-top:12px;border:1px solid rgba(31,58,42,.85);border-radius: 999px;overflow:hidden;background: rgba(0,0,0,.16);}
    .bar > div{height:12px;width:10%;background: linear-gradient(90deg, rgba(244,208,111,.92), rgba(107,230,117,.80));transition: width .22s ease;}
    .villagePopBlock{margin-top:10px;font-family:var(--mono);font-size:.74rem;color:var(--muted);display:flex;flex-direction:column;gap:2px;}
    .villagePopBlock b{color:var(--text);}
    
    .meta{display:flex;justify-content:space-between;gap:10px;font-family:var(--mono);font-size:.74rem;color:var(--muted);margin-top:10px;}
    .meta b{color:var(--text);}
    details{margin-top:12px;border-top:1px solid rgba(31,58,42,.55);padding-top:10px;}
    summary{cursor:pointer;font-family:var(--mono);color:var(--muted);user-select:none;}
    .miniLog{
  margin-top:10px;
  border-radius:16px;
  border:1px solid rgba(244,170,92,.8);
  background: rgba(0,0,0,0.62);
  backdrop-filter: blur(8px);
  overflow:hidden;
}
.miniLogHeader{
  padding:6px 10px;
  font-family:var(--mono);
  font-size:.76rem;
  letter-spacing:.02em;
  text-transform:uppercase;
  color:var(--muted);
  border-bottom:1px solid rgba(31,58,42,.75);
  background: linear-gradient(180deg, rgba(8,12,10,.95), rgba(8,12,10,.88));
}
.log{
  margin-top:10px;
  max-height: 28vh;
  overflow:auto;
  border-radius:18px;
  border:1px solid rgba(244,170,92,.9);
  background: rgba(0,0,0,0.78);
  backdrop-filter: blur(8px);
  padding:12px;
  font-family:var(--mono);
  font-size:.76rem;
  line-height:1.45;
  -webkit-overflow-scrolling: touch;
  scrollbar-width:none; /* Firefox */
}
.log::-webkit-scrollbar{
  display:none; /* WebKit */
}

/* Each log line as a row */
.log-entry{
  display:flex;
  gap:8px;
  align-items:flex-start;
  margin:0 0 6px;
  opacity:0;
  transform:translateY(-4px);
  animation: logIn .18s ease-out forwards;
}

/* Allow multiline battle victory logs */
.log-entry span:last-child{ white-space: pre-line; }

@keyframes logIn{
  to{
    opacity:1;
    transform:translateY(0);
  }
}

/* Timestamp: small + dim */
.log-time{
  opacity:.55;
  font-size:.72rem;
  min-width:44px;
  text-align:right;
  user-select:none;
}

/* Tone colours (same class names you already use) */
.good{color:var(--ok);font-weight:900;}
.bad{color:var(--danger);font-weight:900;}
.warn{color:var(--warn);font-weight:900;}

/* Optional: tiny resource tags if you ever want them */
.log-tag{
  padding:1px 4px;
  border-radius:4px;
  font-size:.72rem;
  opacity:.9;
  user-select:none;
  border:1px solid rgba(31,58,42,.65);
  margin-left:6px;
}
.log-tag-gold{color:var(--accent);}
.log-tag-renown{color:var(--muted);}
.log-tag-land{color:var(--muted);}

/* Bottom tabs */
    .tabbar{
      position:fixed; left:0; right:0; bottom:0;
      padding: 10px 12px calc(10px + env(safe-area-inset-bottom));
      background: linear-gradient(180deg, rgba(11,15,12,.0), rgba(11,15,12,.92) 40%, rgba(11,15,12,.985));
      border-top:1px solid rgba(31,58,42,.75);
      display:flex; gap:10px; justify-content:center;
      overflow-x:auto; overflow-y:hidden;
      -webkit-overflow-scrolling: touch;
      backdrop-filter: blur(6px);
      z-index: 999;
    }
    .tabbar::-webkit-scrollbar{display:none;}
    .tab{
      border:1px solid rgba(31,58,42,.9);
      background: linear-gradient(180deg, rgba(16,26,20,.86), rgba(13,21,17,.86));
      color: var(--muted);
      border-radius: 999px;
      padding: 10px 12px;
      font-family: var(--mono);
      font-size: .76rem;
      cursor:pointer;
      white-space:nowrap;
      user-select:none;
      transition: transform .08s ease, border-color .2s ease, color .2s ease, opacity .2s ease;
      touch-action: manipulation;
    }
    .tab:active{transform: translateY(1px) scale(.99);}
    .tab.active{color:var(--text); border-color: rgba(244,208,111,.45);}
    .tab[disabled]{opacity:.45;cursor:not-allowed;filter:saturate(.75);}
    .dot{display:inline-block;width:8px;height:8px;border-radius:999px;background: rgba(244,208,111,.25);margin-right:8px;vertical-align:middle;}
    .tab.active .dot{background: rgba(244,208,111,.92); box-shadow: 0 0 12px rgba(244,208,111,.25);}

    .toast{
      position: fixed;
      left:50%;
      transform: translateX(-50%);
      bottom: calc(84px + env(safe-area-inset-bottom));
      background: linear-gradient(180deg, var(--card-bg), var(--card-bg-soft));
      border: 1px solid rgba(158,104,54,.55);
      border-radius: 999px;
      padding: 10px 16px;
      font-family: var(--mono);
      font-size: 0.78rem;
      color: var(--card-text);
      box-shadow: 0 12px 30px rgba(0,0,0,.45);
      z-index: 1200;
      display:none;
      max-width: calc(100vw - 24px);
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }

.toast.show{display:block;animation: pop .18s ease-out;}
    @keyframes pop{from{transform:translateX(-50%) scale(.98);opacity:.25;}to{transform:translateX(-50%) scale(1);opacity:1;}}

    /* tiny dopamine confetti */
    .spark{
      position: fixed;
      width: 26px; height: 26px;
      pointer-events:none;
      opacity:.98;
      transform: translate(-50%,-50%);
      animation: fly 650ms ease-out forwards;
      filter: drop-shadow(0 10px 18px rgba(0,0,0,.35));
      z-index: 1300;
      background-image: url("Sprites/Denarii Icon.png");
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
    }
    @keyframes fly{to{ transform: translate(calc(-50% + var(--dx)), calc(-50% + var(--dy))) scale(.65); opacity:0; }}

    .table{
      width:100%;
      border-collapse:separate;
      border-spacing:0 8px;
      font-family:var(--mono);
      font-size:.78rem;
      color:var(--text);
    }
    
    /* Land / Territories visual tweaks */
    .territorySummaryRow{
      display:flex;
      flex-wrap:wrap;
      gap:6px 12px;
      margin:6px 0 4px;
      font-family:var(--mono);
      font-size:.76rem;
    }
    .territorySummaryTag{
      padding:4px 8px;
      border-radius:999px;
      border:1px solid rgba(158,104,54,.6);
      background:rgba(255,255,255,0.6);
      white-space:nowrap;
    }
    .territorySummaryTag b{
      padding-right:4px;
    }
    
    
    .territoryFlavor{
      display:block;
      margin-top:2px;
      font-family:var(--sans);
      font-size:.78rem;
      color:var(--muted);
    }
.territoryCardHeader{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:8px;
      margin-bottom:2px;
    }

    .territoryOwnedTag{
      font-family:var(--mono);
      font-size:.75rem;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid rgba(158,104,54,.7);
      background:rgba(255,255,255,0.7);
    }
.territoryCard{
      text-align:left;
      align-items:flex-start;
    }

    .territoryWorkersRow{
      display:flex;
      align-items:center;
      gap:6px;
      margin-top:6px;
      font-family:var(--mono);
      font-size:.72rem;
    }
    .territoryWorkersMeta{
      flex:1;
      line-height:1.2;
    }
    .territoryWorkersHint{
      display:block;
      font-size:.68rem;
      color:var(--muted);
    }
    .tinyBtn{
      border-radius:999px;
      border:1px solid rgba(158,104,54,.7);
      padding:2px 8px;
      background:rgba(255,255,255,0.85);
      font-family:var(--mono);
      font-size:.78rem;
      min-width:30px;
    }
    .territoryCard .t{
      font-size:.9rem;
    }
    .territoryCard .d{
      font-size:.8rem;
    }
.table td{
      padding:10px 12px;
      border:1px solid rgba(31,58,42,.85);
      background: linear-gradient(180deg, rgba(10,16,13,.62), rgba(7,10,8,.62));
    }
    .table td:first-child{border-radius:14px 0 0 14px;color:var(--muted);width:46%;}
    .table td:last-child{border-radius:0 14px 14px 0;text-align:right;}
    .danger{border-color: rgba(255,107,107,.35) !important;}
    /* Milites icon label */
    .milites-label{
      display:flex;
      align-items:center;
      gap:8px;
    }
    .milites-icon{
      width:44px;
      height:44px;
      image-rendering: pixelated;
    }
  

    /* Chest overlay transitions */
    #chestOverlay{
      opacity: 0;
      pointer-events: none;
      transition: opacity .22s ease-out;
    }
    #chestOverlay.visible{
      opacity: 1;
      pointer-events: auto;
    }
    #chestCard{
      transform: translateY(18px) scale(.94);
      opacity: 0;
      transition: transform .26s ease-out, opacity .26s ease-out;
    }
    #chestOverlay.visible #chestCard{
      transform: translateY(0) scale(1);
      opacity: 1;
    }

    /* Battle report overlay transitions */
    #battleOverlay{
      opacity: 0;
      pointer-events: none;
      transition: opacity .22s ease-out;
    }
    #battleOverlay.visible{
      opacity: 1;
      pointer-events: auto;
    }
    #battleCard{
      transform: translateY(18px) scale(.94);
      opacity: 0;
      transition: transform .26s ease-out, opacity .26s ease-out;
    }
    #battleOverlay.visible #battleCard{
      transform: translateY(0) scale(1);
      opacity: 1;
    }


    /* --- Mobile header compact mode (keeps HUD, removes banner text) --- */
    @media (max-width: 520px){
      .top{padding:6px 0 6px; align-items:center;}
      .top > div:first-child{display:none;} /* hides title + description */
      .hud{gap:6px; justify-content:flex-start;}
      .pill{padding:8px 10px; font-size:.72rem; box-shadow: 0 10px 24px rgba(0,0,0,.30);}
      header{padding-bottom:6px;}
    }
    /* If description exists anywhere, don't show it */
    .sub{display:none !important;}


    
/* Battle simulation overlay transitions */
#battleSimOverlay{
  position:fixed;
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  background: rgba(0,0,0,0.55);
  backdrop-filter: blur(3px);
  opacity:0;
  pointer-events:none;
  transition: opacity .22s ease-out;
  z-index:1600;
}
#battleSimOverlay.visible{
  opacity:1;
  pointer-events:auto;
}
#battleSimCard{
  transform: translateY(18px) scale(.94);
  opacity:0;
  transition: transform .26s ease-out, opacity .26s ease-out;
}
#battleSimOverlay.visible #battleSimCard{
  transform: translateY(0) scale(1);
  opacity:1;
}
.simLine{
  margin:0 0 6px;
  font-family:var(--mono);
  font-size:.80rem;
  line-height:1.30;
  white-space:pre;
}


.simMetaRow{
  display:flex;
  justify-content:space-between;
  align-items:flex-end;
  gap:10px;
  margin-bottom:10px;
  font-family:var(--mono);
  font-size:.78rem;
  color:var(--muted);
}
.simMetaLabel{
  opacity:.85;
  letter-spacing:.04em;
  text-transform:uppercase;
  font-size:.72rem;
}
.simMetaText{
  font-size:.9rem;
  color:var(--text);
}
.simBlock{
  margin:0;
  padding:0;
}
.simLabel{
  font-family:var(--mono);
  font-size:.78rem;
  margin-bottom:2px;
  color:var(--muted);
  line-height:1.0;
}
.simBar{
  margin:0;
  padding:0;
  border:none;
  background:none;
  display:block;
}
.battleBarSprite{
  display:block;
  width:100%;
  max-width:300px;
  height:auto;
  image-rendering:pixelated;
}
.battleBar{
  position:relative;
  display:inline-block;
}
.battleBar.barShake{
  animation: barShake 0.18s ease-out;
}
@keyframes barShake{
  0%{ transform:translateX(0); }
  25%{ transform:translateX(-1px); }
  50%{ transform:translateX(1px); }
  75%{ transform:translateX(-1px); }
  100%{ transform:translateX(0); }
}



.battleBarCount{
  position:absolute;
  right:24px;
  top:50%;
  transform:translateY(-50%);
  font-family:var(--mono);
  font-size:.9rem;
  color:#000;
  text-shadow:0 0 4px rgba(0,0,0,0.9);
}
.simStats{
  display:none;
  margin-top:4px;
  font-family:var(--mono);
  font-size:.74rem;
  color:var(--muted);
  line-height:1.0;
}
.battleSummaryBlock{
  border-radius:16px;
  border:1px solid rgba(158,104,54,.7);
  background:linear-gradient(180deg,#fbf4e7,#f4e3cf);
  padding:10px 12px;
  font-family:var(--mono);
  font-size:.82rem;
  line-height:1.45;
}
.battleSummaryTitle{
  font-weight:900;
  margin-bottom:4px;
}
.battleSummaryLine{
  margin:0 0 2px;
}
.battleSummaryDivider{
  margin:6px 0;
  border-top:1px solid rgba(158,104,54,.45);
}
.battleSummaryMeta{
  color:var(--muted);
  font-size:.78rem;
}
.battleSummaryNote{
  margin-top:8px;
  font-family:var(--sans);
  font-size:.82rem;
  color:var(--muted);
  line-height:1.3;
}
.simEvents{
  margin-top:8px;
  padding:10px 12px 8px;
  border-radius:14px;
  border:1px solid rgba(158,104,54,.55);
  background:rgba(255,243,222,0.96);
  font-family:var(--sans);
  font-size:.84rem;
  line-height:1.4;
}
.simEventLine{
  margin:0 0 4px;
  line-height:1.35;
  color:#4a2605;
}

/* Stronger contrast for battle sim log tones */
.simEvents .good{color:#32c96b;font-weight:900;}
.simEvents .bad{color:#ff4760;font-weight:900;}
.simEvents .warn{color:#6E7379;font-weight:900;}
    
    /* Offline welcome-back overlay */
    .offlineOverlay{
      position:fixed;
      inset:0;
      z-index:1900;
      display:none;
      align-items:center;
      justify-content:center;
      pointer-events:auto;
      background:
        radial-gradient(900px 700px at 10% 0%, rgba(244,208,111,.22), transparent 55%),
        radial-gradient(900px 650px at 90% 25%, rgba(192,108,59,.22), transparent 55%),
        linear-gradient(180deg, rgba(7,10,8,.96), rgba(7,10,8,.98));
      backdrop-filter: blur(4px);
    }
    .offlineOverlay[hidden]{
      display:none;
    }
    .offlineOverlay.visible{
      display:flex;
    }
    .offlineCard{
      max-width:640px;
      width:100%;
      border-radius:24px;
      border:1px solid rgba(158,104,54,.9);
      background: linear-gradient(180deg,#fbf4e7,#f4e3cf);
      box-shadow:0 18px 42px rgba(0,0,0,.65);
      padding:18px 18px 16px;
      color:var(--text);
      font-family:var(--sans);
    }
    .offlineTitle{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      margin-bottom:8px;
    }
    .offlineTitleText{
      font-family:var(--mono);
      font-size:1rem;
      letter-spacing:.06em;
      text-transform:uppercase;
      color:var(--accent);
    }
    .offlineSub{
      font-family:var(--sans);
      font-size:.78rem;
      color:var(--muted);
      margin-bottom:8px;
    }
    .offlineBody{
      font-size:.82rem;
      line-height:1.4;
      color:var(--text);
      display:flex;
      flex-direction:column;
      gap:4px;
      margin-bottom:14px;
    }
    .offlineBody p{
      margin:0;
    }
    .offlineOkRow{
      display:flex;
      justify-content:flex-end;
    }
    .offlineOkBtn{
      min-width:120px;
      padding:9px 18px;
      border-radius:999px;
      border:1px solid rgba(158,104,54,.9);
      cursor:pointer;
      background: linear-gradient(180deg,#fdf6eb,#f2e0c5);
      color:var(--text);
      font-family:var(--mono);
      font-size:.82rem;
      letter-spacing:.05em;
      text-transform:uppercase;
      box-shadow:0 10px 26px rgba(0,0,0,.45);
    }
    .offlineOkBtn:active{
      transform:translateY(1px) scale(.985);
    }

/* Intro overlay */
    .introOverlay{
      position:fixed;
      inset:0;
      z-index:2000;
      display:flex;
      align-items:stretch;
      justify-content:center;
      pointer-events:auto;
    }
    .introBackdrop{
      position:absolute;
      inset:0;
      background:
        url("Sprites/Game Intro Background.png") center/cover no-repeat,
        radial-gradient(900px 700px at 10% 0%, rgba(244,208,111,.22), transparent 55%),
        radial-gradient(900px 650px at 90% 25%, rgba(192,108,59,.22), transparent 55%),
        linear-gradient(180deg, rgba(7,10,8,.96), rgba(7,10,8,.98));
      opacity:1;
    }
    .introCenter{
      position:relative;
      z-index:1;
      flex:1;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px 14px 82px;
    }
    .introCard{
      max-width:720px;
      width:100%;
      transform: translateY(12px) scale(.97);
      opacity:0;
      animation: introPop .28s ease-out forwards;
      background: rgba(255,255,255,0.10);
      border:1px solid rgba(244,170,92,0.80);
      backdrop-filter: blur(12px);
    }
    @keyframes introPop{
      from{ transform: translateY(22px) scale(.96); opacity:0; }
      to{ transform: translateY(0) scale(1); opacity:1; }
    }
    .introNameBlock{
      margin:10px 0 12px;
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .introLabel{
      font-family:var(--mono);
      font-size:.8rem;
      /* warm parchment text colour */
      color:rgb(246, 224, 178);
    }
    .introNameBlock input{
      border-radius:18px;
      border:1px solid rgba(158, 104, 54, 0.95);
      background: linear-gradient(180deg, rgba(24, 14, 8, 0.96), rgba(18, 10, 6, 0.97));
      padding:10px 12px;
      font-family:var(--mono);
      font-size:.86rem;
      color:rgb(249, 233, 196);
      outline:none;
      width:100%;
    }
    .introNameBlock input::placeholder{
      color:rgba(249, 233, 196, .55);
    }
    .introNameBlock input:focus{
      border-color: rgba(244,208,111,.9);
      box-shadow: 0 0 0 1px rgba(244,208,111,.35);
    }
    .introDemo{
      margin-top:4px;
      border-radius:18px;
      border:1px solid rgba(31,58,42,.85);
      padding:10px 10px;
      display:flex;
      gap:10px;
      align-items:stretch;
      background: linear-gradient(180deg, rgba(10,16,13,.9), rgba(7,10,8,.9));
    }
    .introDemoText{
      flex:1;
      display:flex;
      flex-direction:column;
      gap:4px;
      min-width:0;
      padding-right:4px;
    }
    .introDemoTitle{
      font-family:var(--mono);
      font-size:.84rem;
      color:var(--accent);
      font-weight:900;
    }
    .introDemoDesc{
      font-family:var(--sans);
      font-size:.8rem;
      color:var(--muted);
      line-height:1.35;
    }
    .introDemoBtn{
      border-radius:18px;
      border:1px solid rgba(244,208,111,.45);
      background: linear-gradient(180deg, rgba(244,208,111,.18), rgba(244,208,111,.08));
      padding:10px 10px;
      font-family:var(--mono);
      font-size:.76rem;
      color:var(--text);
      cursor:pointer;
      display:flex;
      flex-direction:column;
      justify-content:center;
      gap:4px;
      min-width:0;
      box-shadow: 0 10px 26px rgba(0,0,0,.42);
      touch-action:manipulation;
    }
    .introDemoBtn:active{
      transform: translateY(1px) scale(.985);
    }
    .introDemoMain{
      font-size:.86rem;
    }
    .introDemoMeta{
      font-size:.78rem;
      color:var(--muted);
    }
    .introStartBtn{
      margin-top:12px;
    }
    .introOverlay[hidden]{
      display:none;
    }

.blur{
  backdrop-filter: blur(4px);
}


/* === Creamy parchment + high-contrast black text theme overrides === */

:root{
  --panel:#f7f0e2;
  --panel2:#f1e2c7;
  --text:#111111;
  --muted:#333333;
  --accent:#f4b04a;
  --ok:#14854c;
}

/* Main cards */
.card{
  background: linear-gradient(180deg, var(--panel), var(--panel2));
  border: 1px solid rgba(244,170,92,.9);
  border-radius: var(--radius);
  box-shadow: 0 18px 42px rgba(0,0,0,.55);
  backdrop-filter: none;
  color: var(--text);
}

/* Section headers ("Village", "Legion", etc.) */
.sectionTitle{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
  font-family:var(--mono);
  color:var(--muted);
  font-size:.78rem;
  padding:12px 14px;
  border-bottom:1px solid rgba(158,104,54,.45);
  background: linear-gradient(
    180deg,
    rgba(255,248,234,.98),
    rgba(244,216,176,.96)
  );
}
.sectionTitle span:first-child{
  color:var(--accent);
}
.sectionTitle b{
  color:var(--text);
}

/* Big primary button (Collect Tribute) */
.bigBtn{
  width:100%;
  border:1px solid rgba(158,104,54,.9);
  background: linear-gradient(180deg,#fdf6eb,#f2e0c5);
  color:var(--text);
  border-radius:22px;
  padding:18px 16px;
  font-family:var(--mono);
  box-shadow:0 16px 40px rgba(0,0,0,.45);
}
.bigBtn:hover{
  border-color:rgba(244,208,111,.8);
}

/* Big name / title inside primary button */
.bigName{
  color:var(--accent);
}

/* Secondary small buttons ("Build Huts", nav tabs etc.) */
.smallBtn{
  border:1px solid rgba(158,104,54,.9);
  background: linear-gradient(180deg,#fdf6eb,#f2e0c5);
  color:var(--text);
  border-radius:18px;
  padding:14px 14px;
}
.smallBtn .t{
  font-weight:900;
  color:var(--accent);
  font-size:.92rem;
}
.smallBtn .d{
  font-family:var(--sans);
  color:var(--muted);
  font-size:.74rem;
  line-height:1.25;
}

/* Generic pill (top resources) */
.pill{
  border:1px solid rgba(244,170,92,.7);
  background: rgba(255,255,255,0.5);
  border-radius:999px;
  padding:6px 10px;
  font-family:var(--mono);
  font-size:.78rem;
  white-space:nowrap;
  color:var(--text);
}

/* Objective / nav tabs */
.tab{
  border:1px solid rgba(244,170,92,.9);
  background: rgba(255,255,255,0.4);
  color:var(--text);
  border-radius:999px;
  padding:10px 12px;
  font-family:var(--mono);
  font-size:.78rem;
}
.tab.active{
  color:var(--text);
  border-color:rgba(244,170,92,1);
}
.tab[disabled]{
  opacity:.6;
  cursor:not-allowed;
  filter:none;
}

/* Logs */
.miniLog{
  margin-top:10px;
  border-radius:16px;
  border:1px solid rgba(158,104,54,.55);
  background: linear-gradient(180deg,#fbf4e7,#f4e3cf);
  backdrop-filter:none;
  overflow:hidden;
}
.miniLogHeader{
  padding:6px 10px;
  font-family:var(--mono);
  font-size:.76rem;
  letter-spacing:.02em;
  text-transform:uppercase;
  color:var(--muted);
  border-bottom:1px solid rgba(158,104,54,.4);
  background: linear-gradient(180deg,#f3e1c7,#ebd2b3);
}
.log{
  margin-top:10px;
  max-height:28vh;
  overflow:auto;
  border-radius:18px;
  border:1px solid rgba(158,104,54,.55);
  background:#fdf8ee;
  backdrop-filter:none;
  padding:12px;
  font-family:var(--mono);
  font-size:.76rem;
  line-height:1.45;
  color:var(--text);
}
.log-time{
  opacity:.75;
  font-size:.72rem;
  min-width:44px;
  text-align:right;
  user-select:none;
  color:var(--muted);
}

/* Good/warn/bad accents still use semantic colours */
.good{color:var(--ok);font-weight:900;}
.bad{color:var(--danger);font-weight:900;}
.warn{color:var(--warn);font-weight:900;}

/* Stats table */
.table{
  width:100%;
  border-collapse:separate;
  border-spacing:0 8px;
  font-family:var(--mono);
  font-size:.78rem;
  color:var(--text);
}
.table td{
  padding:10px 12px;
  border:1px solid rgba(158,104,54,.45);
  background: linear-gradient(180deg,#fbf5ea,#f3e4cf);
}
.table td:first-child{
  border-radius:14px 0 0 14px;
  color:var(--muted);
  width:46%;
}
.table td:last-child{
  border-radius:0 14px 14px 0;
  text-align:right;
}

/* Danger rows in stats */
.danger{
  border-color:rgba(255,107,107,.55) !important;
}

/* Ensure generic text colour on cards/logs/stats is black */
.card, .log, .miniLog, .table, .table td, .smallBtn, .bigBtn{
  color:var(--text);
}


/* === Remove top header strip, keep floating counters === */
header{
  background: transparent !important;
  border: none !important;
  padding-bottom: 0 !important;
  backdrop-filter: none !important;
}
/* Add breathing room between counters and first card */
.card:first-of-type{
  margin-top: 18px;
}


/* --- Refined battle HP bar styling (ally/enemy) --- */
.battleBar{
  position: relative;
  display: inline-block;
  max-width: 280px;
  width: 100%;
  border-radius: 999px;
  overflow: hidden;
  box-shadow: 0 10px 24px rgba(0,0,0,0.35);
  background: radial-gradient(circle at 10% 0%, rgba(255,255,255,0.55), rgba(0,0,0,0.45));
}

.battleBarSprite{
  display: block;
  width: 100%;
  height: auto;
  max-width: none;
  image-rendering: auto;
}

.battleBar::before{
  content: "";
  position: absolute;
  inset: 3px;
  border-radius: 999px;
  pointer-events: none;
  background: linear-gradient(90deg, rgba(0,0,0,0.5), transparent 35%, transparent 65%, rgba(0,0,0,0.45));
  mix-blend-mode: soft-light;
}

.battleBarCount{
  position: absolute;
  right: 18px;
  top: 50%;
  transform: translateY(-50%);
  font-family: var(--mono);
  font-size: .86rem;
  letter-spacing: .03em;
  font-weight: 600;
}

.battleBarCount--ally{
  color: #e9f9ec;
  text-shadow: 0 0 4px rgba(0,40,0,0.95);
}

.battleBarCount--enemy{
  color: #ffe6e6;
  text-shadow: 0 0 4px rgba(60,0,0,0.95);
}

@media (max-width: 520px){
  .battleBar{
    max-width: 240px;
    box-shadow: 0 8px 18px rgba(0,0,0,0.4);
  }
  .battleBarCount{
    right: 14px;
    font-size: .78rem;
  }
}


    .unitCard{
      display:flex;
      flex-direction:column;
      align-items:flex-start;
      text-align:left;
      gap:2px;
    }
    .unitHeader{
      display:flex;
      justify-content:space-between;
      width:100%;
      font-size:0.9rem;
      font-weight:600;
    }
    .unitRole{
      font-size:0.75rem;
      opacity:0.8;
    }
    .unitStats{
      display:flex;
      gap:8px;
      font-size:0.8rem;
      margin-top:2px;
    }
    .unitMeta{
      font-size:0.75rem;
      opacity:0.9;
      margin-top:2px;
    }
    
    .unitHeaderRow{
      display:flex;
      justify-content:space-between;
      align-items:center;
      width:100%;
    }
    
    .unitImg{
      width:28px;
      height:28px;
      margin-left:6px;
      object-fit:contain;
    }
    </style>
</head>
<body>
  <div id="introOverlay" class="introOverlay">
    <div class="introBackdrop"></div>
    <div class="introCenter">
      
      <section class="card introCard" id="introCard">
        <div class="cardBody" style="padding:18px 16px 18px;">
          <div class="introNameBlock">
            <label for="introNameInput" class="introLabel">Type your name</label>
            <input
              id="introNameInput"
              maxlength="18"
              autocomplete="off"
              placeholder="Your name‚Ä¶"
            />
          </div>

          <button
            class="bigBtn introStartBtn"
            id="introStartBtn"
            type="button"
            disabled
            style="margin-top:8px;"
          >
            <div class="bigLeft">
              <div class="bigName">Start</div>
            </div>
            <div class="bigRight">
              <div class="gain">Enter the village</div>
              <div class="hint" id="introHint">Pick a name to continue</div>
            </div>
          </button>
        </div>
      </section>

    </div>
  </div>

  <div id="offlineOverlay" class="offlineOverlay" hidden>
    <section class="offlineCard" role="dialog" aria-modal="true" aria-labelledby="offlineTitle">
      <div class="offlineTitle">
        <div>
          <div id="offlineTitle" class="offlineTitleText">Welcome back</div>
          <div class="offlineSub">Your village kept working while you were away.</div>
        </div>
        <div style="font-size:1.6rem;line-height:1;">‚è≥</div>
      </div>
      <div id="offlineBody" class="offlineBody">
        <!-- Filled by JS -->
      </div>
      <div class="offlineOkRow">
        <button id="offlineOkBtn" class="offlineOkBtn">OK</button>
      </div>
    </section>
  </div>

  <div id="gloryOverlay" class="offlineOverlay" hidden>
    <section class="offlineCard" role="dialog" aria-modal="true" aria-labelledby="gloryTitle">
      <div class="offlineTitle">
        <div>
          <div id="gloryTitle" class="offlineTitleText">Castrum Victoriae</div>
          <div class="offlineSub">War trophies from your victories.</div>
        </div>
        <div class="offlineSub">Glory <b id="gloryOverlayNow">0</b></div>
      </div>
      <div id="gloryBody" class="offlineBody">
        <p>Spend glory to recruit special forces with unique battlefield roles.</p>
        <div class="row2">
          <button class="smallBtn unitCard" id="btnBuyAuxilia">
            <div class="unitHeader">
              <span class="unitName">Auxilia Spearmen</span>
              <span class="unitRole">Defensive infantry</span>
            </div>
            <div class="unitStats">
              <span class="stat">‚öî 6</span>
              <span class="stat">üõ° 8</span>
              <span class="stat">‚ù§ 20</span>
            </div>
            <div class="unitMeta">
              <span class="cost">Cost: 40 glory</span>
              <span class="upkeep">‚Ä¢ Upkeep: 1.3√ó milite</span>
              <span class="owned">‚Ä¢ Owned: <b id="ownedAux">0</b></span>
            </div>
          </button>
          <button class="smallBtn unitCard" id="btnBuyEquites">
            <div class="unitHeader">
              <span class="unitName">Equites (Cavalry)</span>
              <span class="unitRole">Shock cavalry</span>
            </div>
            <div class="unitStats">
              <span class="stat">‚öî 13</span>
              <span class="stat">üõ° 4</span>
              <span class="stat">‚ù§ 18</span>
            </div>
            <div class="unitMeta">
              <span class="cost">Cost: 70 glory</span>
              <span class="upkeep">‚Ä¢ Upkeep: 1.8√ó milite</span>
              <span class="owned">‚Ä¢ Owned: <b id="ownedEquites">0</b></span>
            </div>
          </button>
        </div>
        <div class="row2" style="margin-top:8px;">
          <button class="smallBtn unitCard" id="btnBuyVeterans">
            <div class="unitHeader">
              <span class="unitName">Veteran Cohort</span>
              <span class="unitRole">Elite heavy infantry</span>
            </div>
            <div class="unitStats">
              <span class="stat">‚öî 9</span>
              <span class="stat">üõ° 10</span>
              <span class="stat">‚ù§ 24</span>
            </div>
            <div class="unitMeta">
              <span class="cost">Cost: 120 glory</span>
              <span class="upkeep">‚Ä¢ Upkeep: 2.1√ó milite</span>
              <span class="owned">‚Ä¢ Owned: <b id="ownedVets">0</b></span>
            </div>
          </button>
        </div>
      </div>
      <div class="offlineOkRow">
        <button id="gloryCloseBtn" class="offlineOkBtn">Close</button>
      </div>
    </section>
  </div>
  <div id="territoryOverlay" class="offlineOverlay" hidden>
    <section class="offlineCard" role="dialog" aria-modal="true" aria-labelledby="territoryTitle">
      <div id="territoryCardInner">
        <!-- Filled by JS when inspecting a territory -->
      </div>
    </section>
  </div>





  <header>
    <div class="wrap">
      <div class="top">
        <div>
          <h1>ElderToKing</h1>
          <p class="sub" id="subline">One main action per tab. Everything else is optional.</p>
        </div>
        <div class="hud">
          <div class="pill pill--main" id="renownPill">
            <span style="display:inline-flex;align-items:center;gap:6px;">
              <img src="Sprites/Renown Icon.png" alt="Renown" style="width:18px;height:18px;image-rendering:pixelated;">
              <span>Renown <b id="renown">0</b></span>
            </span>
          </div>
          <div class="pill">
            <span style="display:inline-flex;align-items:center;gap:6px;">
              <img src="Sprites/Denarii Icon.png" alt="Denarii" style="width:18px;height:18px;image-rendering:pixelated;">
              <span>Denarii <b id="gold">0</b></span>
            </span>
          </div>
          <div class="pill">Land <b id="landHud">0</b></div>
          <div class="pill" id="playerPill" style="display:none;">
            <span>Ruler <b id="playerNameHud"></b></span>
          </div>
        </div>
      </div>
    </div>
  </header>

  <main class="wrap" id="views">

    <!-- VILLAGE -->
    <section class="card view" data-view="village">
      <div class="sectionTitle"><span>Village</span><span style="display:flex;flex-direction:column;align-items:flex-end;gap:2px;font-size:.74rem;"><span>Income <b id="incomeRate">0</b>/s</span></span></div>
      <div class="cardBody">
        <div class="card" style="box-shadow:0 10px 24px rgba(0,0,0,.36); border-radius:18px; overflow:hidden; margin-bottom:12px;">
          <div class="sectionTitle" style="border-bottom:1px solid rgba(31,58,42,.55);">
            <span>Objectives</span><span><b id="objStreak">0</b> streak</span>
          </div>
          <div class="cardBody" style="padding:10px 12px;">
            <div id="objList" style="display:flex;flex-direction:column;gap:8px;"></div>
          </div>
        </div>

        <button class="bigBtn" id="btnTribute">
          <div class="bigLeft">
            <div class="bigName" id="tributeTitle">Collect Tribute</div>
            <div class="bigDesc">Tap for denarii. Keep your streak for extra.</div>
          </div>
          <div class="bigRight">
            <div class="gain" id="tributeGain">+0 denarii</div>
            <div class="hint" id="tributeHint">Streak x1</div>
          </div>
        </button>

        <button class="smallBtn" id="btnCashout" style="margin-top:10px; display:none;">
          <div class="t">Cash Out</div>
          <div class="d" id="cashoutDesc">Bank your streak bonus.</div>
        </button>


        <div class="row3">
          <button class="smallBtn" id="btnHut" style="display:none;">
            <div class="t">Build Huts</div>
            <div class="d" id="hutDesc">Cheap shelter. Attracts settlers.</div>
          </button>
          <button class="smallBtn" id="btnFarm">
            <div class="t">Build Farm</div>
            <div class="d" id="farmDesc">Passive income. Small but forever.</div>
          </button>
          <button class="smallBtn" id="btnVilla">
            <div class="t">Build Villa</div>
            <div class="d" id="villaDesc">Bigger income. Costs more.</div>
          </button>
        </div>

        <div class="villagePopBlock">
          <div>Population: <b id="popUsed">0</b></div>
          <div>Population Capacity: <b id="popCap">0</b></div>
          <div>Migration: <b id="migRate">0.00</b>/s</div>
        </div>

        <div class="bar"><div id="progressFill"></div></div>
        <p id="incomeBreakdown" style="margin:6px 0 0;font-size:.72rem;color:var(--muted);">
          Income: 0.00/s (net)
        </p>
        <div class="meta">
          <div>Title: <b id="title">Elder</b></div>
          <div>Next: <b id="nextTitle">Elder</b></div>
        </div>

        <div class="miniLog">
          <div class="miniLogHeader">Recent Events</div>
          <div class="log" id="log"></div>
        </div>
      </div>
    </section>

    <!-- LEGION -->
    <section class="card view" data-view="legion" hidden>
      <div class="sectionTitle"><span>‚öîÔ∏è</span><span class="milites-label"></span><span>Glory <b id="gloryNow">0</b></span></div>
      <div class="cardBody">
        <button class="bigBtn unitCard" id="btnRecruit">
          <div class="unitHeaderRow">
            <div class="unitHeader">
              <span class="unitName">Milites</span>
              <span class="unitRole">Line Infantry</span>
            </div>
            <img src="Sprites/Milites.png" class="unitImg" alt="Milite">
          </div>
          <div class="unitStats">
            <span class="stat">‚öî 7</span>
            <span class="stat">üõ° 5</span>
            <span class="stat">‚ù§ 16</span>
          </div>
          <div class="unitMeta">
            <span class="cost" id="recruitCost">Cost 0</span>
            <span class="upkeep">‚Ä¢ Upkeep: 1√ó</span>
            <span class="owned">‚Ä¢ Owned: <b id="ownedMilites">0</b></span>
          </div>
        </button>
        <button class="bigBtn unitCard" id="btnRecruitCavalry">
          <div class="unitHeaderRow">
            <div class="unitHeader">
              <span class="unitName">Cavalry</span>
              <span class="unitRole">Shock cavalry</span>
            </div>
            <img src="ElderToKing/Sprites/Cavalry.png" class="unitImg" alt="Cavalry">
          </div>
          <div class="unitStats">
            <span class="stat">‚öî 11</span>
            <span class="stat">üõ° 4</span>
            <span class="stat">‚ù§ 20</span>
          </div>
          <div class="unitMeta">
            <span class="cost" id="recruitCavCost">Cost 0</span>
            <span class="upkeep">‚Ä¢ Upkeep: 1.5√ó</span>
            <span class="owned">‚Ä¢ Owned: <b id="ownedCavalry">0</b></span>
          </div>
        </button>



        
        <div class="row2 battleRow">
          <button class="smallBtn battleCard" id="btnBattleBandits1">
            <div class="t">Crush bandits</div>
            <div class="d" id="battleBandits1Desc">10‚Äì50 enemies ‚Ä¢ quick skirmish</div>
          </button>
          <button class="smallBtn battleCard" id="btnBattleLevy">
            <div class="t">Muster your levy (local lord)</div>
            <div class="d" id="battleLevyDesc">250‚Äì500 enemies ‚Ä¢ moderate risk</div>
          </button>
          <button class="smallBtn battleCard" id="btnBattleVillageRaid">
            <div class="t">Take nearby village</div>
            <div class="d" id="battleVillageRaidDesc">500‚Äì1,000 enemies ‚Ä¢ high risk</div>
          </button>
          <button class="smallBtn battleCard" id="btnBattleSiege">
            <div class="t">Siege town</div>
            <div class="d" id="battleSiegeDesc">1,000‚Äì5,000 enemies ‚Ä¢ deadly</div>
          </button>
          <div class="hint">Renown gained from winning battles.</div>
        </div>

        
        
        <button class="smallBtn" id="btnOpenCastrum" style="margin-top:12px;">
          <div class="t">Castrum Victoriae</div>
          <div class="d">Spend glory from victories to recruit special forces.</div>
        </button>

<div class="meta">
          <div>Upkeep: <b id="legionUpkeep">0</b>/s</div>
          <div>Land: <b id="landLegion">0</b></div>
        </div>
      </div>
    </section>

    <!-- TEMPLE -->
<section class="card view" data-view="temple" hidden>
      <div class="sectionTitle"><span>Temple</span><span>Crowns <b id="crowns">0</b></span></div>
      <div class="cardBody">
        <button class="bigBtn" id="btnOffer">
          <div class="bigLeft">
            <div class="bigName">Offer to the Gods</div>
            <div class="bigDesc">Spend denarii for faith. Faith boosts crits.</div>
          </div>
          <div class="bigRight">
            <div class="gain" id="offerCost">Cost 0</div>
            <div class="hint" id="faithNow">Faith 0</div>
          </div>
        </button>

        <div class="row2">
          <button class="smallBtn" id="btnBless">
            <div class="t">Blessing</div>
            <div class="d" id="blessDesc">Short buff window. Cooldown.</div>
          </button>
          <button class="smallBtn" id="btnAscend">
            <div class="t">Ascend (Prestige)</div>
            <div class="d" id="ascendDesc">Reset for crowns (permanent boosts).</div>
          </button>
        </div>

        <div class="meta">
          <div>Crit: <b id="critRate">0%</b></div>
          <div>Buff: <b id="buffLeft">0s</b></div>
        </div>
      </div>
    </section>

    <!-- TERRITORIES (replaces old Land allocation UI) -->
    <section class="card view" data-view="land" hidden>
      <div class="sectionTitle">
        <span>Territories</span>
        <span>Total <b id="territoryCount">0</b></span>
      </div>
      <div class="cardBody">
        <p style="margin:0 0 10px;font-size:.78rem;color:var(--muted);">
          Victories add new territories to your domain.
        </p>

        <div style="margin:0 0 8px;font-size:.78rem;color:var(--muted);">
          Output: <b id="landOutputDen">+0 Denarii / tick</b>, <b id="landOutputPop">+0 Cap</b>
        </div>

        <div id="landSummaryBlock" style="margin:8px 0 6px;font-size:.78rem;color:var(--muted);display:none;">
          <!-- Filled with grouped land types, e.g. "3 Riverlands (Income), 2 Farmlands (Cap)" -->
        </div>

        <div id="territoryEmpty" style="margin:4px 0 0;font-size:.78rem;color:var(--muted);">
          You control no named territories yet. Win a battle to seize your first lands.
        </div>

        <div id="territoryList" style="margin-top:8px;display:flex;flex-direction:column;gap:6px;">
          <!-- Filled by render() with cards for each territory -->
        </div>
      </div>
    </section>


<!-- STATS -->
    <section class="card view" data-view="stats" hidden>
      <div class="sectionTitle"><span>Stats</span><span><b>Geek mode</b></span></div>
      <div class="cardBody">
        <table class="table" aria-label="All stats">
          <tbody id="statsTable"></tbody>
        </table>
        <div class="row2">
          <button class="smallBtn" id="btnExport">
            <div class="t">Copy Save</div>
            <div class="d">Copies JSON save to clipboard.</div>
          </button>
          <button class="smallBtn" id="btnReset">
            <div class="t" style="color:var(--danger);">Reset Save</div>
            <div class="d">Erase local save on this device.</div>
          </button>
        </div>
      </div>
    </section>

    <div class="toast" id="toast">Saved.</div>
  </main>

  <nav class="tabbar" aria-label="Sections">
    <button class="tab active" data-go="village"><span class="dot"></span>Village</button>
    <button class="tab" data-go="legion"><span class="dot"></span>‚öîÔ∏è</button>
<button class="tab" data-go="temple"><span class="dot"></span>Temple</button>
    <button class="tab" data-go="land"><span class="dot"></span>Land</button>
    <button class="tab" data-go="stats"><span class="dot"></span>Stats</button>
  </nav>

<script>
  "use strict";

  const $ = (q, el=document)=> el.querySelector(q);
  const $$ = (q, el=document)=> Array.from(el.querySelectorAll(q));
  const clamp = (n,min,max)=> Math.max(min, Math.min(max,n));
  const rnd = (a,b)=> Math.floor(Math.random()*(b-a+1))+a;
  const chance = (p)=> Math.random() < p;

  const STORAGE_KEY = "roman_denarii_land_loop_villagecap_v14_save";

  const unlock = {
    legion: 0,
    temple: 0,
    
    
  };

  // Define the title progression and the renown required to reach each rank.
  //
  // The original thresholds allowed players to race through the early ranks too
  // quickly, which in turn unlocked tougher battle tiers before they had
  // enough warriors. To slow early progression and make rank‚Äëups feel like
  // meaningful milestones, the renown requirements have been increased.
  // Each threshold below (except the starting Elder rank) is roughly
  // twice the former value. This keeps later titles at a similar cadence
  // while forcing players to invest more in early renown before the next
  // tier of enemies appears.
  const titles = [
    // Tier 1 ‚Äî Intra‚ÄëVillage Prestige
    { name: "Elder", need: 0 },
    { name: "Respected Elder", need: 300 },    // 150√ó2 ‚Üí 300
    { name: "Clan Speaker", need: 700 },        // 350√ó2 ‚Üí 700
    { name: "Council Elder", need: 1200 },      // 600√ó2 ‚Üí 1200
    { name: "First Elder", need: 1800 },        // 900√ó2 ‚Üí 1800

    // Tier 2 ‚Äî Clan Leadership
    { name: "Patriarch/Matriarch", need: 2600 }, // 1300√ó2 ‚Üí 2600
    { name: "High Patriarch", need: 3600 },      // 1800√ó2 ‚Üí 3600
    { name: "Great Patriarch", need: 4800 },     // 2400√ó2 ‚Üí 4800
    { name: "Clan Warden", need: 6200 },         // 3100√ó2 ‚Üí 6200
    { name: "Clan Protector", need: 7800 },      // 3900√ó2 ‚Üí 7800

    // Tier 3 ‚Äî Tribal Influence
    { name: "Village Chief", need: 9600 },       // 4800√ó2 ‚Üí 9600
    { name: "Senior Chief", need: 11600 },      // 5800√ó2 ‚Üí 11600
    { name: "Paramount Chief", need: 13800 },   // 6900√ó2 ‚Üí 13800
    { name: "Tribal Speaker", need: 16200 },    // 8100√ó2 ‚Üí 16200
    { name: "War Chief", need: 18800 },         // 9400√ó2 ‚Üí 18800
    { name: "Peace Chief", need: 21600 },       // 10800√ó2 ‚Üí 21600

    // Tier 4 ‚Äî Confederation Level
    { name: "High Chief", need: 24600 },       // 12300√ó2 ‚Üí 24600
    { name: "Warlord", need: 28000 },          // 14000√ó2 ‚Üí 28000
    { name: "Lawgiver", need: 32000 },         // 16000√ó2 ‚Üí 32000
    { name: "First Magistrate", need: 36600 }, // 18300√ó2 ‚Üí 36600
    { name: "Sacred Chief", need: 41800 },      // 20900√ó2 ‚Üí 41800
    { name: "Lord of Clans", need: 47600 },     // 23800√ó2 ‚Üí 47600

    // Tier 5 ‚Äî Protoking / Chiefdom‚ÄëState
    { name: "Protector of the People", need: 54000 }, // 27000√ó2 ‚Üí 54000
    { name: "Heir of the Ancestors", need: 61000 },   // 30500√ó2 ‚Üí 61000
    { name: 'Princeps ("First Among Equals")', need: 68800 }, // 34400√ó2 ‚Üí 68800
    { name: "Rex Designatus", need: 77400 },   // 38700√ó2 ‚Üí 77400
    { name: "High Lord", need: 87000 },        // 43500√ó2 ‚Üí 87000
    { name: "Sovereign Chief", need: 97600 },  // 48800√ó2 ‚Üí 97600

    // Tier 6 ‚Äî Kingship
    { name: "King (Rex)", need: 110000 },      // 55000√ó2 ‚Üí 110000
    { name: "High King", need: 124000 },       // 62000√ó2 ‚Üí 124000
    { name: "Divine King", need: 140000 }      // 70000√ó2 ‚Üí 140000
  ];

  const defaultState = () => ({
    created: Date.now(),
    gold: 18,
    renown: 0,

    // village economy
    tribute: 1,
    farmCount: 0,
    villaCount: 0,
    hutCount: 0,

    // legion
    warriors: 0,
    cavalry: 0,
    battlesWon: 0,

    // special forces recruited with glory
    auxilia: 0,
    equites: 0,
    veterans: 0,

    // new war prestige currency
    glory: 0,
    lifetimeGlory: 0,

    // upkeep tracking
    unpaidUpkeepSeconds: 0,
    lastUpkeepWarnAt: 0,

    // land & politics
    land: 0,
    
    landAgriculture: 0,
    landMilitary: 0,
    landHousing: 0,
    landGovernance: 0,

    // NEW: named territories captured from battles
    controlledRegions: [],
    territoryWorkers: {},
// village capacity
    population: 0,          // total settlers (includes milites)
    populationUsed: 0,      // milites using population (kept for compatibility)
    settlerProg: 0,         // fractional settlers progress

    // temple / prestige
    faith: 0,
    crowns: 0,
    buffUntil: 0,
    blessReadyAt: 0,

    // decrees from renown
    decrees: 0,

    // renown soft-tech progression
    renownPerkLevel: 0,
    lastTap: 0,
    streak: 1,
    lifetimeGold: 0,
    lifetimeRenown: 0,
    rankIdx: 0,

    // offline progression tracking
    lastSeenAt: 0,
    lifetimeOfflineSec: 0,
    // whether the player has actually entered the village (name picked)
    offlineReady: 0,

    tapsSinceCashout: 0,
    cashoutBanked: 0,

    // objectives
    objectives: null,
    objStreak: 0,

    // burst events
    feverUntil: 0,
    objDoubleUntil: 0,

    // temp buffs
    prosperUntil: 0,

    // prestige meta
    ascends: 0,
    bestStreak: 0,
    biggestCashout: 0,
    lastSettlerToastAt: 0,

    // legion hidden state
    legionMorale: 1,
    legionXp: 0,

    // identity
    playerName: "",
    introBattleDone: 0,
  });

  function normalizeState(state){
    const d = defaultState();
    if(!state || typeof state !== "object") return d;

    // Merge with defaults and coerce numbers safely
    for(const k of Object.keys(d)){
      if(!(k in state)) state[k] = d[k];
      if(typeof d[k] === "number"){
        state[k] = Number(state[k]);
        if(!Number.isFinite(state[k])) state[k] = d[k];
      }
    }

    // Arm offline system for existing saves that predate offlineReady.
    if(typeof state.offlineReady === "undefined"){
      const hasProgress =
        (state.playerName && String(state.playerName).trim().length > 0) ||
        (state.lifetimeGold && state.lifetimeGold > 0) ||
        (state.renown && state.renown > 0);
      state.offlineReady = hasProgress ? 1 : 0;
    }

    // --- Territory migration (old saves) ---
    if(!Array.isArray(state.controlledRegions)){
      state.controlledRegions = [];
    }
    // If this is an old save with land > 0 but no territories yet,
    // backfill with generic ‚ÄúClaimed Land‚Äù entries so counts stay in sync.
    if(state.controlledRegions.length === 0){
      const legacyLand = Number(state.land) || 0;
      const cap = Math.min(legacyLand, 40); // don‚Äôt spam thousands of rows
      for(let i=0;i<cap;i++){
        state.controlledRegions.push({
          id: "legacy-"+i,
          name: "Claimed Land",
          tier: 1,
          summary: "Territory claimed before the territory update.",
          trait: null,
          stage: "mature",
          specialization: null,
          project: null,
          workersAssigned: 0,
          maxWorkers: 0
        });
      }
    }

    // Ensure modern per‚Äëtile fields exist on all territories from older saves.
    for(const terr of state.controlledRegions){
      if(!terr || typeof terr !== "object") continue;
      if(typeof terr.trait === "undefined") terr.trait = null;
      if(typeof terr.stage !== "string") terr.stage = "mature";
      if(typeof terr.specialization === "undefined") terr.specialization = null;
      if(typeof terr.project === "undefined") terr.project = null;
      if(typeof terr.workersAssigned !== "number") terr.workersAssigned = 0;
      if(typeof terr.maxWorkers !== "number") terr.maxWorkers = 0;
    }
    return state;
  }

  let S = normalizeState(load()) || defaultState();

  // Offline tracking: if lastSeenAt is missing or zero, seed it from created time.
  if(!S.lastSeenAt || !Number.isFinite(S.lastSeenAt)){
    S.lastSeenAt = S.created || Date.now();
  }

  // Apply any offline progress since the last session.
  try{
    applyOfflineProgress();
  }catch(e){
    // If anything goes wrong with offline calc, just skip it rather than breaking the game.
    console && console.warn && console.warn("Offline progress failed", e);
  }

  // --- Population migration / compatibility ---

  // population = total settlers (civilians + milites). populationUsed tracks milites.
  if(typeof S.population !== "number") S.population = Math.max(0, S.populationUsed||0, S.warriors||0);
  if(typeof S.settlerProg !== "number") S.settlerProg = 0;
  if(typeof S.populationUsed !== "number") S.populationUsed = 0;
  // Ensure milites never exceed population
  if((S.warriors||0) > (S.population||0)) S.warriors = S.population;
  S.populationUsed = (S.warriors||0) + (S.cavalry||0);

  // If localStorage is empty/evicted, try IndexedDB recovery (especially on iPhone).
  recoverSaveFromIDB();
  let currentView = "village";

    // --- Robust saving on iPhone (localStorage + IndexedDB fallback) ---
  // iOS Safari can evict localStorage (especially for file:// or low-storage situations).
  // We write to BOTH localStorage and IndexedDB, and we can recover from IndexedDB if localStorage is empty.
  const SAVE_DB_NAME = "roman_kingdom_save_db_v1";
  const SAVE_STORE = "kv";

  function isStandalone(){
    try{
      return (window.matchMedia && window.matchMedia("(display-mode: standalone)").matches) || (window.navigator && window.navigator.standalone);
    }catch(e){ return false; }
  }

  function openSaveDB(){
    return new Promise((resolve, reject)=>{
      try{
        const req = indexedDB.open(SAVE_DB_NAME, 1);
        req.onupgradeneeded = ()=>{ req.result.createObjectStore(SAVE_STORE); };
        req.onsuccess = ()=> resolve(req.result);
        req.onerror = ()=> reject(req.error);
      }catch(e){ reject(e); }
    });
  }

  async function idbSet(key, value){
    try{
      const db = await openSaveDB();
      await new Promise((resolve, reject)=>{
        const tx = db.transaction(SAVE_STORE, "readwrite");
        tx.objectStore(SAVE_STORE).put(value, key);
        tx.oncomplete = ()=> resolve(true);
        tx.onerror = ()=> reject(tx.error);
      });
      db.close();
    }catch(e){}
  }

  async function idbGet(key){
    try{
      const db = await openSaveDB();
      const val = await new Promise((resolve, reject)=>{
        const tx = db.transaction(SAVE_STORE, "readonly");
        const req = tx.objectStore(SAVE_STORE).get(key);
        req.onsuccess = ()=> resolve(req.result ?? null);
        req.onerror = ()=> reject(req.error);
      });
      db.close();
      return val;
    }catch(e){
      return null;
    }
  }

  function save(silent=false){
    // Record last time we saw the player for offline progression.
    S.lastSeenAt = Date.now();
    const payload = JSON.stringify(S);
    try{ localStorage.setItem(STORAGE_KEY, payload); }catch(e){}
    // IndexedDB write (best-effort, async)
    idbSet(STORAGE_KEY, payload);
    if(!silent) toast("Saved");
  }

  function load(){
    // Fast path: localStorage
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      if(raw){
        try{ return JSON.parse(raw); }catch(e){}
      }
    }catch(e){}
    // Slow path: handled asynchronously after first render
    return null;
  }

  async function recoverSaveFromIDB(){
    const raw = await idbGet(STORAGE_KEY);
    if(!raw) return false;
    try{
      const parsed = JSON.parse(raw);
      S = normalizeState(parsed);
      try{ localStorage.setItem(STORAGE_KEY, raw); }catch(e){}
      toast("Save recovered");
      render();
      return true;
    }catch(e){
      return false;
    }
  }

// --- iPhone/iOS reliability: persistent storage + autosave + lifecycle saves ---
// iOS Safari can aggressively discard tabs; we save often and also on page hide.
(function setupReliableSaves(){
  // Ask for "persistent" storage when available (reduces eviction on some browsers)
  try{
    if(navigator.storage && navigator.storage.persist){
      navigator.storage.persist().then(()=>{}).catch(()=>{});
    }
  }catch(e){}

  // Detect whether localStorage is actually usable (Private Browsing / restrictions can break it)
  function storageWritable(){
    try{
      const k = STORAGE_KEY + "__probe";
      localStorage.setItem(k, "1");
      localStorage.removeItem(k);
      return true;
    }catch(e){
      return false;
    }
  }

  // iPhone tip: if you're running from file:// and NOT installed to Home Screen,
  // iOS can reset storage when you leave the tab. Warn once.
  try{
    const fromFile = (location && location.protocol === "file:");
    if(fromFile && !isStandalone()){
      setTimeout(()=>toast("üìå iPhone tip: install to Home Screen (Share ‚Üí Add to Home Screen) and launch from the icon for reliable saving."), 650);
    }
  }catch(e){}

  // If storage isn't writable, warn once so the user knows why resets happen.
  try{
    if(!storageWritable()){
      // Keep it subtle; also avoid blocking the game.
      setTimeout(()=>toast("‚ö†Ô∏è Saving is blocked in this mode (iPhone Private Browsing / restrictions). Open in Safari normally or add to Home Screen."), 400);
    }
  }catch(e){}

  // Debounced save helper (avoids spamming writes during rapid taps)
  let _svT = 0;
  window.scheduleSave = function scheduleSave(){
    clearTimeout(_svT);
    _svT = setTimeout(()=>{ try{ save(true); }catch(e){} }, 250);
  };

  // Autosave: iOS may kill the page without firing beforeunload reliably.
  // Keep it lightweight and frequent.
  setInterval(()=>{ try{ save(true); }catch(e){} }, 2500);

  // Save when the page is being backgrounded / suspended.
  function flushSave(){
    try{ save(true); }catch(e){}
  }
  document.addEventListener("visibilitychange", ()=>{
    if(document.visibilityState === "hidden") flushSave();
  });
  window.addEventListener("pagehide", flushSave, {capture:true});
  window.addEventListener("beforeunload", flushSave, {capture:true});
})();


  function toast(text){
    const t = $("#toast");
    t.textContent = text;
    t.classList.add("show");
    clearTimeout(toast._tm);
    toast._tm = setTimeout(()=>t.classList.remove("show"), 900);
  }

  function logLine(text, tone="") {
  const log = $("#log");
  if (!log) return;

  const wrap = document.createElement("div");
  wrap.className = "log-entry";

  const ts = new Date();
  const stamp =
    `${ts.getHours().toString().padStart(2,"0")}:` +
    `${ts.getMinutes().toString().padStart(2,"0")}`;

  // Time column
  const timeEl = document.createElement("span");
  timeEl.className = "log-time";
  timeEl.textContent = stamp;

  // Message column
  const msgEl = document.createElement("span");
  if (tone === "good" || tone === "bad" || tone === "warn") {
    msgEl.classList.add(tone);
  }
  msgEl.textContent = text;

  wrap.appendChild(timeEl);
  wrap.appendChild(msgEl);

  // Prepend newest entry at the top
  if (log.firstChild) {
    log.insertBefore(wrap, log.firstChild);
  } else {
    log.appendChild(wrap);
  }

  // Keep only the latest 4 entries
  while (log.childNodes.length > 4) {
    log.removeChild(log.lastChild);
  }

  // Always show top (newest) entries
  log.scrollTo({
    top: 0,
    behavior: "smooth"
  });
}
  // ---- Intro / naming flow ----
  let introDemoGold = 0;

  function updatePlayerNameHud(){
    const pill = $("#playerPill");
    const nameEl = $("#playerNameHud");
    if(!pill || !nameEl) return;
    if(S.playerName && S.playerName.trim()){
      nameEl.textContent = S.playerName.trim();
      pill.style.display = "inline-block";
    }else{
      pill.style.display = "none";
    }
  }

  function maybeShowIntro(){
    const overlay = $("#introOverlay");
    if(!overlay) return;

    const nameInput = $("#introNameInput");
    const startBtn  = $("#introStartBtn");
    const demoBtn   = $("#introTapBtn");
    const demoGold  = $("#introDemoGold");
    const introHint = $("#introHint");

    // If player already has a name, skip intro.
    if(S.playerName && S.playerName.trim()){
      overlay.setAttribute("hidden","hidden");
      updatePlayerNameHud();
      return;
    }

    // Show overlay
    overlay.removeAttribute("hidden");

    // Wire once
    if(demoBtn && !demoBtn._wired){
      demoBtn._wired = true;
      demoBtn.addEventListener("click", (e)=>{
        introDemoGold += 1;
        if(demoGold) demoGold.textContent = introDemoGold;
        const rect = e.currentTarget.getBoundingClientRect();
        sparkAt(rect.left + rect.width*0.75, rect.top + rect.height*0.35, 0.55);
      });
    }

    if(nameInput && !nameInput._wired){
      nameInput._wired = true;
      nameInput.addEventListener("input", ()=>{
        const raw = nameInput.value || "";
        const trimmed = raw.trim();
        S.playerName = trimmed;
        const ok = trimmed.length >= 1;
        if(startBtn){
          startBtn.disabled = !ok;
        }
        if(introHint){
          introHint.textContent = ok ? "Tap to enter the village" : "Pick a name to continue";
        }
      });
    }

    if(startBtn && !startBtn._wired){
      startBtn._wired = true;
      startBtn.addEventListener("click", ()=>{
        if(!S.playerName || !S.playerName.trim()) return;
        overlay.setAttribute("hidden","hidden");
        updatePlayerNameHud();
        // Mark that the player has properly started a run, so offline gains are valid.
        S.offlineReady = 1;
        if(typeof scheduleSave === "function") scheduleSave();
        // Intro flavour: invasion hook instead of generic welcome
        toast("Your village is being invaded!");
        // Trigger intro battle once, right after the player enters the village
        if(!S.introBattleDone && typeof startIntroBattle === "function"){
          setTimeout(()=> startIntroBattle(), 650);
        }
      });
    }
  }


  function sparkAt(x,y,gold=0.25){
    const n = 6;
    // gold: 0..1. Higher = warmer, brighter coins.
    const g = clamp(gold, 0, 1);
    const bright = 1 + g*0.45;     // 1.00 .. 1.45
    const sat    = 1 + g*1.10;     // 1.00 .. 2.10
    const hue    = g*12;           // subtle warm shift
    const glowA  = 0.10 + g*0.55;  // glow alpha
    for(let i=0;i<n;i++){
      const s = document.createElement("div");
      s.className = "spark";
      s.style.left = x+"px";
      s.style.top  = y+"px";
      s.style.setProperty("--dx", `${rnd(-90,90)}px`);
      s.style.setProperty("--dy", `${rnd(-140,-40)}px`);
      // Tint coins based on intensity (crit/cashout/jackpot)
      s.style.filter =
        `drop-shadow(0 10px 18px rgba(0,0,0,.35)) `+
        `drop-shadow(0 0 ${8 + g*18}px rgba(255, 215, 120, ${glowA})) `+
        `hue-rotate(${hue}deg) saturate(${sat}) brightness(${bright})`;
      document.body.appendChild(s);
      setTimeout(()=> s.remove(), 700);
    }
  }


  // --- Rank up celebration: confetti + popup + follow-up toast ---

  function rankTierLabel(tier){
    if(tier === 1) return "Title Tier I";
    if(tier === 2) return "Title Tier II";
    if(tier === 3) return "Title Tier III";
    if(tier === 4) return "Title Tier IV";
    if(tier === 5) return "Title Tier V";
    return "High Tier";
  }

  function rankUpFlavorLine(tier){
    const poolByTier = {
      1: [
        "The village finally understands who is in charge.",
        "Fireside whispers turn into open praise."
      ],
      2: [
        "Clans begin measuring themselves against you.",
        "Your banner is becoming a rallying point."
      ],
      3: [
        "Warbands start to offer their steel first.",
        "Tribes weigh their plans around your mood."
      ],
      4: [
        "Councils fall quiet when you enter the hall.",
        "Borders shift a little when you nod."
      ],
      5: [
        "Whole realms tighten their defenses at your name.",
        "You‚Äôre no longer just a leader ‚Äî you‚Äôre an era."
      ]
    };
    const pool = poolByTier[tier] || poolByTier[5];
    const i = rnd(0, pool.length - 1);
    return pool[i];
  }

  function rankUpConfettiBurst(){
    try{
      const vw = window.innerWidth || 400;
      const vh = window.innerHeight || 700;
      const bursts = 16;
      for(let i=0; i<bursts; i++){
        const x = rnd(Math.floor(vw*0.12), Math.floor(vw*0.88));
        const y = rnd(Math.floor(vh*0.12), Math.floor(vh*0.55));
        // nice, bright ‚Äúroyal‚Äù coins
        sparkAt(x, y, 0.85);
      }
    }catch(e){}
  }

  function showRankUpPopup(cfg){
  const titleName   = cfg.titleName   || "New Title";
  const tier        = cfg.tier        || 1;
  const tributeGain = cfg.tributeGain || 1;
  const gainedRanks = cfg.gainedRanks || 1;

  const tierLabel   = rankTierLabel(tier);
  const flavour     = rankUpFlavorLine(tier);

  const overlay = document.createElement("div");
  overlay.style.position = "fixed";
  overlay.style.inset = "0";
  overlay.style.display = "flex";
  overlay.style.alignItems = "center";
  overlay.style.justifyContent = "center";
  overlay.style.zIndex = "1200";

  const backdrop = document.createElement("div");
  backdrop.style.position = "absolute";
  backdrop.style.inset = "0";
  backdrop.style.background = "rgba(0,0,0,.55)";
  backdrop.style.backdropFilter = "blur(4px)";

  const card = document.createElement("section");
  card.className = "card";
  card.style.position = "relative";
  card.style.maxWidth = "420px";
  card.style.width = "92%";
  card.style.maxHeight = "80vh";
  card.style.overflow = "auto";
  card.style.zIndex = "10";

  const header = document.createElement("div");
  header.className = "sectionTitle";
  header.style.justifyContent = "center";
  const headerSpan = document.createElement("span");
  headerSpan.style.color = "var(--accent)";
  headerSpan.style.fontWeight = "900";
  headerSpan.textContent = "Rank Up!";
  header.appendChild(headerSpan);

  const body = document.createElement("div");
  body.className = "cardBody";

  const p = document.createElement("p");
  p.style.fontSize = ".85rem";
  p.style.margin = "0 0 10px";
  p.textContent = flavour;

  const infoBlock = document.createElement("div");
  infoBlock.style.marginBottom = "10px";

  const label = document.createElement("div");
  label.style.fontFamily = "var(--sans)";
  label.style.fontSize = ".84rem";
  label.style.color = "var(--muted)";
  label.style.marginBottom = "2px";
  label.textContent = "New title";

  const titleDiv = document.createElement("div");
  titleDiv.style.fontSize = "1.12rem";
  titleDiv.style.fontWeight = "700";
  titleDiv.textContent = titleName;

  const meta = document.createElement("div");
  meta.style.fontFamily = "var(--mono)";
  meta.style.fontSize = ".80rem";
  meta.style.marginTop = "6px";
  meta.style.color = "var(--muted)";
  let metaText = tierLabel + " ¬∑ Tribute base +" + tributeGain;
  if(gainedRanks > 1){
    metaText += " ¬∑ +" + gainedRanks + " ranks at once";
  }
  meta.textContent = metaText;

  infoBlock.appendChild(label);
  infoBlock.appendChild(titleDiv);
  infoBlock.appendChild(meta);

  const btn = document.createElement("button");
  btn.type = "button";
  btn.className = "smallBtn";
  btn.style.width = "100%";
  btn.style.marginTop = "8px";
  btn.id = "rankUpOkBtn";
  btn.textContent = "Continue";

  body.appendChild(p);
  body.appendChild(infoBlock);
  body.appendChild(btn);

  card.appendChild(header);
  card.appendChild(body);

  overlay.appendChild(backdrop);
  overlay.appendChild(card);

  const close = ()=>{
    try{
      if(overlay && overlay.parentNode){
        overlay.parentNode.removeChild(overlay);
      }
    }catch(e){}
    toast("New title: " + titleName);
  };

  btn.addEventListener("click", close);
  overlay.addEventListener("click", (ev)=>{
    if(ev.target === overlay) close();
  });

  document.body.appendChild(overlay);
  rankUpConfettiBurst();
}
  // ---- Scalind + rates (make it LAST longer) ----
  function crownMult(){
    // very strong long-term scaling, but gradual
    return 1 + (S.crowns * 0.12);
  }
  function landMult(){
    return 1 + (S.land * 0.05);
  }
function decreeMult(){
    return 1 + (S.decrees * 0.07);
  }

  // --- Land allocation (plots) hybrid system ---
  function totalLandPlots(){
    const land = S.land || 0;
    if(land <= 0) return 0;
    // Hybrid: soft diminishing (sqrt) scaled, on top of tier-based land rewards.
    return Math.floor(Math.sqrt(land) * 4);
  }
  function usedLandPlots(){
    return (S.landAgriculture||0) + (S.landMilitary||0) + (S.landHousing||0) + (S.landGovernance||0);
  }
  function freeLandPlots(){
    return Math.max(0, totalLandPlots() - usedLandPlots());
  }

  function landAllocIncomeMult(){
    return 1 + (S.landAgriculture||0) * 0.04;
  }
  function landAllocPopMult(){
    return 1 + (S.landHousing||0) * 0.04;
  }
  function landAllocLegionMult(){
    const m = S.landMilitary||0;
    if(m <= 0) return 1;
    // Diminishing returns + cap: strong early, but not runaway.
    const bonus = 0.025 * Math.sqrt(m); // e.g. m=16 ‚Üí +10%, m=64 ‚Üí +20%
    return 1 + Math.min(bonus, 0.75);   // cap at +75% strength
  }
  function warriorUpkeepPerSec(){
    const w   = S.warriors || 0;
    const cav = S.cavalry  || 0;
    const aux = S.auxilia  || 0;
    const eq  = S.equites  || 0;
    const vet = S.veterans || 0;

    const totalUnits = w + cav + aux + eq + vet;
    if(totalUnits <= 0) return 0;

    // Base upkeep per milite per second (heavier than before).
    let perMil = 0.04;

    // Special forces count as heavier to maintain.
    const weightMil = 1.0;
    const weightCav = 1.5; // mounted, better paid
    const weightAux = 1.3; // better equipped infantry
    const weightEq  = 1.8; // elite cavalry
    const weightVet = 2.1; // elite pay + gear

    let effectiveCount =
      (w   * weightMil) +
      (cav * weightCav) +
      (aux * weightAux) +
      (eq  * weightEq)  +
      (vet * weightVet);

    // Agriculture + villas + land (Agriculture) soften upkeep.
    const foodRelief =
      1 - Math.min(
        0.45,
        (S.farmCount * 0.0025) +
        (S.villaCount * 0.0035) +
        ((S.landAgriculture || 0) * 0.011)
      );

    // Military plots also make milites cheaper to maintain.
    const milRelief =
      1 - Math.min(0.30, (S.landMilitary || 0) * 0.0065);

    let mult = foodRelief * milRelief;

    // Very large armies are disproportionately expensive to keep in the field.
    if(effectiveCount > 60){
      mult *= 1 + Math.log10(effectiveCount - 50) * 0.35;
    }

    // Never let upkeep vanish completely.
    mult = Math.max(0.45, mult);

    let upkeep = effectiveCount * perMil * mult;

    // If your economy is tiny but you somehow have a big army,
    // scale upkeep down a bit so it doesn't instantly implode new runs.
    const inc = incomePerSec();
    if(inc > 0){
      const maxShare = 0.85; // upkeep can eat at most 85% of steady income
      upkeep = Math.min(upkeep, inc * maxShare);
    }

    return upkeep;
  }

  function landAllocRenownMult(){
    const g = S.landGovernance||0;
    if(g <= 0) return 1;
    // Diminishing returns + cap so renown can't spiral.
    const bonus = 0.02 * Math.sqrt(g);  // e.g. g=25 ‚Üí +10%, g=100 ‚Üí +20%
    return 1 + Math.min(bonus, 0.6);    // cap at +60% renown
  }

  function incomePerSec(){
    let farm = S.farmCount * 0.75;
    // Soft cap: without land, extra farms become less effective (nudges you into the land loop)
    const softCap = 6 + (S.land * 2);
    if(S.farmCount > softCap){
      farm *= Math.max(0.60, 1 - (S.farmCount - softCap) * 0.04);
    }
    const villa = S.villaCount * 3.0;
    const landWork = landWorkersIncome();
    const base = farm + villa + landWork;
    const prosper = (Date.now() < (S.prosperUntil||0)) ? 1.5 : 1.0;
    // Land allocation (Agriculture) further boosts income.
    return base * landMult() * landAllocIncomeMult() * decreeMult() * crownMult() * prosper;
  }

  // --- Migration rate (settlers per second) ---
  // Kept in one place so UI and simulation stay consistent.
  
  // --- Migration rate (settlers per second) ---
  // Includes infinite scaling from tap streak (logarithmic, no hard cap)
  function migrationPerSec(){
    // How fast new settlers join per second.
    // Tweaked so that new people visibly arrive as you build up,
    // especially once you have a few farms/villas online.
    const prosper = (Date.now() < (S.prosperUntil||0)) ? 1.5 : 1.0;

    const baseRate = 0.08; // baseline trickle
    const incomeRate = clamp(incomePerSec()/140, 0, 0.35);
    const sizeRate =
      (S.villaCount||0)*0.010 +
      (S.farmCount||0)*0.0045 +
      (S.hutCount||0)*0.0045;
    const landRate = (S.land||0)*0.0018;

    // üî• Streak-based attraction (infinite, diminishing returns)
    const streak = Math.max(1, S.streak||1);
    const streakMult = 1 + Math.log10(streak) * 0.30;

    // üåü Renown perk: famous realms attract more settlers.
    const ren = S.renown || 0;
    const renMult = 1 + Math.log10(1 + ren/200) * 0.25;

    const raw = (baseRate + incomeRate + sizeRate + landRate)
      * prosper
      * streakMult
      * renMult;

    // Upper cap slightly higher so mid‚Äëgame villages actually fill.
    return clamp(raw, 0.03, 1.4);
  }


  // ---- Village Economy Loop ----
  function populationCap(){
    // Farms provide housing; villas attract families; land improves efficiency.
    // Simple + readable:
    // - Each hut supports 3 people
    // - Each farm supports 5 people
    // - Each villa supports 14 people (bigger households)
    // - Land boosts overall capacity a bit more
    const base = (S.hutCount * 3) + (S.farmCount * 5) + (S.villaCount * 14);
    return Math.floor(base * (1 + S.land * 0.10) * landAllocPopMult());
  }
  function hasVillageCapacity(){
    return (S.population || 0) < populationCap();
  }

  function applyStreak(){
    const now = Date.now();
    const prev = S.streak || 0;
    if(now - (S.lastTap || 0) <= 2600){
      // Infinite streak: no upper cap, just timing-based
      S.streak = prev + 1;
    }else{
      S.streak = 1;
    }
    S.lastTap = now;

    // Objective: reach a streak threshold (counts when you hit/hold it)
    bumpObjective("streak", Math.max(0, S.streak - (prev||0)));

    // Track best streak across all runs
    if(!S.bestStreak || S.streak > S.bestStreak){
      S.bestStreak = S.streak;
    }

    // Streak milestone bursts every 25 taps
    if(S.streak > 0 && S.streak % 25 === 0){
      maybeBurst("streak");
    }
  }

  function critChance(){
    // faith boosts crit chance; buff doubles it
    const base = 0.08 + clamp(S.faith / 12000, 0, 0.18);
    const boosted = isBuffed() ? base * 1.9 : base;
    return clamp(boosted, 0.06, 0.30);
  }

  function isBuffed(){ return Date.now() < S.buffUntil; }

  function tapGain(){
    const base = S.tribute + rankTributeBonus(titleInfo().idx) + rushBonus();
    const streakBonus = 1 + Math.min(0.35, (S.streak-1)*0.018);
    const pMult = landMult() * decreeMult() * crownMult();
    const feverMult = (Date.now() < (S.feverUntil || 0)) ? 2.5 : 1;
    const didCrit = chance(critChance());
    let critMult = 1;
    if(didCrit){
      // Variable crits: feels spikier than a flat 2x.
      critMult = rnd(2, 4); // 2x‚Äì4x, inclusive
    }
    const gain = Math.round(base * streakBonus * pMult * feverMult * critMult);
    return { gain, crit: didCrit, critMult };
  }


  // ---- Streak timer + Gold Rush ----
  const STREAK_WINDOW_MS = 3000;

  function streakTimeLeftMs(){
    if(!S.lastTap) return STREAK_WINDOW_MS;
    return Math.max(0, STREAK_WINDOW_MS - (Date.now() - S.lastTap));
  }

  function expireStreakIfNeeded(){
    // Don‚Äôt let the streak expire while a defensive popup is on screen
    if(window.defenceOverlayOpen) return;

    if(S.streak > 1 && S.lastTap && (Date.now() - S.lastTap) > STREAK_WINDOW_MS){
      S.streak = 1;
    }
  }

  function rushBonus(){
    // Infinite "gold rush" growth: every 10 streak adds a small flat bonus to tap base.
    // Slow enough to not break balance, but feels endless.
    const milestones = Math.max(0, Math.floor((S.streak - 1) / 10));
    return Math.round(milestones * 0.15 * 10) / 10; // +0.15 per milestone, rounded to 0.1
  }


  // ---- Costs (ramp hard so it isn't beaten in 2 mins) ----
  function costHut(){
    // Cheap early housing that becomes gradually more expensive
    const n = S.hutCount||0;
    return Math.floor(60 * Math.pow(1.22, n));
  }

  function costFarm(){
    return 320;
  }
  function costVilla(){
    return 5200;
  }


  function recruitCost(){
    return 220;
  }

  function cavalryRecruitCost(){
    return 900;
  }

  function recruitStrengthGain(){
    return 6;
  }

    function recalcLegionStrength(){
    // Aggregate legion stats from unit types (milites + cavalry + special forces).
    const warriors = Math.max(0, S.warriors || 0);
    const cav      = Math.max(0, S.cavalry  || 0);
    const aux      = S.auxilia  || 0;
    const equites  = S.equites  || 0;
    const veterans = S.veterans || 0;

    // Base per-unit stats (can be tuned later).
    const MIL = { atk: 7,  def: 5,  hp: 16 };
    const CAV = { atk: 11, def: 4,  hp: 20 };
    const AUX = { atk: 6,  def: 8,  hp: 20 };
    const EQ  = { atk: 13, def: 4,  hp: 18 };
    const VET = { atk: 9,  def: 10, hp: 24 };

    let atk = warriors * MIL.atk + cav * CAV.atk + aux * AUX.atk + equites * EQ.atk + veterans * VET.atk;
    let def = warriors * MIL.def + cav * CAV.def + aux * AUX.def + equites * EQ.def + veterans * VET.def;
    let hp  = warriors * MIL.hp  + cav * CAV.hp  + aux * AUX.hp  + equites * EQ.hp  + veterans * VET.hp;

    // Clamp a bit so tiny legions still have some footprint.
    atk = Math.max(0, atk);
    def = Math.max(0, def);
    hp  = Math.max(0, hp);

    return {
      atk,
      def,
      hp,
      warriors,
      cav,
      aux,
      equites,
      veterans
    };
  }

// --- Battles  ---
  const BATTLE_SETS = [
    [
      { label:"Break Up Farm Brawl", enemyMin:8, enemyMax:14 },
      { label:"Defend Stray Herd", enemyMin:6, enemyMax:11 },
      { label:"Drive Off Rustlers", enemyMin:6, enemyMax:12 },
      { label:"Feud at the Wall", enemyMin:5, enemyMax:10 }
    ], // Elder
    [
      { label:"Break Up Farm Brawl", enemyMin:15, enemyMax:15 },
      { label:"Defend Stray Herd", enemyMin:15, enemyMax:15 },
      { label:"Drive Off Rustlers", enemyMin:10, enemyMax:20 },
      { label:"Feud at the Wall", enemyMin:10, enemyMax:20 }
    ], // Respected Elder
    [
      { label:"Break Up Farm Brawl", enemyMin:20, enemyMax:25 },
      { label:"Defend Stray Herd", enemyMin:20, enemyMax:25 },
      { label:"Drive Off Rustlers", enemyMin:15, enemyMax:25 },
      { label:"Feud at the Wall", enemyMin:15, enemyMax:25 }
    ], // Clan Speaker
    [
      { label:"Break Up Farm Brawl", enemyMin:30, enemyMax:35 },
      { label:"Defend Stray Herd", enemyMin:25, enemyMax:35 },
      { label:"Drive Off Rustlers", enemyMin:20, enemyMax:35 },
      { label:"Feud at the Wall", enemyMin:20, enemyMax:35 }
    ], // Council Elder
    [
      { label:"Break Up Farm Brawl", enemyMin:35, enemyMax:40 },
      { label:"Defend Stray Herd", enemyMin:30, enemyMax:40 },
      { label:"Drive Off Rustlers", enemyMin:30, enemyMax:40 },
      { label:"Feud at the Wall", enemyMin:25, enemyMax:40 }
    ], // First Elder
    [
      { label:"Clan Border Skirmish", enemyMin:30, enemyMax:35 },
      { label:"Retribution Raid", enemyMin:30, enemyMax:35 },
      { label:"Defend Ancestral Fields", enemyMin:25, enemyMax:40 },
      { label:"Honor Retinue Clash", enemyMin:25, enemyMax:40 }
    ], // Patriarch/Matriarch
    [
      { label:"Clan Border Skirmish", enemyMin:45, enemyMax:50 },
      { label:"Retribution Raid", enemyMin:40, enemyMax:55 },
      { label:"Defend Ancestral Fields", enemyMin:35, enemyMax:55 },
      { label:"Honor Retinue Clash", enemyMin:30, enemyMax:60 }
    ], // High Patriarch
    [
      { label:"Clan Border Skirmish", enemyMin:60, enemyMax:70 },
      { label:"Retribution Raid", enemyMin:55, enemyMax:70 },
      { label:"Defend Ancestral Fields", enemyMin:45, enemyMax:70 },
      { label:"Honor Retinue Clash", enemyMin:40, enemyMax:75 }
    ], // Great Patriarch
    [
      { label:"Clan Border Skirmish", enemyMin:75, enemyMax:85 },
      { label:"Retribution Raid", enemyMin:70, enemyMax:85 },
      { label:"Defend Ancestral Fields", enemyMin:60, enemyMax:90 },
      { label:"Honor Retinue Clash", enemyMin:50, enemyMax:90 }
    ], // Clan Warden
    [
      { label:"Clan Border Skirmish", enemyMin:95, enemyMax:100 },
      { label:"Retribution Raid", enemyMin:80, enemyMax:105 },
      { label:"Defend Ancestral Fields", enemyMin:70, enemyMax:105 },
      { label:"Honor Retinue Clash", enemyMin:60, enemyMax:105 }
    ], // Clan Protector
    [
      { label:"Village Raid", enemyMin:80, enemyMax:90 },
      { label:"Hill Ambush", enemyMin:75, enemyMax:95 },
      { label:"Border River Battle", enemyMin:70, enemyMax:105 },
      { label:"Seasonal Warband Clash", enemyMin:60, enemyMax:110 }
    ], // Village Chief
    [
      { label:"Village Raid", enemyMin:110, enemyMax:120 },
      { label:"Hill Ambush", enemyMin:100, enemyMax:130 },
      { label:"Border River Battle", enemyMin:90, enemyMax:135 },
      { label:"Seasonal Warband Clash", enemyMin:80, enemyMax:140 }
    ], // Senior Chief
    [
      { label:"Village Raid", enemyMin:140, enemyMax:155 },
      { label:"Hill Ambush", enemyMin:125, enemyMax:160 },
      { label:"Border River Battle", enemyMin:110, enemyMax:165 },
      { label:"Seasonal Warband Clash", enemyMin:95, enemyMax:170 }
    ], // Paramount Chief
    [
      { label:"Village Raid", enemyMin:170, enemyMax:190 },
      { label:"Hill Ambush", enemyMin:150, enemyMax:195 },
      { label:"Border River Battle", enemyMin:130, enemyMax:200 },
      { label:"Seasonal Warband Clash", enemyMin:110, enemyMax:200 }
    ], // Tribal Speaker
    [
      { label:"Village Raid", enemyMin:200, enemyMax:225 },
      { label:"Hill Ambush", enemyMin:180, enemyMax:225 },
      { label:"Border River Battle", enemyMin:155, enemyMax:230 },
      { label:"Seasonal Warband Clash", enemyMin:130, enemyMax:230 }
    ], // War Chief
    [
      { label:"Village Raid", enemyMin:235, enemyMax:255 },
      { label:"Hill Ambush", enemyMin:205, enemyMax:260 },
      { label:"Border River Battle", enemyMin:175, enemyMax:260 },
      { label:"Seasonal Warband Clash", enemyMin:145, enemyMax:260 }
    ], // Peace Chief
    [
      { label:"Subdue Rebel Clan", enemyMin:200, enemyMax:220 },
      { label:"Assault Palisaded Hamlet", enemyMin:185, enemyMax:240 },
      { label:"Battle at Council Field", enemyMin:170, enemyMax:260 },
      { label:"Sacred Grove Showdown", enemyMin:155, enemyMax:280 }
    ], // High Chief
    [
      { label:"Subdue Rebel Clan", enemyMin:290, enemyMax:320 },
      { label:"Assault Palisaded Hamlet", enemyMin:260, enemyMax:335 },
      { label:"Battle at Council Field", enemyMin:235, enemyMax:355 },
      { label:"Sacred Grove Showdown", enemyMin:205, enemyMax:370 }
    ], // Warlord
    [
      { label:"Subdue Rebel Clan", enemyMin:380, enemyMax:420 },
      { label:"Assault Palisaded Hamlet", enemyMin:340, enemyMax:435 },
      { label:"Battle at Council Field", enemyMin:295, enemyMax:445 },
      { label:"Sacred Grove Showdown", enemyMin:255, enemyMax:460 }
    ], // Lawgiver
    [
      { label:"Subdue Rebel Clan", enemyMin:470, enemyMax:515 },
      { label:"Assault Palisaded Hamlet", enemyMin:415, enemyMax:530 },
      { label:"Battle at Council Field", enemyMin:360, enemyMax:540 },
      { label:"Sacred Grove Showdown", enemyMin:305, enemyMax:555 }
    ], // First Magistrate
    [
      { label:"Subdue Rebel Clan", enemyMin:560, enemyMax:615 },
      { label:"Assault Palisaded Hamlet", enemyMin:490, enemyMax:625 },
      { label:"Battle at Council Field", enemyMin:425, enemyMax:635 },
      { label:"Sacred Grove Showdown", enemyMin:355, enemyMax:645 }
    ], // Sacred Chief
    [
      { label:"Subdue Rebel Clan", enemyMin:650, enemyMax:715 },
      { label:"Assault Palisaded Hamlet", enemyMin:570, enemyMax:720 },
      { label:"Battle at Council Field", enemyMin:485, enemyMax:730 },
      { label:"Sacred Grove Showdown", enemyMin:405, enemyMax:735 }
    ], // Lord of Clans
    [
      { label:"Crush Tax Revolt", enemyMin:500, enemyMax:550 },
      { label:"Punish Defiant Chief", enemyMin:460, enemyMax:600 },
      { label:"Cross-Valley Incursion", enemyMin:425, enemyMax:650 },
      { label:"Siege Border Stronghold", enemyMin:385, enemyMax:700 }
    ], // Protector of the People
    [
      { label:"Crush Tax Revolt", enemyMin:860, enemyMax:945 },
      { label:"Punish Defiant Chief", enemyMin:770, enemyMax:990 },
      { label:"Cross-Valley Incursion", enemyMin:685, enemyMax:1040 },
      { label:"Siege Border Stronghold", enemyMin:595, enemyMax:1085 }
    ], // Heir of the Ancestors
    [
      { label:"Crush Tax Revolt", enemyMin:1220, enemyMax:1340 },
      { label:"Punish Defiant Chief", enemyMin:1085, enemyMax:1385 },
      { label:"Cross-Valley Incursion", enemyMin:945, enemyMax:1425 },
      { label:"Siege Border Stronghold", enemyMin:810, enemyMax:1470 }
    ], // Princeps ("First Among Equals")
    [
      { label:"Crush Tax Revolt", enemyMin:1580, enemyMax:1740 },
      { label:"Punish Defiant Chief", enemyMin:1395, enemyMax:1775 },
      { label:"Cross-Valley Incursion", enemyMin:1205, enemyMax:1815 },
      { label:"Siege Border Stronghold", enemyMin:1020, enemyMax:1855 }
    ], // Rex Designatus
    [
      { label:"Crush Tax Revolt", enemyMin:1940, enemyMax:2135 },
      { label:"Punish Defiant Chief", enemyMin:1705, enemyMax:2170 },
      { label:"Cross-Valley Incursion", enemyMin:1470, enemyMax:2205 },
      { label:"Siege Border Stronghold", enemyMin:1230, enemyMax:2240 }
    ], // High Lord
    [
      { label:"Crush Tax Revolt", enemyMin:2300, enemyMax:2530 },
      { label:"Punish Defiant Chief", enemyMin:2015, enemyMax:2560 },
      { label:"Cross-Valley Incursion", enemyMin:1730, enemyMax:2595 },
      { label:"Siege Border Stronghold", enemyMin:1445, enemyMax:2625 }
    ], // Sovereign Chief
    [
      { label:"Throne Claimant Rebellion", enemyMin:2000, enemyMax:2200 },
      { label:"Grand Campaign of Conquest", enemyMin:1845, enemyMax:2400 },
      { label:"Coalition War", enemyMin:1695, enemyMax:2600 },
      { label:"Storm the Rival Capital", enemyMin:1540, enemyMax:2800 }
    ], // King (Rex)
    [
      { label:"Throne Claimant Rebellion", enemyMin:4700, enemyMax:5170 },
      { label:"Grand Campaign of Conquest", enemyMin:4160, enemyMax:5315 },
      { label:"Coalition War", enemyMin:3620, enemyMax:5455 },
      { label:"Storm the Rival Capital", enemyMin:3080, enemyMax:5600 }
    ], // High King
    [
      { label:"Throne Claimant Rebellion", enemyMin:7400, enemyMax:8140 },
      { label:"Grand Campaign of Conquest", enemyMin:6475, enemyMax:8225 },
      { label:"Coalition War", enemyMin:5545, enemyMax:8315 },
      { label:"Final Divine Showdown", enemyMin:4620, enemyMax:8400 }
    ], // Divine King
  ];
function battleTierFromTitleIdx(idx){
    if(idx <= 4) return 1;
    if(idx <= 9) return 2;
    if(idx <= 15) return 3;
    if(idx <= 21) return 4;
    if(idx <= 27) return 5;
    return 6;
  }

  function battleDifficultyForTier(tier){
    if(tier <= 1) return { baseStars: 1, name: "Easy" };
    if(tier === 2) return { baseStars: 2, name: "Normal" };
    if(tier === 3) return { baseStars: 3, name: "Hard" };
    if(tier === 4) return { baseStars: 4, name: "Very Hard" };
    return { baseStars: 5, name: "Deadly" };
  }

  function battleRarityFromStars(stars){
    if(stars <= 1) return "Common";
    if(stars === 2) return "Uncommon";
    if(stars === 3) return "Rare";
    if(stars === 4) return "Epic";
    return "Mythic";
  }


  function battleFactionMetaForTier(tier, kind, min, max){
    const maxEnemies = max || min || 0;
    let scale;
    if(maxEnemies <= 40)      scale = "Small";
    else if(maxEnemies <= 200) scale = "Medium";
    else if(maxEnemies <= 800) scale = "Large";
    else                       scale = "Huge";

    let icon = "‚öîÔ∏è";
    let name = "Warband";
    let order = "Disciplined";

    if(tier <= 1){
      icon = "üó°";
      name = "Bandits";
      order = "Disorganized";
    }else if(tier === 2){
      icon = "‚öîÔ∏è";
      name = "Clan Raiders";
      order = "Loose warbands";
    }else if(tier === 3){
      icon = "‚öîÔ∏è";
      name = "Levy of Local Lord";
      order = "Disciplined";
    }else if(tier === 4){
      icon = "üè∞";
      name = "Town Militia";
      order = "Fortified";
    }else if(tier === 5){
      icon = "üè∞";
      name = "City Garrison";
      order = "Veteran garrison";
    }else{
      icon = "üëë";
      name = "Royal Host";
      order = "Elite host";
    }

    return { icon, name, scale, order };
  }

  function battleOutcomeLabel(kind, tier){
    if(kind === "skirmish") return "Outcome: Gold + small renown";
    if(kind === "feud"){
      return tier <= 2
        ? "Outcome: Renown, small chance of territory"
        : "Outcome: Renown + chance of territory";
    }
    if(kind === "field") return "Outcome: Renown + territory";
    if(kind === "siege") return "Outcome: High renown + territory";
    return "Outcome: Renown";
  }


  // Narrative battle archetypes by tier (Hybrid: title tier √ó slot)
  // kind:
  //  - "skirmish"  ‚Üí never grants land
  //  - "feud"      ‚Üí may grant land at higher tiers
  //  - "field"     ‚Üí always territorial
  //  - "siege"     ‚Üí always territorial, heavier land

  
const BATTLE_ARCHETYPES = {
    1: [
      {
        label: "Drive Off the Ridge Herders",
        kind: "skirmish",
        short: "Border skirmish",
        flavour: "Clans test your borders with small herds."
      },
      {
        label: "Settle the Winter Grazing Feud",
        kind: "feud",
        short: "Grazing feud",
        flavour: "A boundary quarrel draws spears to the wall."
      },
      {
        label: "Seize the Lower Pastures",
        kind: "field",
        short: "Pasture field",
        flavour: "Hold the meadows that feed your village."
      },
      {
        label: "Enclose the Village Palisade",
        kind: "siege",
        short: "Village siege",
        flavour: "Timber walls decide who rules this place."
      }
    ],

    2: [
      {
        label: "Break the Spring Muster at the River Ford",
        kind: "skirmish",
        short: "River skirmish",
        flavour: "A rival clan gathers men where the road runs shallow."
      },
      {
        label: "Subdue the March-Lord of Senna",
        kind: "feud",
        short: "March feud",
        flavour: "A frontier lord refuses your voice in his valley."
      },
      {
        label: "Secure the Broad Valley of Ilma",
        kind: "field",
        short: "Valley field",
        flavour: "Levies muster along the slopes above Ilma."
      },
      {
        label: "Storm the Hill-Fort at Narrow Gate",
        kind: "siege",
        short: "Hill-fort siege",
        flavour: "One gate, one crest, and all the uplands follow."
      }
    ],

    3: [
      {
        label: "Scatter the League Scouts at Reed-Bank",
        kind: "skirmish",
        short: "League skirmish",
        flavour: "League riders test the strength of your watch."
      },
      {
        label: "Answer the League‚Äôs Tribute Demands",
        kind: "feud",
        short: "Tribute feud",
        flavour: "Merchants arrive with terms backed by spears."
      },
      {
        label: "Command the Valley of Three Rivers",
        kind: "field",
        short: "River-valley field",
        flavour: "Three valleys meet; whoever holds them sets the toll."
      },
      {
        label: "Break the Tribal Stronghold of Fen-Croft",
        kind: "siege",
        short: "Tribal siege",
        flavour: "A fen-ringed timber keep shelters your rivals."
      }
    ],

    4: [
      {
        label: "Intercept Confederation Riders",
        kind: "skirmish",
        short: "Confed skirmish",
        flavour: "Messengers race between confederate chiefs."
      },
      {
        label: "Punish the March Coalition‚Äôs Envoys",
        kind: "feud",
        short: "Coalition feud",
        flavour: "Envoys arrive under arms and speak as equals."
      },
      {
        label: "Contest the Confederation Granary Basin",
        kind: "field",
        short: "Granary field",
        flavour: "Grain stores and river land decide the winter."
      },
      {
        label: "Besiege the Confederation Citadel at River-Bend",
        kind: "siege",
        short: "Citadel siege",
        flavour: "A stone keep crowns the bend where two rivers meet."
      }
    ],

    5: [
      {
        label: "Test the Provincial Muster at Low-Ford",
        kind: "skirmish",
        short: "Provincial skirmish",
        flavour: "Provincial banners appear at the shallows."
      },
      {
        label: "Humiliate the Provincial Tax-Farmers",
        kind: "feud",
        short: "Tax feud",
        flavour: "Collectors return with short tribute and long complaints."
      },
      {
        label: "Reduce the Tributary Valley of Altar-Kings",
        kind: "field",
        short: "Tributary field",
        flavour: "Old altar-stones mark a valley that pays two masters."
      },
      {
        label: "Compel Submission of the Provincial Seat",
        kind: "siege",
        short: "Provincial siege",
        flavour: "The province‚Äôs officers shelter behind old walls."
      }
    ],

    6: [
      {
        label: "Scatter the Royal Scouts of the March",
        kind: "skirmish",
        short: "Royal skirmish",
        flavour: "The king‚Äôs riders taste the edge of your realm."
      },
      {
        label: "Defy the Royal Magistrate of the Cross-Road",
        kind: "feud",
        short: "Royal feud",
        flavour: "A royal judge arrives with laws and escorts."
      },
      {
        label: "Enforce Dominion over the River-Marches",
        kind: "field",
        short: "River-march field",
        flavour: "Whole marches decide whether to bow or bleed."
      },
      {
        label: "Take the Captaincy of the Tributary Citadel",
        kind: "siege",
        short: "Royal siege",
        flavour: "The garrison decides who truly rules this frontier."
      }
    ]
  };

  const FRONTIER_PRAENOMEN = [
    "Varro","Lucius","Hostor","Marus","Aulus","Caius","Secundus",
    "Tatius","Brennus","Florus","Silvanus","Drusus","Cassian"
  ];
  const FRONTIER_COGNOMEN = [
    "Tatius","Brennus","of Three Rivers","of the Fen","of the Ridge",
    "of Low-Ford","of Senna","of the March","of the Lower Valley",
    "of Reed-Bank","of Narrow Gate","of the Granary Basin"
  ];

  function sample(arr){
    return arr[Math.floor(Math.random() * arr.length)];
  }

  

  // House / faction identity by tier: early Italic ‚Üí later Roman-provincial
  const HOUSE_ROOTS_TRIBAL = [
    "Tasca","Verro","Serri","Caian","Varno","Tarru","Marro","Hostor","Silvan","Druso"
  ];
  const HOUSE_ROOTS_ROMAN = [
    "Domitia","Flaminia","Claudiana","Tarquitia","Valeria","Aemilia","Cornelia","Fabia"
  ];

  // Faction "classes" stay extremely short and minimal for card readability.
  const HOUSE_CLASSES_TRIBAL = [
    "Bandits","Rustlers","Hill Raiders","Cattle-Thieves","Marsh Bandits"
  ];
  const HOUSE_CLASSES_MARCHER = [
    "Levies","Banners","Marchers","Retinue","Shieldmen"
  ];
  const HOUSE_CLASSES_ROMAN = [
    "Decurions","Procurators","Auxilia","Cohorts","Tribunes"
  ];

  function makeHouseIdentity(tier, kind){
    let roots, classes;
    if(tier <= 2){
      // Early Italic tribal: short clan-style roots and pastoral classes
      roots = HOUSE_ROOTS_TRIBAL;
      classes = HOUSE_CLASSES_TRIBAL;
    }else if(tier <= 4){
      // Marcher / levy era: same roots, more organised military classes
      roots = HOUSE_ROOTS_TRIBAL;
      classes = HOUSE_CLASSES_MARCHER;
    }else{
      // Late-game: mixture of Italic and Romanised houses with civic/military classes
      roots = Math.random() < 0.5 ? HOUSE_ROOTS_TRIBAL : HOUSE_ROOTS_ROMAN;
      classes = HOUSE_CLASSES_ROMAN;
    }

    const root = sample(roots);
    const cls  = sample(classes);
    const label = `${root} ‚Äî ${cls}`;
    return { root, cls, label };
  }


  function makeBattleContext(tier, slot, arch, baseDef){
    const kind = arch && arch.kind || "";
    // Generate a house / faction identity that persists per tier+slot until defeated.
    const house = makeHouseIdentity(tier, kind);
    const leader = house.label;
    const min = baseDef.enemyMin;
    const max = baseDef.enemyMax;
    const approx = (min === max) ? `${min}` : `${min}‚Äì${max}`;

    // Base difficulty from title tier
    const baseDiff = battleDifficultyForTier(tier);
    let stars = baseDiff.baseStars;

    // Rarity roll: most cards stay at base difficulty, some roll higher
    const roll = Math.random();
    if(roll > 0.97){
      stars += 2;
    }else if(roll > 0.85){
      stars += 1;
    }
    stars = clamp(stars, 1, 5);

    const rarity = battleRarityFromStars(stars);

    let doing;
    if(arch && arch.flavour){
      doing = arch.flavour;
    }else if(arch && arch.kind === "skirmish"){
      doing = "Their riders test the edges of your land.";
    }else if(arch && arch.kind === "feud"){
      doing = "A feud spills over your borders.";
    }else if(arch && arch.kind === "field"){
      doing = "Two sides gather to decide who holds the ground.";
    }else if(arch && arch.kind === "siege"){
      doing = "A garrison braces behind its walls.";
    }else{
      doing = "Steel gathers somewhere beyond your boundary.";
    }
    return {
      tier,
      slot,
      label: arch && arch.label || baseDef.label,
      kind: arch && arch.kind,
      leader,
      approx,
      doing,
      difficultyStars: stars,
      difficultyName: baseDiff.name,
      rarityLabel: rarity
    };
  }

  function getBattleContext(tier, slot, arch, baseDef){
    if(typeof S !== "object") return makeBattleContext(tier, slot, arch, baseDef);
    if(!S.battleContexts) S.battleContexts = {};
    const key = tier + ":" + slot;
    const existing = S.battleContexts[key];
    const archLabel = arch && arch.label || baseDef.label;
    if(existing && existing.label === archLabel){
      return existing;
    }
    const ctx = makeBattleContext(tier, slot, arch, baseDef);
    S.battleContexts[key] = ctx;
    return ctx;
  }
function battleArchetypeFor(tier, slot){
    const t = BATTLE_ARCHETYPES[tier] || BATTLE_ARCHETYPES[1];
    return t && t[slot] ? t[slot] : t ? t[0] : null;
  }

  function currentBattleSet(){
    const { idx } = titleInfo();
    return BATTLE_SETS[Math.min(idx, BATTLE_SETS.length-1)];
  }


  
// === Land Type Effects (flat base output) ===
const LAND_TYPE_EFFECTS = {
  // Tier 1 ‚Äî pure land features
  "Riverlands":      { den: 2, pop: 1 },
  "Forest Edge":     { den: 1, pop: 1 },
  "Farmlands":       { den: 1, pop: 2 },
  "Grazing Commons": { den: 1, pop: 1 },
  "Marsh Flats":     { den: 0, pop: 1 },
  "Old Quarry":      { den: 2, pop: 0 },

  // Tier 2 ‚Äî small holdings
  "Orchard Lands":   { den: 2, pop: 2 },
  "Timber Stand":    { den: 2, pop: 1 },
  "Streamford":      { den: 2, pop: 2 },
  "Outlying Stead":  { den: 1, pop: 2 },

  // Tier 3 ‚Äî hamlets & villages
  "Palisaded Hamlet": { den: 3, pop: 3 },
  "River Village":    { den: 4, pop: 4 },
  "Hill Village":     { den: 3, pop: 4 },
  "Market Crossing":  { den: 5, pop: 4 },

  // Tier 4 ‚Äî fortified / sacred / trade
  "Walled Village":    { den: 5, pop: 5 },
  "Council Field":     { den: 2, pop: 3 },
  "Shrine Settlement": { den: 3, pop: 3 },
  "Trade Road":        { den: 6, pop: 2 },

  // Tier 5 ‚Äî forts, mines, groves, town
  "Border Fort":  { den: 4, pop: 3 },
  "Mineworks":    { den: 6, pop: 2 },
  "Sacred Grove": { den: 3, pop: 2 },
  "Growing Town": { den: 8, pop: 6 },

  // Tier 6 ‚Äî realm-scale holdings
  "Border Stronghold": { den: 7, pop: 5 },
  "Regional Capital":  { den: 10, pop: 10 },
  "Great Market":      { den: 12, pop: 6 },
  "Subdued Seat":      { den: 6, pop: 6 },

  // Legacy generic types (for very old saves)
  "Hamlet":       { den: 3, pop: 3 },
  "Village":      { den: 5, pop: 6 },
  "Market Town":  { den: 8, pop: 8 },
  "Stronghold":   { den: 6, pop: 4 },
  "City":         { den: 12, pop: 12 }
};


function landBaseIncome(){
  if(!Array.isArray(S.controlledRegions)) return 0;
  let sum = 0;
  for(const r of S.controlledRegions){
    const eff = LAND_TYPE_EFFECTS[r.name];
    if(eff && eff.den) sum += eff.den;
  }
  return sum;
}

function landBasePopCap(){
  if(!Array.isArray(S.controlledRegions)) return 0;
  let sum = 0;
  for(const r of S.controlledRegions){
    const eff = LAND_TYPE_EFFECTS[r.name];
    if(eff && eff.pop) sum += eff.pop;
  }
  return sum;
}


function totalTypeWorkers(){
  if(!S.territoryWorkers) return 0;
  let sum = 0;
  for(const k in S.territoryWorkers){
    if(!Object.prototype.hasOwnProperty.call(S.territoryWorkers, k)) continue;
    sum += S.territoryWorkers[k] || 0;
  }
  return sum;
}

// Simple per-worker land income; each worker is worth +0.4 denarii/s.
function landWorkersIncome(){
  if(!S.territoryWorkers) return 0;
  let sum = 0;
  for(const k in S.territoryWorkers){
    if(!Object.prototype.hasOwnProperty.call(S.territoryWorkers, k)) continue;
    const w = S.territoryWorkers[k] || 0;
    sum += w * 0.4;
  }
  return sum;
}

function adjustTypeWorkers(name, delta){
  if(!name || !delta) return;
  if(!Array.isArray(S.controlledRegions)) return;

  if(!S.territoryWorkers) S.territoryWorkers = {};
  const arr = S.controlledRegions.filter(t => t && t.name === name);
  const tiles = arr.length;
  if(tiles <= 0){
    return;
  }
  const maxWorkers = tiles * 5; // 5 labourers per tile

  let workers = S.territoryWorkers[name] || 0;

  if(delta > 0){
    if(workers >= maxWorkers){
      if(typeof toast === "function") toast("This land can't use more workers yet.");
      return;
    }
    const totalPop = Number(S.population || 0);
    const milites = Number(S.populationUsed || 0);
    const civils = Math.max(0, totalPop - milites);
    const elsewhere = totalTypeWorkers() - workers;
    const free = Math.max(0, civils - elsewhere);
    if(free <= 0){
      if(typeof toast === "function") toast("No free population to assign.");
      return;
    }
    workers += 1;
  }else if(delta < 0){
    if(workers <= 0) return;
    workers -= 1;
  }

  S.territoryWorkers[name] = workers;
  if(typeof scheduleSave === "function") scheduleSave();
  render();
}



function updateTerritoryProjects(){
  if(!Array.isArray(S.controlledRegions)) return;
  const now = Date.now();
  let changed = false;
  for(const terr of S.controlledRegions){
    if(!terr || !terr.project || terr.stage !== "developing") continue;
    if(!terr.project.endsAt) continue;
    if(now >= terr.project.endsAt){
      terr.stage = "mature";
      // For now, workers remain assigned, representing ongoing work/production.
      changed = true;
    }
  }
  if(changed && typeof scheduleSave === "function"){
    scheduleSave();
  }
}

function landDevelopmentBonuses(){
  if(!Array.isArray(S.controlledRegions)) return { den: 0, pop: 0 };
  let bonusDen = 0;
  let bonusPop = 0;

  for(const terr of S.controlledRegions){
    if(!terr || terr.stage !== "mature" || !terr.specialization) continue;
    const specList = TERRITORY_SPECIALIZATIONS[terr.name];
    if(!specList) continue;
    const spec = specList.find(s => s.id === terr.specialization);
    if(!spec) continue;
    if(spec.bonusDen) bonusDen += spec.bonusDen;
    if(spec.bonusPop) bonusPop += spec.bonusPop;
  }
  return { den: bonusDen, pop: bonusPop };
}

// Simple emoji icon per territory type for the detail header.
function territoryIcon(name){
  switch(name){
    case "Riverlands": return "üåä";
    case "Forest Edge": return "üå≤";
    case "Farmlands": return "üåæ";
    case "Grazing Commons": return "üêÑ";
    case "Marsh Flats": return "ü™µ";
    case "Old Quarry": return "‚õèÔ∏è";
    case "Orchard Lands": return "üçé";
    case "Timber Stand": return "ü™ì";
    case "Streamford": return "üåâ";
    case "Outlying Stead": return "üèöÔ∏è";
    case "Palisaded Hamlet": return "üèòÔ∏è";
    case "River Village": return "üèûÔ∏è";
    case "Hill Village": return "‚õ∞Ô∏è";
    case "Market Crossing": return "üõ£Ô∏è";
    case "Walled Village": return "üß±";
    case "Council Field": return "‚öñÔ∏è";
    case "Shrine Settlement": return "‚õ©Ô∏è";
    case "Trade Road": return "üõ§Ô∏è";
    case "Border Fort": return "üõ°Ô∏è";
    case "Mineworks": return "‚öíÔ∏è";
    case "Sacred Grove": return "üå≥";
    case "Growing Town": return "üèôÔ∏è";
    case "Border Stronghold": return "üè∞";
    case "Regional Capital": return "üèõÔ∏è";
    case "Great Market": return "üí∞";
    case "Subdued Seat": return "üëë";
    default: return "üèûÔ∏è";
  }
}

// Lightweight flavour traits per land type.
// These are mostly cosmetic for now, but are shown on the tile card.
const TERRITORY_TRAITS = {
  "Riverlands": [
    "Fertile banks (+busy river trade)",
    "Slow meanders (easy crossings)",
    "Steep banks (harder to work)"
  ],
  "Forest Edge": [
    "Old growth line (good timber)",
    "Brushy fringe (thick undergrowth)",
    "Game-rich margins (plenty of deer)"
  ],
  "Farmlands": [
    "Fertile soil (+good harvests)",
    "Gentle slopes (easy to plough)",
    "Stony patches (harder to till)"
  ],
  "Grazing Commons": [
    "Sheltered pasture (+healthy herds)",
    "Windy upland (tough grazing)",
    "Wet lowland (boggy ground)"
  ],
  "Marsh Flats": [
    "Reed-choked pools",
    "Treacherous bog",
    "Migratory bird haven"
  ],
  "Old Quarry": [
    "Deep-cut stone faces",
    "Abandoned workings",
    "Rich in useful rubble"
  ],
  "Orchard Lands": [
    "Well-tended groves",
    "Scattered old trees",
    "Blossom-rich rows"
  ],
  "Timber Stand": [
    "Straight trunks (good beams)",
    "Mixed growth",
    "Younger saplings"
  ],
  "Streamford": [
    "Shallow ford (easy crossing)",
    "Rocky bed (careful footing)",
    "Braided channels"
  ],
  "Outlying Stead": [
    "Hardy families",
    "Old palisade",
    "Lonely watch-fire"
  ],
  "Palisaded Hamlet": [
    "Sturdy ditch and bank",
    "Overlooked by a hill",
    "Crowded timber walls"
  ],
  "River Village": [
    "Busy ferry landing",
    "Net-lines along the bank",
    "Quayside sheds"
  ],
  "Hill Village": [
    "Terraced slopes",
    "Wind-scoured ridge",
    "Stone-built houses"
  ],
  "Market Crossing": [
    "Four-road junction",
    "Permanent stalls",
    "Seasonal fairs"
  ],
  "Walled Village": [
    "Guarded gate",
    "Low stone curtain",
    "Watch platforms"
  ],
  "Council Field": [
    "Speaker's mound",
    "Ring of old stones",
    "Tall ash at centre"
  ],
  "Shrine Settlement": [
    "Ancient altar",
    "Spring-sanctuary",
    "Pilgrim shelters"
  ],
  "Trade Road": [
    "Well-packed surface",
    "Posting-stations",
    "Milestones"
  ],
  "Border Fort": [
    "Ditch and rampart",
    "Timber tower",
    "Beacon hill"
  ],
  "Mineworks": [
    "Deep adits",
    "Ore carts",
    "Smoke-stained sheds"
  ],
  "Sacred Grove": [
    "Circle of oaks",
    "Whispering pines",
    "Clear spring"
  ],
  "Growing Town": [
    "New streets", "Bustling market", "Crammed tenements"
  ],
  "Border Stronghold": [
    "High walls", "Deep cistern", "Old armoury"
  ],
  "Regional Capital": [
    "Grand forum", "Governor's hall", "Marbled streets"
  ],
  "Great Market": [
    "Foreign traders", "Counting houses", "Covered stalls"
  ],
  "Subdued Seat": [
    "Old royal hall", "Tamed banners", "Quiet courtyards"
  ]
};

function rollTerritoryTrait(name){
  const options = TERRITORY_TRAITS[name];
  if(!options || !options.length) return null;
  const idx = Math.floor(Math.random() * options.length);
  return options[idx];
}

// Per-type development specialisations.
// Each entry describes a project the player can start on that tile.
const TERRITORY_SPECIALIZATIONS = {
  "Farmlands": [
    {
      id: "cereal_fields",
      label: "Develop Wheat Fields",
      description: "Turn the open land into orderly cereal fields.",
      costGold: 120,
      costPop: 2,
      durationDays: 7,
      bonusDen: 0,
      bonusPop: 1,
      maxWorkers: 4
    },
    {
      id: "vineyard",
      label: "Plant Vineyard (Luxury)",
      description: "Plant vines that slowly become valuable.",
      costGold: 300,
      costPop: 3,
      durationDays: 30,
      bonusDen: 1,
      bonusPop: 0,
      maxWorkers: 3
    },
    {
      id: "pasture",
      label: "Prepare Pasture (Livestock)",
      description: "Fence and seed the land for grazing herds.",
      costGold: 150,
      costPop: 2,
      durationDays: 10,
      bonusDen: 0,
      bonusPop: 1,
      maxWorkers: 4
    }
  ],
  "Riverlands": [
    {
      id: "irrigated_fields",
      label: "Lay Irrigated Fields",
      description: "Channel riverwater to nearby plots.",
      costGold: 180,
      costPop: 2,
      durationDays: 10,
      bonusDen: 0,
      bonusPop: 1,
      maxWorkers: 3
    },
    {
      id: "river_tradepost",
      label: "Establish River Trade Post",
      description: "Build a jetty and huts for barge traffic.",
      costGold: 260,
      costPop: 2,
      durationDays: 16,
      bonusDen: 2,
      bonusPop: 0,
      maxWorkers: 3
    }
  ],
  "Forest Edge": [
    {
      id: "logging_camp",
      label: "Set Up Logging Camp",
      description: "Organise woodcutters and timber hauling.",
      costGold: 140,
      costPop: 2,
      durationDays: 9,
      bonusDen: 2,
      bonusPop: 0,
      maxWorkers: 4
    },
    {
      id: "hunting_grounds",
      label: "Mark Hunting Grounds",
      description: "Control the game and hides coming from the forest.",
      costGold: 100,
      costPop: 1,
      durationDays: 6,
      bonusDen: 1,
      bonusPop: 1,
      maxWorkers: 3
    }
  ],
  "Grazing Commons": [
    {
      id: "herd_pasture",
      label: "Organise Herd Pasture",
      description: "Fence common land and tend larger herds.",
      costGold: 130,
      costPop: 2,
      durationDays: 8,
      bonusDen: 0,
      bonusPop: 1,
      maxWorkers: 4
    },
    {
      id: "drive_road",
      label: "Mark Drive Road",
      description: "Arrange regular herd-drives for trade.",
      costGold: 160,
      costPop: 2,
      durationDays: 11,
      bonusDen: 1,
      bonusPop: 0,
      maxWorkers: 3
    }
  ],
  "Marsh Flats": [
    {
      id: "reed_grounds",
      label: "Exploit Reed Grounds",
      description: "Harvest reeds, herbs and bog products.",
      costGold: 80,
      costPop: 1,
      durationDays: 5,
      bonusDen: 1,
      bonusPop: 0,
      maxWorkers: 2
    },
    {
      id: "drainage",
      label: "Begin Drainage Works",
      description: "Lay ditches towards eventual dry fields.",
      costGold: 220,
      costPop: 3,
      durationDays: 20,
      bonusDen: 0,
      bonusPop: 2,
      maxWorkers: 4
    }
  ],
  "Old Quarry": [
    {
      id: "stone_quarry",
      label: "Reopen Stone Quarry",
      description: "Restart steady stone cutting.",
      costGold: 200,
      costPop: 3,
      durationDays: 15,
      bonusDen: 2,
      bonusPop: 0,
      maxWorkers: 4
    },
    {
      id: "clay_pits",
      label: "Dig Clay Pits",
      description: "Dig clay for bricks and pottery.",
      costGold: 150,
      costPop: 2,
      durationDays: 10,
      bonusDen: 1,
      bonusPop: 0,
      maxWorkers: 3
    }
  ],
  "Orchard Lands": [
    {
      id: "intensive_orchards",
      label: "Intensive Orchards",
      description: "Replant with denser, better-yielding trees.",
      costGold: 200,
      costPop: 2,
      durationDays: 18,
      bonusDen: 1,
      bonusPop: 1,
      maxWorkers: 3
    }
  ],
  "Timber Stand": [
    {
      id: "managed_forest",
      label: "Manage Timber Stand",
      description: "Thin and mark trees for steady lumber.",
      costGold: 190,
      costPop: 2,
      durationDays: 14,
      bonusDen: 2,
      bonusPop: 0,
      maxWorkers: 4
    }
  ],
  "Streamford": [
    {
      id: "ford_market",
      label: "Found Ford Market",
      description: "Let traders pause and pay a little.",
      costGold: 210,
      costPop: 2,
      durationDays: 14,
      bonusDen: 2,
      bonusPop: 0,
      maxWorkers: 3
    }
  ],
  "Outlying Stead": [
    {
      id: "family_stead",
      label: "Build Up Farm Stead",
      description: "Support more families and storage.",
      costGold: 160,
      costPop: 2,
      durationDays: 12,
      bonusDen: 0,
      bonusPop: 1,
      maxWorkers: 4
    }
  ],
  "Palisaded Hamlet": [
    {
      id: "militia_focus",
      label: "Militia Focus",
      description: "Drill locals and strengthen defences.",
      costGold: 220,
      costPop: 2,
      durationDays: 14,
      bonusDen: 0,
      bonusPop: 1,
      maxWorkers: 3
    },
    {
      id: "market_focus",
      label: "Market Focus",
      description: "Encourage stalls around the gate.",
      costGold: 240,
      costPop: 2,
      durationDays: 14,
      bonusDen: 2,
      bonusPop: 0,
      maxWorkers: 3
    }
  ],
  "River Village": [
    {
      id: "fishing_quarter",
      label: "Fishing Quarter",
      description: "Boats, nets and riverside sheds.",
      costGold: 230,
      costPop: 2,
      durationDays: 16,
      bonusDen: 1,
      bonusPop: 1,
      maxWorkers: 4
    }
  ],
  "Hill Village": [
    {
      id: "terraced_fields",
      label: "Terraced Fields",
      description: "Cut terraces into the slope.",
      costGold: 210,
      costPop: 2,
      durationDays: 16,
      bonusDen: 0,
      bonusPop: 2,
      maxWorkers: 4
    }
  ],
  "Market Crossing": [
    {
      id: "toll_rights",
      label: "Grant Toll Rights",
      description: "Formalise market-tolls on the crossing.",
      costGold: 260,
      costPop: 2,
      durationDays: 18,
      bonusDen: 3,
      bonusPop: 0,
      maxWorkers: 3
    }
  ],
  "Walled Village": [
    {
      id: "crafts_district",
      label: "Support Crafts District",
      description: "Give space to artisans and shops.",
      costGold: 300,
      costPop: 3,
      durationDays: 20,
      bonusDen: 3,
      bonusPop: 1,
      maxWorkers: 4
    }
  ],
  "Council Field": [
    {
      id: "formal_council",
      label: "Formalise Council",
      description: "Regular assemblies, scribes and heralds.",
      costGold: 220,
      costPop: 2,
      durationDays: 14,
      bonusDen: 1,
      bonusPop: 1,
      maxWorkers: 2
    }
  ],
  "Shrine Settlement": [
    {
      id: "pilgrim_hostel",
      label: "Build Pilgrim Hostel",
      description: "Shelter visitors and take small offerings.",
      costGold: 240,
      costPop: 2,
      durationDays: 18,
      bonusDen: 2,
      bonusPop: 0,
      maxWorkers: 3
    }
  ],
  "Trade Road": [
    {
      id: "waystation",
      label: "Establish Waystation",
      description: "Stable, inn and storehouse on the road.",
      costGold: 260,
      costPop: 3,
      durationDays: 18,
      bonusDen: 3,
      bonusPop: 0,
      maxWorkers: 4
    }
  ],
  "Border Fort": [
    {
      id: "permanent_garrison",
      label: "Station Permanent Garrison",
      description: "House and feed more professional troops.",
      costGold: 320,
      costPop: 3,
      durationDays: 22,
      bonusDen: 0,
      bonusPop: 1,
      maxWorkers: 3
    }
  ],
  "Mineworks": [
    {
      id: "deep_workings",
      label: "Expand Deep Workings",
      description: "Push new shafts and galleries.",
      costGold: 340,
      costPop: 3,
      durationDays: 24,
      bonusDen: 4,
      bonusPop: 0,
      maxWorkers: 4
    }
  ],
  "Sacred Grove": [
    {
      id: "ritual_enclosure",
      label: "Raise Ritual Enclosure",
      description: "Manage offerings and keep rites.",
      costGold: 250,
      costPop: 2,
      durationDays: 18,
      bonusDen: 1,
      bonusPop: 1,
      maxWorkers: 2
    }
  ],
  "Growing Town": [
    {
      id: "stone_quarter",
      label: "Lay Stone Quarter",
      description: "Replace shacks with lasting streets.",
      costGold: 380,
      costPop: 4,
      durationDays: 30,
      bonusDen: 4,
      bonusPop: 2,
      maxWorkers: 5
    }
  ],
  "Border Stronghold": [
    {
      id: "supply_depots",
      label: "Organise Supply Depots",
      description: "Secure grain, arms and fodder.",
      costGold: 360,
      costPop: 3,
      durationDays: 26,
      bonusDen: 2,
      bonusPop: 1,
      maxWorkers: 4
    }
  ],
  "Regional Capital": [
    {
      id: "administrative_quarter",
      label: "Grow Administrative Quarter",
      description: "Clerks, offices and courts.",
      costGold: 420,
      costPop: 4,
      durationDays: 32,
      bonusDen: 4,
      bonusPop: 2,
      maxWorkers: 5
    }
  ],
  "Great Market": [
    {
      id: "counting_houses",
      label: "Encourage Counting Houses",
      description: "Concentrate money-changing and contracts.",
      costGold: 430,
      costPop: 3,
      durationDays: 32,
      bonusDen: 5,
      bonusPop: 0,
      maxWorkers: 4
    }
  ],
  "Subdued Seat": [
    {
      id: "governors_court",
      label: "Seat Governor's Court",
      description: "Formalise rule and provincial presence.",
      costGold: 380,
      costPop: 3,
      durationDays: 30,
      bonusDen: 2,
      bonusPop: 2,
      maxWorkers: 4
    }
  ]
};

// Helper: total workers used across all territories.
function totalTerritoryWorkers(){
  if(!Array.isArray(S.controlledRegions)) return 0;
  let sum = 0;
  for(const terr of S.controlledRegions){
    if(!terr) continue;
    sum += Number(terr.workersAssigned || 0);
  }
  return sum;
}


// --- Territory detail overlay state & helpers ---
let territoryUIState = {
  name: null,
  indices: [],
  idx: 0
};

function openTerritoryOverlay(name){
  const overlay = document.getElementById("territoryOverlay");
  const inner = document.getElementById("territoryCardInner");
  if(!overlay || !inner) return;

  const arr = Array.isArray(S.controlledRegions) ? S.controlledRegions : [];
  const indices = [];
  for(let i=0;i<arr.length;i++){
    const terr = arr[i];
    if(terr && terr.name === name){
      // Ensure baseline fields exist for safety
      if(typeof terr.trait === "undefined") terr.trait = null;
      if(typeof terr.stage !== "string") terr.stage = "raw";
      if(typeof terr.specialization === "undefined") terr.specialization = null;
      if(typeof terr.project === "undefined") terr.project = null;
      if(typeof terr.workersAssigned !== "number") terr.workersAssigned = 0;
      if(typeof terr.maxWorkers !== "number") terr.maxWorkers = 0;
      // Lazily roll a trait if missing
      if(!terr.trait){
        terr.trait = rollTerritoryTrait(terr.name);
      }
      indices.push(i);
    }
  }

  if(!indices.length) return;

  territoryUIState.name = name;
  territoryUIState.indices = indices;
  territoryUIState.idx = 0;

  overlay.removeAttribute("hidden");
  overlay.classList.add("visible");
  renderTerritoryDetail();
}

function closeTerritoryOverlay(){
  const overlay = document.getElementById("territoryOverlay");
  if(overlay){
    overlay.classList.remove("visible");
    overlay.setAttribute("hidden", "hidden");
  }
}

function stepTerritory(delta){
  if(!territoryUIState.indices.length) return;
  const n = territoryUIState.indices.length;
  territoryUIState.idx = (territoryUIState.idx + delta + n) % n;
  renderTerritoryDetail();
}

function currentTerritoryRef(){
  const arr = Array.isArray(S.controlledRegions) ? S.controlledRegions : [];
  if(!territoryUIState.indices.length) return null;
  const idx = territoryUIState.indices[territoryUIState.idx] || 0;
  const terr = arr[idx];
  if(!terr) return null;
  return { terr, idx };
}


function renderTerritoryDetail(){
  const inner = document.getElementById("territoryCardInner");
  if(!inner) return;
  const ref = currentTerritoryRef();
  if(!ref) return;
  const terr = ref.terr;

  // Ensure trait exists for display
  if(!terr.trait){
    terr.trait = rollTerritoryTrait(terr.name);
  }

  const icon = territoryIcon(terr.name);
  const listCount = territoryUIState.indices.length;
  const humanIdx = territoryUIState.idx + 1;

  const eff = LAND_TYPE_EFFECTS[terr.name] || { den: 0, pop: 0 };
  const baseDen = eff.den || 0;
  const basePop = eff.pop || 0;

  let bonusDen = 0;
  let bonusPop = 0;
  const specs = TERRITORY_SPECIALIZATIONS[terr.name];
  if(specs && terr.stage === "mature" && terr.specialization){
    const spec = specs.find(s => s.id === terr.specialization);
    if(spec){
      bonusDen = spec.bonusDen || 0;
      bonusPop = spec.bonusPop || 0;
    }
  }

  const totalDen = baseDen + bonusDen;
  const totalPop = basePop + bonusPop;

  const workersNow = terr.workersAssigned || 0;
  const specForLimits = (specs || []).find(s => s.id === terr.specialization) || (specs && specs[0]);
  const maxWorkers = terr.maxWorkers || (specForLimits ? specForLimits.maxWorkers || 0 : 0);

  const stageLabel = (terr.stage === "developing") ? "Developing" :
                     (terr.stage === "mature") ? "Mature" :
                     "Raw";
  const potential = terr.summary || "";

  // --- Development section (compact) ---
  let devSection = "";
  const availableSpecs = TERRITORY_SPECIALIZATIONS[terr.name];
  if(availableSpecs && (!terr.specialization || terr.stage === "raw")){
    const optionsHtml = availableSpecs.map((s, idx) => {
      const checked = (terr.specialization ? terr.specialization === s.id : idx === 0) ? "checked" : "";
      return `
      <label style="display:block;margin:2px 0;">
        <input type="radio" name="territoryDevChoice" value="${s.id}" ${checked}>
        <b>${s.label}</b><br>
        <span style="font-size:.78rem;">
          ${fmt(s.costGold)} denarii, ${s.costPop} pop ‚Ä¢ ${s.durationDays} days
        </span>
      </label>`;
    }).join("");
    devSection = `
    <div class="offlineGroup">
      <div class="offlineGroupTitle">Development</div>
      ${optionsHtml}
      <button id="territoryStartDevBtn" class="offlineOkBtn" style="margin-top:4px;">Start</button>
    </div>`;
  } else if(terr.stage === "developing" && terr.project){
    const remainingMs = Math.max(0, (terr.project.endsAt || 0) - Date.now());
    const remainingDays = remainingMs / (1000*60*60*24);
    const remStr = remainingMs <= 0 ? "Finishing soon" : `${remainingDays.toFixed(1)} days left`;
    devSection = `
    <div class="offlineGroup">
      <div class="offlineGroupTitle">Development</div>
      <p style="font-size:.8rem;margin:2px 0 4px;">
        ${terr.project.type}<br>
        Workers: ${terr.workersAssigned || 0} ‚Ä¢ ${remStr}
      </p>
    </div>`;
  } else if(terr.stage === "mature" && terr.specialization){
    devSection = `
    <div class="offlineGroup">
      <div class="offlineGroupTitle">Development</div>
      <p style="font-size:.8rem;margin:2px 0 4px;">
        ${ (specForLimits && specForLimits.label) || terr.specialization }
      </p>
    </div>`;
  }

  const productionSummary = `
    <div class="offlineGroup">
      <div class="offlineGroupTitle">Output</div>
      <p style="font-size:.8rem;margin:2px 0 4px;">
        Denarii: +${fmt(baseDen)}${bonusDen ? " (+" + fmt(bonusDen) + ")" : ""}<br>
        Cap: +${fmt(basePop)}${bonusPop ? " (+" + fmt(bonusPop) + ")" : ""}
      </p>
    </div>`;

  const workersSection = `
    <div class="offlineGroup">
      <div class="offlineGroupTitle">Workers</div>
      <p style="font-size:.8rem;margin:2px 0 4px;">
        <button id="terrWorkerMinus" type="button" class="smallBtn" style="min-width:28px;margin:0 4px;">‚àí</button>
        <span id="terrWorkerCount">${workersNow}</span> / ${maxWorkers}
        <button id="terrWorkerPlus" type="button" class="smallBtn" style="min-width:28px;margin:0 4px;">+</button>
      </p>
    </div>`;

  inner.innerHTML = `
    <div class="offlineTitle">
      <div>
        <div id="territoryTitle" class="offlineTitleText">[${icon} ${terr.name}] ${terr.id || ""}</div>
        <div class="offlineSub">${terr.trait || ""}</div>
      </div>
      <div class="offlineSub">Territory ${humanIdx} of ${listCount} ${terr.name}</div>
    </div>
    <div class="offlineBody">
      <div class="offlineGroup">
        <div class="offlineGroupTitle">Status</div>
        <p style="font-size:.8rem;margin:2px 0 4px;">
          Stage: <b>${stageLabel}</b><br>
          ${potential ? ("Note: " + potential) : ""}<br>
          Workers: ${workersNow} / ${maxWorkers || "‚Äî"}
        </p>
      </div>

      ${devSection}

      ${workersSection}

      ${productionSummary}
    </div>
    <div class="offlineOkRow" style="justify-content:space-between;">
      <button id="territoryPrevBtn" class="offlineOkBtn" type="button">‚óÄ Prev</button>
      <div style="flex:1;"></div>
      <button id="territoryCloseBtn" class="offlineOkBtn" type="button" style="margin-right:8px;">Close</button>
      <button id="territoryNextBtn" class="offlineOkBtn" type="button">Next ‚ñ∂</button>
    </div>
  `;
// Wire buttons
  const prevBtn = document.getElementById("territoryPrevBtn");
  const nextBtn = document.getElementById("territoryNextBtn");
  const closeBtn = document.getElementById("territoryCloseBtn");
  const startBtn = document.getElementById("territoryStartDevBtn");
  const minusBtn = document.getElementById("terrWorkerMinus");
  const plusBtn = document.getElementById("terrWorkerPlus");

  if(prevBtn) prevBtn.onclick = () => stepTerritory(-1);
  if(nextBtn) nextBtn.onclick = () => stepTerritory(1);
  if(closeBtn) closeBtn.onclick = () => closeTerritoryOverlay();
  if(startBtn) startBtn.onclick = () => startTerritoryDevelopment();
  if(minusBtn) minusBtn.onclick = () => adjustTerritoryWorkers(-1);
  if(plusBtn) plusBtn.onclick = () => adjustTerritoryWorkers(1);
}

function startTerritoryDevelopment(){
  const ref = currentTerritoryRef();
  if(!ref) return;
  const terr = ref.terr;

  if(terr.stage === "developing"){
    if(typeof toast === "function") toast("This territory is already being developed.");
    return;
  }

  const specs = TERRITORY_SPECIALIZATIONS[terr.name];
  if(!specs || !specs.length){
    if(typeof toast === "function") toast("No development options for this territory type yet.");
    return;
  }

  const radios = document.querySelectorAll('input[name="territoryDevChoice"]');
  let chosenId = null;
  radios.forEach(r => { if(r.checked) chosenId = r.value; });
  if(!chosenId) chosenId = specs[0].id;

  const spec = specs.find(s => s.id === chosenId) || specs[0];
  if(!spec) return;

  const gold = Number(S.gold || 0);
  if(gold < spec.costGold){
    if(typeof toast === "function") toast("Not enough denarii for this project.");
    return;
  }

  // Free civilian workers = total population - milites - workers already assigned elsewhere.
  const totalPop = Number(S.population || 0);
  const milites = Number(S.populationUsed || 0);
  const civils = Math.max(0, totalPop - milites);
  const totalWorkersElsewhere = totalTerritoryWorkers() - (terr.workersAssigned || 0);
  const freeWorkers = Math.max(0, civils - totalWorkersElsewhere);

  if(freeWorkers < spec.costPop){
    if(typeof toast === "function") toast("Not enough free population to assign workers.");
    return;
  }

  // Pay and start project
  S.gold = gold - spec.costGold;

  const now = Date.now();
  terr.stage = "developing";
  terr.specialization = spec.id;
  terr.project = {
    type: spec.label,
    endsAt: now + (spec.durationDays * 24 * 60 * 60 * 1000),
    cost: { gold: spec.costGold, pop: spec.costPop }
  };
  terr.workersAssigned = spec.costPop;
  terr.maxWorkers = spec.maxWorkers || spec.costPop;

  if(typeof scheduleSave === "function") scheduleSave();
  if(typeof toast === "function") toast("Development started on this territory.");
  render();
  renderTerritoryDetail();
}

function adjustTerritoryWorkers(delta){
  const ref = currentTerritoryRef();
  if(!ref) return;
  const terr = ref.terr;

  const specs = TERRITORY_SPECIALIZATIONS[terr.name];
  const specForLimits = (specs || []).find(s => s.id === terr.specialization) || (specs && specs[0]);
  const maxWorkers = terr.maxWorkers || (specForLimits ? specForLimits.maxWorkers || 0 : 0);

  let workers = terr.workersAssigned || 0;
  if(delta > 0){
    if(workers >= maxWorkers) return;

    const totalPop = Number(S.population || 0);
    const milites = Number(S.populationUsed || 0);
    const civils = Math.max(0, totalPop - milites);
    const totalWorkersElsewhere = totalTerritoryWorkers() - workers;
    const freeWorkers = Math.max(0, civils - totalWorkersElsewhere);
    if(freeWorkers <= 0){
      if(typeof toast === "function") toast("No free population to assign.");
      return;
    }
    workers += 1;
  }else if(delta < 0){
    if(workers <= 0) return;
    workers -= 1;
  }

  terr.workersAssigned = workers;
  if(typeof scheduleSave === "function") scheduleSave();
  renderTerritoryDetail();
}


// === Territory Systemm (named lands instead of abstract plots) ===
  function territoryCount(){
    return Array.isArray(S.controlledRegions) ? S.controlledRegions.length : 0;
  }

  const TERRITORY_POOLS = {
  // Tier 1 ‚Äî Intra-Village Prestige: *lands*, not settlements (no "tribute from hamlets")
  1: [
    { id:"riverlands",   name:"Riverlands",       tier:1, summary:"Fertile banks that feed your village." },
    { id:"forest_edge",  name:"Forest Edge",     tier:1, summary:"Woodlots and game close to home." },
    { id:"farmlands",    name:"Farmlands",       tier:1, summary:"Open fields you can work and defend." },
    { id:"pastures",     name:"Grazing Commons", tier:1, summary:"Common pastureland for herds and carts." },
    { id:"marsh",        name:"Marsh Flats",     tier:1, summary:"Difficult ground that hides you from raiders." },
    { id:"quarry",       name:"Old Quarry",      tier:1, summary:"Stone and clay to shore up walls and huts." }
  ],

  // Tier 2 ‚Äî Clan Leadership: small holdings begin to appear
  2: [
    { id:"orchards",     name:"Orchard Lands",   tier:2, summary:"Fruit and cider for trade and feasts." },
    { id:"timber",       name:"Timber Stand",    tier:2, summary:"Good lumber for palisades and carts." },
    { id:"streamford",   name:"Streamford",      tier:2, summary:"A ford you can watch and tax lightly." },
    { id:"outstead",     name:"Outlying Stead",  tier:2, summary:"A distant homestead sworn to your clan." }
  ],

  // Tier 3 ‚Äî Tribal Influence: hamlets and villages become plausible
  3: [
    { id:"palisaded",    name:"Palisaded Hamlet", tier:3, summary:"A small hamlet protected by timber walls." },
    { id:"rivervillage", name:"River Village",    tier:3, summary:"A riverside village that boosts trade and food." },
    { id:"hillvillage",  name:"Hill Village",     tier:3, summary:"High ground that makes musters safer." },
    { id:"marketcross",  name:"Market Crossing",  tier:3, summary:"A crossroads where coin begins to flow." }
  ],

  // Tier 4 ‚Äî Confederation Level: fortified settlements and sacred sites
  4: [
    { id:"walled",       name:"Walled Village",   tier:4, summary:"Stonework and gates harden your reach." },
    { id:"councilfield", name:"Council Field",    tier:4, summary:"A meeting ground that strengthens legitimacy." },
    { id:"shrine",       name:"Shrine Settlement",tier:4, summary:"A holy place drawing pilgrims and prestige." },
    { id:"traderoad",    name:"Trade Road",       tier:4, summary:"A route that lifts steady denarii." }
  ],

  // Tier 5 ‚Äî Proto-king / Chiefdom-State: towns, forts, industry
  5: [
    { id:"bordertower",  name:"Border Fort",      tier:5, summary:"A strong point that steadies your frontier." },
    { id:"mines",        name:"Mineworks",        tier:5, summary:"Ore and coin for arms and pay." },
    { id:"sacredgrove",  name:"Sacred Grove",     tier:5, summary:"Oaths and rites bind clans to you." },
    { id:"smalltown",    name:"Growing Town",     tier:5, summary:"Markets and craftsmen expand your treasury." }
  ],

  // Tier 6 ‚Äî Kingship: capitals and major strongholds
  6: [
    { id:"stronghold",   name:"Border Stronghold", tier:6, summary:"A major fortress anchoring your realm." },
    { id:"capital",      name:"Regional Capital",  tier:6, summary:"A seat of rule where taxes and law flow." },
    { id:"greatmarket",  name:"Great Market",      tier:6, summary:"Trade surges under your banner." },
    { id:"subduedseat",  name:"Subdued Seat",      tier:6, summary:"A rival seat brought into your domain." }
  ]
};

  function pickTerritoryTemplate(tier){
    // Use a cumulative pool: all land types from tier 1 up to the current tier.
    const t = clamp(tier || 1, 1, 6);
    const pool = [];
    for(let k = 1; k <= t; k++){
      const sub = TERRITORY_POOLS[k];
      if (Array.isArray(sub) && sub.length){
        pool.push(...sub);
      }
    }
    if(!pool.length){
      return { id:"wilds", name:"Unmarked Land", tier:t, summary:"Rough country slowly being tamed." };
    }
    return pool[rnd(0, pool.length - 1)];
  }

  
function titleTier(){
    const { idx } = titleInfo();
    return titleTierFromIdx(idx);
  }

  function titleTierFromIdx(idx){
    // Your title ladder (index ranges):
    // Tier 1: 0‚Äì4, Tier 2: 5‚Äì9, Tier 3: 10‚Äì15, Tier 4: 16‚Äì21, Tier 5: 22‚Äì27, Tier 6: 28+
    if(idx <= 4) return 1;
    if(idx <= 9) return 2;
    if(idx <= 15) return 3;
    if(idx <= 21) return 4;
    if(idx <= 27) return 5;
    return 6;
  }

function captureTerritory(battleTier){
    if(!Array.isArray(S.controlledRegions)) S.controlledRegions = [];

    // IMPORTANT: Your title limits *what kind* of land you can realistically claim.
    // Elders can only be associated with local features (riverlands, forest edge, farmlands),
    // even if they win larger fights. Higher titles unlock settlement/holdings names.
    const tier = clamp(Math.min((battleTier||1), titleTier()), 1, 6);

    const tmpl = pickTerritoryTemplate(tier);
    const index = S.controlledRegions.length + 1;

    const terr = {
      id: `${tmpl.id}#${index}`,
      name: tmpl.name,
      tier: tmpl.tier,
      summary: tmpl.summary,
      // New per-tile state
      trait: rollTerritoryTrait(tmpl.name),
      stage: "raw",
      specialization: null,
      project: null,
      workersAssigned: 0,
      maxWorkers: 0
    };

    S.controlledRegions.push(terr);
    return terr;
  }


  function battleSim(slot){
  const b = currentBattleSet()[slot];
  const enemyCount = rnd(b.enemyMin, b.enemyMax);

  const wins = (S.battlesWon || 0);
  const tier = battleTierFromTitleIdx(titleInfo().idx);
  const arch = battleArchetypeFor(tier, slot);
  if(arch && arch.label) b.label = arch.label;

  // --- YOUR TROOPS ---
  const warriors = Math.max(0, S.warriors || 0);
  const aux      = S.auxilia  || 0;
  const equites  = S.equites  || 0;
  const veterans = S.veterans || 0;

  const yourTroops = warriors; // core milites that can die

  // Base per-unit stats (can tweak later)
  const MIL = { atk: 7,  def: 5,  hp: 16 };
  const AUX = { atk: 6,  def: 8,  hp: 20 };
  const EQ  = { atk: 13, def: 4,  hp: 18 };
  const VET = { atk: 9,  def: 10, hp: 24 };

  let baseAtk = warriors * MIL.atk + aux * AUX.atk + equites * EQ.atk + veterans * VET.atk;
  let baseDef = warriors * MIL.def + aux * AUX.def + equites * EQ.def + veterans * VET.def;
  let baseHP  = warriors * MIL.hp  + aux * AUX.hp  + equites * EQ.hp  + veterans * VET.hp;

  // Global multipliers from crowns, decrees, land, faith, veterancy, morale
  const land = S.land || 0;
  const landBattleMult = 1 + Math.min(land * 0.012, 0.45);

  const faith = S.faith || 0;
  let faithMult = 1 + Math.min(faith / 18000, 0.25);
  try{
    if(typeof isBuffed === "function" && isBuffed()){
      faithMult *= 1.15;
    }
  }catch(e){}

  const cm = crownMult();
  const dm = decreeMult();

  const legionXp = S.legionXp || 0;
  const expLevel = 1 + Math.min(legionXp / 6000, 0.30); // up to +30%

  let legionMorale = typeof S.legionMorale === "number" ? S.legionMorale : 1;
  legionMorale = clamp(legionMorale, 0.4, 2.0);
  const moraleMult = 0.85 + legionMorale * 0.30; // ~0.97‚Äì1.45

  const globalMult = cm * dm * landBattleMult * faithMult * expLevel * moraleMult;

  let yourATK = Math.max(0, baseAtk * globalMult);
  let yourDEF = Math.max(0, baseDef * globalMult);
  let yourHPmax = Math.max(20, baseHP * globalMult);
  let yourHP = yourHPmax;
  let yourArmor = yourDEF * 0.25;

  // --- ENEMY STATS ---
  // Generic enemy per-head stats scaled by tier/slot & learning.
  const ENEMY = { atk: 4.5, def: 3.5, hp: 9.5 };

  let enemyATK = enemyCount * ENEMY.atk;
  let enemyDEF = enemyCount * ENEMY.def;
  let enemyHPmax = Math.max(20, enemyCount * ENEMY.hp);
  let enemyHP = enemyHPmax;

  const tierMults = [0.9, 1.0, 1.2, 1.4, 1.7, 2.0];
  const slotMults = [0.9, 1.0, 1.15, 1.3];
  const tierMult = tierMults[tier - 1] || 1.0;
  const slotMult = slotMults[slot] || 1.0;

  let enemyScale = tierMult * slotMult;

  // --- Treasure caravans: sometimes enemies are richer (and tougher) ---
  let treasureType = "normal";
  let treasureLootMult = 1;
  let treasurePowerMult = 1;

  {
    const tRoll = Math.random();
    // Mildly loaded warband
    if (tRoll < 0.32) {
      treasureType = "fat";
      treasureLootMult = 1.35;
      treasurePowerMult = 1.06;
    }
    // Well‚Äësupplied caravan
    if (tRoll < 0.12) {
      treasureType = "rich";
      treasureLootMult = 1.8;
      treasurePowerMult = 1.12;
    }
    // Rare jackpot hoard
    if (tRoll < 0.04) {
      treasureType = "jackpot";
      treasureLootMult = 3.0;
      treasurePowerMult = 1.25;
    }
  }

  // Enemies "learn" you as you win more.
  const learnDivBase = [1000, 260, 190, 140];
  const learnDiv = learnDivBase[Math.min(slot, learnDivBase.length - 1)] || 250;
  const learn = 1 + Math.min(wins / learnDiv, 0.18);
  enemyScale *= learn * treasurePowerMult;

  enemyATK   *= enemyScale;
  enemyDEF   *= enemyScale;
  enemyHPmax *= enemyScale;
  enemyHP     = enemyHPmax;
  let enemyArmor = enemyDEF * 0.25;

  // Composite "power" ratings used only for win chance & casualty heuristics.
  const yourPower  = yourATK + yourDEF * 0.8 + yourHPmax * 0.08;
  const enemyPower = enemyATK + enemyDEF * 0.8 + enemyHPmax * 0.08;
const TICK_SEC = 0.35;
  const MAX_TIME = 18; // seconds
  const maxTicks = Math.floor(MAX_TIME / TICK_SEC);

  let routed = null; // 'you' | 'enemy' | null

  function moraleBreakChance(myFrac, theirFrac, morale){
    const gap = clamp(theirFrac - myFrac, -0.9, 0.9);
    if(gap <= 0) return 0;
    const base = 0.06 + gap * 0.50;
    const moraleMod = 1 / clamp(morale, 0.4, 2.0);
    return clamp(base * moraleMod, 0, 0.65);
  }

  for(let i=0;i<maxTicks;i++){
    if(yourHP <= 0 || enemyHP <= 0) break;

    // Damage with a bit of noise
    const atkRollYou = 0.85 + Math.random() * 0.4;
    const atkRollEn  = 0.85 + Math.random() * 0.4;

    const rawToEnemy = Math.max(0, yourATK * atkRollYou - enemyDEF * 0.22);
    const rawToYou   = Math.max(0, enemyATK * atkRollEn  - yourDEF * 0.22);

    const armorMitEnemy = enemyArmor / (enemyArmor + 420);
    const armorMitYou   = yourArmor  / (yourArmor  + 420);

    const dmgToEnemy = rawToEnemy * (1 - armorMitEnemy) * TICK_SEC;
    const dmgToYou   = rawToYou   * (1 - armorMitYou)   * TICK_SEC;

    enemyHP -= dmgToEnemy;
    yourHP  -= dmgToYou;

    const yourFrac  = clamp(yourHP  / yourHPmax, 0, 1);
    const enemyFrac = clamp(enemyHP / enemyHPmax, 0, 1);

    // Morale checks after initial clash
    if(i > 4){
      const enemyMorale = 1.0; // generic
      const enemyBreak = moraleBreakChance(enemyFrac, yourFrac, enemyMorale);
      if(!routed && Math.random() < enemyBreak){
        routed = "enemy";
        break;
      }

      // Your side uses hidden legionMorale
      const yourMoraleVal = legionMorale;
      const yourBreak = moraleBreakChance(yourFrac, enemyFrac, yourMoraleVal);
      if(!routed && Math.random() < yourBreak){
        routed = "you";
        break;
      }
    }
  }

  const yourFracFinal  = clamp(yourHP  / yourHPmax, 0, 1);
  const enemyFracFinal = clamp(enemyHP / enemyHPmax, 0, 1);

  // Decide winner
  let win;
  if(routed === "enemy" || enemyHP <= 0){
    win = true;
  }else if(routed === "you" || yourHP <= 0){
    win = false;
  }else{
    const scoreYou = yourFracFinal  * yourPower;
    const scoreEn  = enemyFracFinal * enemyPower;
    win = scoreYou >= scoreEn || Math.random() < scoreYou / Math.max(scoreYou + scoreEn, 1);
  }

  // Convert HP loss ‚Üí troop casualties
  let lossFrac = (yourHPmax - Math.max(0, yourHP)) / yourHPmax;
  lossFrac = clamp(lossFrac, 0, win ? 0.65 : 0.90);

  // Base losses from HP damage, applied to your core milites.
  let losses = Math.round(yourTroops * lossFrac);

  // Strength comparison for casualty tuning
  const powerRatioCas = yourPower / Math.max(enemyPower, 1);

  // Ensure meaningful attrition, and punish underpowered wins more
  if (yourTroops > 0) {
    // Baseline chip damage for all fights
    const baseMinFracWin = 0.03;
    const baseMinFracLose = 0.06;
    const baseMinFrac = win ? baseMinFracWin : baseMinFracLose;
    let minLosses = Math.max(1, Math.round(yourTroops * baseMinFrac));

    // If you scraped a win while weaker on paper, raise the floor a lot
    if (win && powerRatioCas < 1.0) {
      const extra = (1.0 - powerRatioCas); // how underpowered you were
      const riskyMinFrac = 0.20 + extra * 0.40; // ~20‚Äì60% casualties for risky wins
      const riskyLosses = Math.round(yourTroops * clamp(riskyMinFrac, 0.20, 0.80));
      minLosses = Math.max(minLosses, riskyLosses);
    }

    // Small stacks shouldn‚Äôt have ‚Äúfree‚Äù victories.
    if (yourTroops <= 8) {
      let smallMin = win ? 1 : 2;
      if (powerRatioCas < 0.8) smallMin += 1;
      if (powerRatioCas < 0.5) smallMin += 1;
      const smallLosses = Math.min(yourTroops, smallMin);
      minLosses = Math.max(minLosses, smallLosses);
    }

    // Large armies keep a gentle floor, but never totally free hits.
    if (yourTroops >= 15) {
      const bigFloor = Math.round(yourTroops * baseMinFrac);
      minLosses = Math.max(minLosses, bigFloor);
    }

    if (losses < minLosses) losses = minLosses;
    if (losses <= 0) losses = 1;
  }


  // Protective effect from Auxilia & Veterans: better lines, fewer losses.
  {
    const aux     = S.auxilia  || 0;
    const veterans = S.veterans || 0;
    let lossMult = 1;
    lossMult -= aux * 0.01;
    lossMult -= veterans * 0.02;
    lossMult = clamp(lossMult, 0.6, 1);
    losses = Math.round(losses * lossMult);
    if (losses < 1) losses = 1;
  }

  losses = Math.min(yourTroops, Math.max(0, losses));

  // Approximate win chance for UI based on starting power + morale
  const powerRatio = yourPower / Math.max(enemyPower, 1);
  let winP = powerRatio / (1 + powerRatio);
  const moraleBias = (legionMorale - 1) * 0.18;
  winP = clamp(winP + moraleBias, 0.04, 0.96);

  return {
    label: b.label,
    enemies: enemyCount,
    winP,
    win,
    losses,
    tier,
    treasureType,
    treasureLootMult
  };
}

  function offerCost(){
    return Math.round(600 * Math.pow(1.34, Math.floor((S.faith||0)/120)));
  }

  function offerFaithGain(){
    return Math.round(22 + (S.land*2));
  }

  function blessCooldownMs(){ return 60_000; }
  function blessDurationMs(){ return 22_000; }

  function ascendCrownGain(){
    // you need renown to ascend; crowns scale gently to keep long-term
    const r = S.renown;
    if(r < 8000) return 0;
    return Math.max(1, Math.floor(Math.sqrt(r/900)));
  }

  
  

  


  
  

  // ---- Titles + unlocks ----
  function titleInfo(){
    const r = S.renown;
    let idx = 0;
    for(let i=0;i<titles.length;i++) if(r >= titles[i].need) idx = i;
    const cur = titles[idx];
    const next = titles[Math.min(idx+1, titles.length-1)];
    return { cur, next, idx };
  }

  function rankTributeBonus(idx){
    // Slight per-rank boost. Early ranks are small to keep the start tough.
    // Elder=0 ‚Üí +0.0, Elder=1 ‚Üí +0.2, Chief=2 ‚Üí +0.5, etc.
    return Math.round((0.10*idx + 0.08*idx*idx) * 10) / 10; // to nearest 0.1
  }

  
function handleRankUps(){
    const info = titleInfo();
    const idx = info.idx;
    if(typeof S.rankIdx !== "number") S.rankIdx = 0;
    const prevIdx = S.rankIdx;

    if(idx <= prevIdx) return;

    const gained = idx - prevIdx;
    // Award a small permanent tap increase each rank-up
    // (this stacks with multipliers like Provinces/Decrees/Crowns and crit/streak).
    const before = S.tribute;
    S.tribute = Math.max(1, Math.round((S.tribute + gained * 0.25) * 10) / 10);
    S.rankIdx = idx;

    const tributeGain = (S.tribute - before);
    logLine(`Rank up! Your tribute grows. (+${tributeGain.toFixed(1)} tap base)`, "good");

    // Big celebration: confetti + popup + follow-up toast
    try{
      const titleName = info.cur && info.cur.name ? info.cur.name : "New Title";
      const tier = titleTierFromIdx(idx);
      showRankUpPopup({
        titleName,
        tier,
        tributeGain: tributeGain.toFixed(1),
        gainedRanks: gained
      });
    }catch(e){
      toast("Rank up!");
    }

    // Notify when a new land tier unlocks
    try{
      const prevTier = titleTierFromIdx(prevIdx);
      const newTier  = titleTierFromIdx(idx);

      if(!S.maxTerritoryTierNotified || typeof S.maxTerritoryTierNotified !== "number"){
        S.maxTerritoryTierNotified = prevTier;
      }

      if(newTier > S.maxTerritoryTierNotified){
        const unlockedNames = [];
        for(let t = S.maxTerritoryTierNotified + 1; t <= newTier; t++){
          const pool = TERRITORY_POOLS[t];
          if(pool && pool.length){
            pool.forEach(p => unlockedNames.push(p.name));
          }
        }
        S.maxTerritoryTierNotified = newTier;
        if(unlockedNames.length && typeof showLandTierUnlockPopup === "function"){
          showLandTierUnlockPopup(newTier, unlockedNames);
        }
      }
    }catch(e){
      if(console && console.warn) console.warn("Land tier unlock notify failed", e);
    }
  }


  // ---- Dopamine layers: Jackpots + Cash Out ----
  function cashoutMultiplier(){
    // Scales with prestige + progression systems
    return landMult() * decreeMult() * crownMult();
  }

  function rollJackpot(){
    // Returns {type, mult} or null
    // Lucky: common-ish; Imperial: rare but huge.
    const pMult = cashoutMultiplier();
    const luckyP = clamp(0.010 + (S.faith/200000), 0.010, 0.020);     // 1.0% ‚Üí 2.0%
    const impP   = clamp(0.0020 + (S.crowns*0.00015), 0.0020, 0.0060); // 0.20% ‚Üí 0.60%
    if(chance(impP))   return { type:"Imperial Tribute", mult: rnd(220, 650) * pMult };
    if(chance(luckyP)) return { type:"Lucky Denarius",  mult: rnd(40, 140) * pMult };
    return null;
  }

  function bankCashout(amount){
    // Bank grows with streak so players feel momentum.
    const streakBoost = 1 + Math.min(0.85, (S.streak-1)*0.02);
    S.cashoutBanked += Math.round(amount * 0.35 * streakBoost);
    S.cashoutBanked = clamp(S.cashoutBanked, 0, 9_999_999_999);
  }
  function expireCashoutIfNeeded(){ /* handled by cooldown + streak timer */ }

// ---- Cash Out Rework (streak-driven, timing & milestones) ----
  // Goal: tempt players to *cash* their streak at milestones instead of mindlessly holding it.
  const CASHOUT_MIN_STREAK = 6;       // when cashing becomes available
  const CASHOUT_COOLDOWN_MS = 2500;   // after cashing out

  function cashoutPotential(){
    const s = Math.max(1, S.streak || 1);
    if(s < CASHOUT_MIN_STREAK) return 0;

    const milestones = Math.floor(s / 10); // every 10 feels special
    const within = streakTimeLeftMs() / STREAK_WINDOW_MS; // 0..1
    const timing = 0.70 + 0.30 * within; // more if you're actively tapping

    // Softer streak curve so players can't hoard absurd jackpots from endless tapping.
    const curve = Math.pow(s, 1.05); // was 1.22
    const kicker = 1 + milestones * 0.12;
    const rush = 1 + (rushBonus() * 0.05);

    const raw = (4 + curve) * kicker * timing * rush;
    let payout = Math.round(raw * cashoutMultiplier());

    // Hard cap: tie cashout to current empire power instead of infinite streaks.
    const baseIncome = Math.max(10, (S.tribute || 1) * landMult());
    const cap = Math.round(baseIncome * 80); // roughly 80 taps worth at current strength
    if(payout > cap) payout = cap;

    return payout;
  }

  function cashoutReady(){
    const now = Date.now();
    return (now >= (S.cashoutCooldownUntil || 0)) && cashoutPotential() > 0;
  }
// ---- Micro objectives (state-driven, procedural, always something to do) ----
const OBJ_SLOTS = 3;

// Lanes:
//  slot 0 = "village / economy"
//  slot 1 = "legion / land / battles"
//  slot 2 = "meta / temple / streak / cashout"
function ensureObjectives(){
  if(!Array.isArray(S.objectives) || S.objectives.length !== OBJ_SLOTS){
    S.objectives = [];
    for(let i=0;i<OBJ_SLOTS;i++) S.objectives.push(makeObjective(i));
    S.objStreak = Number(S.objStreak) || 0;
  }else{
    // Make sure each slot is at least a valid objective object
    for(let i=0;i<OBJ_SLOTS;i++){
      if(!S.objectives[i] || typeof S.objectives[i] !== "object"){
        S.objectives[i] = makeObjective(i);
      }
    }
    S.objStreak = Number(S.objStreak) || 0;
  }
}

function makeObjective(slotIndex = 0){
  // Procedural objectives: scale off current progress + unlocks.
  const r        = Number(S.renown)   || 0;
  const land     = Number(S.land)     || 0;
  const w        = Number(S.warriors) || 0;
  const crowns   = Number(S.crowns)   || 0;
  const income   = Math.max(0, incomePerSec());
  const farms    = Number(S.farmCount) || 0;
  const villas   = Number(S.villaCount) || 0;
  const battles  = Number(S.battlesWon) || 0;

  // Rough progression tier: renown + crowns pushes things up.
  const progTier = Math.max(
    1,
    1 + Math.floor(r / 1400) + Math.floor(crowns / 3)
  );

  // Slightly discourage giving the same type in every slot.
  const existingTypes = (Array.isArray(S.objectives) ? S.objectives : [])
    .filter(Boolean)
    .map(o => o.type);
  const existingSet = new Set(existingTypes);

  // Each slot has a preferred "lane", but can fall back if that lane is weak.
  let lane = "village";
  if(slotIndex === 1) lane = "legion";
  if(slotIndex === 2) lane = "meta";

  const pool = [];
  const pushObj = (spec)=>{
    if(!spec || spec.weight <= 0) return;
    let weight = spec.weight;
    if(existingSet.has(spec.type)){
      // still allowed, but less likely so you see variety
      weight *= 0.35;
    }
    if(weight <= 0) return;
    pool.push({ ...spec, weight });
  };

  // --- Lane: village / economy (slot 0 bias) ---
  if(lane === "village"){
    // Core tap loop ‚Äì short chains early, longer chains later
    const tapMin = 8 + (progTier-1)*3;
    const tapMax = tapMin + 10 + progTier*4;
    pushObj({ type: "tap", min: tapMin, max: tapMax, weight: 6 });

    // Denarii milestones tied to your current income
    const earnBase = Math.max(120, Math.round(income * (16 + progTier*4)));
    pushObj({
      type: "earnDen",
      min: earnBase,
      max: Math.round(earnBase * 1.6),
      weight: 6
    });

    if(progTier >= 3){
      const big = earnBase * (1.9 + progTier*0.20);
      pushObj({
        type: "earnDen",
        min: Math.round(big),
        max: Math.round(big * 1.4),
        weight: 3
      });
    }

    // Farms ramp from 1 ‚Üí 2 ‚Üí 3+ as your village gets big.
    let farmMin = 1;
    if(farms >= 6)  farmMin = 2;
    if(farms >= 16) farmMin = 3;
    const farmMax = farmMin + (progTier >= 4 ? 1 : 0);
    pushObj({
      type: "buildFarm",
      min: farmMin,
      max: farmMax,
      weight: 4
    });

    // Villas show up once you're mid-game.
    if(r >= 900){
      let villaMin = 1;
      if(villas >= 4) villaMin = 2;
      if(villas >= 9) villaMin = 3;
      const villaMax = Math.min(villaMin + 1, 4);
      pushObj({
        type:"buildVilla",
        min: villaMin,
        max: villaMax,
        weight: 3
      });
    }
  }

  // --- Lane: legion / land / battles (slot 1 bias) ---
  if(lane === "legion"){
    if(r >= unlock.legion){
      // Recruit ramp: early 1‚Äì2, later 3‚Äì6 per objective.
      let recMin = 1;
      let recMax = 2;
      if(w >= 10){ recMin = 2; recMax = 4; }
      if(w >= 30){ recMin = 3; recMax = 6; }
      if(w >= 70){ recMin = 4; recMax = 8; }
      pushObj({
        type:"recruit",
        min: recMin,
        max: recMax,
        weight: 5
      });

      // Win battles: starts at 1, grows gently.
      let winMin = 1;
      let winMax = 1;
      if(battles >= 5){ winMax = 2; }
      if(battles >= 18){ winMin = 2; winMax = 3; }
      if(battles >= 40){ winMin = 3; winMax = 4; }
      pushObj({
        type:"winBattle",
        min: winMin,
        max: winMax,
        weight: 4
      });

      // Gain land ‚Äì more relevant as you scale.
      let landMin = 1;
      let landMax = 2 + Math.floor(progTier*0.8);
      landMax = Math.min(8, landMax);
      pushObj({
        type:"gainLand",
        min: landMin,
        max: landMax,
        weight: 4
      });
    }

    // Back-up econ task if legion is locked
    if(r < unlock.legion){
      const earnBase = Math.max(140, Math.round(income * (14 + progTier*3)));
      pushObj({
        type:"earnDen",
        min: earnBase,
        max: Math.round(earnBase * 1.5),
        weight: 4
      });
    }
  }

  // --- Lane: meta / temple / streak / cashout (slot 2 bias) ---
  if(lane === "meta"){
    // Streak objective encourages tap rhythm play
    pushObj({
      type:"streak",
      min: 6 + progTier*2,
      max: 10 + progTier*4,
      weight: 5
    });

    // Cashout objective: push players to actually hit the button
    if(r >= 400){
      pushObj({
        type:"cashout",
        min: 1,
        max: Math.min(2, 1 + Math.floor(progTier/3)),
        weight: 3
      });
    }

    // Temple objectives
    if(r >= unlock.temple){
      pushObj({
        type:"offerFaith",
        min: 1,
        max: Math.min(3, 1 + progTier),
        weight: 3
      });
    }

    // Always have *something* simple available
    const earnBase = Math.max(100, Math.round(income * (10 + progTier*2)));
    pushObj({
      type:"earnDen",
      min: earnBase,
      max: Math.round(earnBase * 1.4),
      weight: 3
    });
  }

  // Global fallbacks if lane ended up too thin
  if(pool.length === 0){
    const earnBase = Math.max(80, Math.round(income * (8 + progTier*2)));
    pushObj({ type:"tap",    min: 8,         max: 20,                weight: 4 });
    pushObj({ type:"earnDen",min: earnBase,  max: Math.round(earnBase*1.4), weight: 4 });
  }

  // Weighted pick
  const totalW = pool.reduce((a,p)=>a+p.weight,0);
  let roll = Math.random() * totalW;
  let pick = pool[0];
  for(const p of pool){
    roll -= p.weight;
    if(roll <= 0){ pick = p; break; }
  }

  const target = rnd(pick.min, pick.max);
  const id = `${pick.type}_${Date.now()}_${rnd(100,999)}`;

  // Reward design:
  // - scales with renown, land, crowns, income and target
  // - gets a small push from objStreak so back-to-back completions feel hot
  const streak = Number(S.objStreak)||0;
  const streakMult = 1 + Math.min(0.45, streak * 0.04);

  const baseDen   = 22 + Math.floor(r/110) + (crowns*16) + Math.floor(land*3.5);
  const incomeDen = income * (12 + progTier*4);
  const targetFactor = 0.85 + target*0.08 + progTier*0.25;

  let rewardDen = Math.round((baseDen + incomeDen) * targetFactor * streakMult);

  // soft caps just to keep early game sane
  const softCap =
    (r < 1500)   ?  900 :
    (r < 8000)   ? 5000 :
    (r < 25000)  ? 30000 :
                   1e12;
  rewardDen = Math.min(rewardDen, softCap);

  // Power rewards removed; objectives now grant denarii only.
  const rewardPower = 0;

  return {
    id,
    type: pick.type,
    target,
    progress: 0,
    rewardDen,
    rewardPower,
    claimed: false
  };
}

function objText(o){
  const left = Math.max(0, o.target - o.progress);

  if(o.type==="tap")
    return `Tap ${o.target} times (${left} left)`;

  if(o.type==="streak")
    return `Reach streak x${o.target} (best this run: x${Math.max(1, S.streak||1)})`;

  if(o.type==="winBandits")
    return `Win ${o.target} bandit skirmish${o.target>1?"es":""} (${left} left)`;

  if(o.type==="winLevy")
    return `Win ${o.target} levy battle${o.target>1?"s":""} (${left} left)`;

  if(o.type==="winVillage")
    return `Win ${o.target} village assault${o.target>1?"s":""} (${left} left)`;

  if(o.type==="winSiege")
    return `Win ${o.target} siege${o.target>1?"s":""} (${left} left)`;

  if(o.type==="buildFarm")
    return `Build ${o.target} farm${o.target>1?"s":""} (${left} left)`;

  if(o.type==="buildVilla")
    return `Build ${o.target} villa${o.target>1?"s":""} (${left} left)`;

  if(o.type==="earnDen")
    return `Earn ${fmt(o.target)} denarii (${fmt(left)} left)`;

  if(o.type==="recruit")
    return `Recruit ${o.target} milites${o.target>1?"s":""} (${left} left)`;

  if(o.type==="winBattle")
    return `Win ${o.target} battle${o.target>1?"s":""} (${left} left)`;

  if(o.type==="gainLand")
    return `Gain ${o.target} land (${left} left)`;

  if(o.type==="offerFaith")
    return `Make ${o.target} temple offering${o.target>1?"s":""} (${left} left)`;

  if(o.type==="cashout")
    return `Cash out ${o.target} time${o.target>1?"s":""} (${left} left)`;

  return `Complete this task (${left} left)`;
}

function objComplete(o){ return o.progress >= o.target; }
function objComplete(o){ return o.progress >= o.target; }
function bumpObjective(type, amount=1){
  for(const o of S.objectives){
    if(o.claimed) continue;
    if(o.type !== type) continue;
    o.progress = clamp(o.progress + amount, 0, o.target);
  }
}

function bumpEarnedDenarii(amount){
  ensureObjectives();
  for(const o of S.objectives){
    if(o.claimed) continue;
    if(o.type !== "earnDen") continue;
    o.progress = clamp(o.progress + amount, 0, o.target);
  }
}

function claimObjective(idx){
  ensureObjectives();
  const o = S.objectives[idx];
  if(!o || o.claimed || !objComplete(o)) return;

  o.claimed = true;
  S.objStreak = (Number(S.objStreak)||0) + 1;

  const now = Date.now();
  const objMult = now < (S.objDoubleUntil || 0) ? 2 : 1;
  const rewardDen = o.rewardDen * objMult;

  // payout
  S.gold += rewardDen;
  S.lifetimeGold += rewardDen;

  const doubledText = objMult > 1 ? " (doubled)" : "";
  logLine(`Objective complete! (+${fmt(rewardDen)} denarii${doubledText})`, "good");
  toast("Objective claimed");

  // üîî Objective streak dopamine:
  //  - Hook into the existing burst engine
  //  - Occasionally spit out a chest on streak milestones
  maybeBurst("streak");
  if(S.objStreak > 0 && S.objStreak % 4 === 0){
    try{
      showChest("objective");
    }catch(e){
      // chest UI missing / not loaded? silently ignore
    }
  }

  // replace with a new one in the same lane
  S.objectives[idx] = makeObjective(idx);
}

function renderObjectives(){
  const list = $("#objList");
  if(!list) return;
  ensureObjectives();

  $("#objStreak").textContent = fmt(S.objStreak || 0);

  list.innerHTML = "";
  S.objectives.forEach((o, i) => {
    const row = document.createElement("div");
    row.style.display = "flex";
    row.style.alignItems = "center";
    row.style.justifyContent = "space-between";
    row.style.gap = "10px";

    const left = document.createElement("div");
    left.style.display = "flex";
    left.style.flexDirection = "column";
    left.style.gap = "2px";

    const title = document.createElement("div");
    title.style.fontFamily = "var(--mono)";
    title.style.fontSize = ".78rem";
    title.style.color = "var(--text)";
    title.textContent = objText(o);

    const small = document.createElement("div");
    small.style.fontFamily = "var(--sans)";
    small.style.fontSize = ".74rem";
    small.style.color = "var(--muted)";
    small.textContent = `Reward: +${fmt(o.rewardDen)} denarii`;

    left.appendChild(title);
    left.appendChild(small);

    const btn = document.createElement("button");
    btn.className = "tab"; // reuse pill button style
    btn.style.padding = "10px 12px";
    btn.style.fontSize = ".74rem";
    btn.textContent = objComplete(o) ? "Claim" : `${Math.floor((o.progress/Math.max(1,o.target))*100)}%`;
    btn.disabled = !objComplete(o);
    if(objComplete(o)) btn.classList.add("active");
    btn.addEventListener("click", () => { claimObjective(i); render(); });

    row.appendChild(left);
    row.appendChild(btn);
    list.appendChild(row);
  });
}





  // ---- Burst Events (RNG micro-spikes) ----
  function triggerTributeFever(){
    const now = Date.now();
    const dur = 6000; // 6s
    S.feverUntil = Math.max(S.feverUntil || 0, now) + dur;
    toast("Tribute Fever! +250% taps for 6s");
    logLine("Tribute Fever surges through the village!", "good");
  }

  function triggerDoubleObjectives(){
    const now = Date.now();
    const dur = 20000; // 20s
    S.objDoubleUntil = Math.max(S.objDoubleUntil || 0, now) + dur;
    toast("Double Objectives! Rewards boosted");
    logLine("For a short time, objectives are doubled.", "warn");
  }

  function triggerCommanderVisit(){
    S.warriors = (S.warriors || 0) + 1;
    recalcLegionStrength();
    toast("Commander visits: +1 free warrior");
    logLine("A seasoned commander grants you a free warrior.", "good");
  }

  function triggerGoldStorm(){
    const now = Date.now();
    // Small burst of gold
    const base = 18 + Math.floor((S.renown||0)/160) + (S.crowns||0)*4;
    const gain = Math.max(10, Math.round(base * (1 + Math.random()*3)));
    S.gold += gain;
    S.lifetimeGold += gain;
    bumpEarnedDenarii(gain);

    toast("Gold storm!");

    // Visual coins: reuse sparkAt across random positions
    try{
      const vw = window.innerWidth || 400;
      const vh = window.innerHeight || 700;
      for(let i=0;i<10;i++){
        const x = rnd(Math.floor(vw*0.1), Math.floor(vw*0.9));
        const y = rnd(Math.floor(vh*0.15), Math.floor(vh*0.7));
        sparkAt(x,y, 0.60);
      }
    }catch(e){}
    logLine(`Gold storm! (+${fmt(gain)} denarii)`, "good");
  }

  function maybeBurst(source){
    // Base chance per trigger source
    let base;
    if(source === "streak") base = 0.18;
    else if(source === "cashout") base = 0.15;
    else if(source === "battle") base = 0.16;
    else base = 0.10;

    if(Math.random() > base) return;

    const roll = Math.random();
    if(roll < 0.35){
      triggerTributeFever();
    }else if(roll < 0.60){
      triggerDoubleObjectives();
    }else if(roll < 0.80){
      triggerCommanderVisit();
    }else{
      triggerGoldStorm();
    }
  }

// ---- Loot Chests (2-second dopamine overlay) ----
  
  function chestRarityFrom(source){
    // Tiered rarities:
    //   Wooden < Bronze < Silver < Gold < Royal
    // Source can be "skirmish", "objective", "battle" or generic gifts.
    const wins   = Number(S.battlesWon) || 0;
    const streak = Number(S.objStreak)  || 0;
    const ren    = Number(S.renown)     || 0;

    const roll = Math.random();

    // Skirmish / battle rewards bias upwards as you win more wars.
    if(source === "skirmish" || source === "battle"){
      if(wins >= 24){
        if(roll < 0.10) return "Royal";
        if(roll < 0.40) return "Gold";
        if(roll < 0.80) return "Silver";
        if(roll < 0.95) return "Bronze";
        return "Wooden";
      }else if(wins >= 12){
        if(roll < 0.04) return "Royal";
        if(roll < 0.25) return "Gold";
        if(roll < 0.65) return "Silver";
        if(roll < 0.90) return "Bronze";
        return "Wooden";
      }else if(wins >= 5){
        if(roll < 0.12) return "Gold";
        if(roll < 0.42) return "Silver";
        if(roll < 0.82) return "Bronze";
        return "Wooden";
      }else{
        if(roll < 0.08) return "Silver";
        if(roll < 0.42) return "Bronze";
        return "Wooden";
      }
    }

    // Objective-chain chests get better with streak.
    if(source === "objective"){
      if(streak >= 20){
        if(roll < 0.08) return "Royal";
        if(roll < 0.40) return "Gold";
        if(roll < 0.82) return "Silver";
        if(roll < 0.96) return "Bronze";
        return "Wooden";
      }else if(streak >= 12){
        if(roll < 0.04) return "Royal";
        if(roll < 0.25) return "Gold";
        if(roll < 0.70) return "Silver";
        if(roll < 0.94) return "Bronze";
        return "Wooden";
      }else if(streak >= 4){
        if(roll < 0.12) return "Gold";
        if(roll < 0.45) return "Silver";
        if(roll < 0.88) return "Bronze";
        return "Wooden";
      }else{
        if(roll < 0.06) return "Silver";
        if(roll < 0.52) return "Bronze";
        return "Wooden";
      }
    }

    // Generic gifts: renown very slowly biases towards better tiers.
    let royalP  = 0.01;
    let goldP   = 0.06;
    let silverP = 0.25;
    let bronzeP = 0.42; // rest is Wooden

    const renBonus = Math.min(0.45, Math.log10(1 + ren / 500) * 0.35);
    if(renBonus > 0){
      // Nudge some probability mass from Wooden/Bronze into Silver/Gold/Royal.
      silverP += renBonus * 0.6;
      goldP   += renBonus * 0.3;
      royalP  += renBonus * 0.1;
      bronzeP = Math.max(0.10, bronzeP - renBonus * 0.4);
    }

    // Normalise and clamp.
    royalP  = clamp(royalP,  0, 0.15);
    goldP   = clamp(goldP,   0, 0.25);
    silverP = clamp(silverP, 0, 0.55);
    bronzeP = clamp(bronzeP, 0, 0.75);

    const wCut  = 1 - (royalP + goldP + silverP + bronzeP);
    const woodenCut  = Math.max(0, wCut);

    if(roll < woodenCut) return "Wooden";
    if(roll < woodenCut + bronzeP) return "Bronze";
    if(roll < woodenCut + bronzeP + silverP) return "Silver";
    if(roll < woodenCut + bronzeP + silverP + goldP) return "Gold";
    return "Royal";
  }


  function chestPalette(rarity){
    // Normalise any legacy rarity labels into the new tiered system.
    if(rarity === "Epic") rarity = "Gold";
    else if(rarity === "Rare") rarity = "Silver";
    else if(rarity === "Common") rarity = "Bronze";

    // Base palettes for each tier. These control icon, title and visual accents.
    switch(rarity){
      case "Royal":
        return {
          tier: "Royal",
          title: "Royal Chest",
          icon: "üëë",
          border: "rgba(244,208,111,0.95)",
          glow: "0 20px 48px rgba(0,0,0,0.70), 0 0 26px rgba(244,208,111,0.65)",
          bg: "linear-gradient(180deg,#fff7df,#f5d48c)",
          backdrop: "rgba(0,0,0,0.70)",
          pillBg: "rgba(255,255,255,0.90)",
          pillBorder: "rgba(244,208,111,0.95)",
          sub: "Treasures fit for a king. Very rare.",
          hint: "Tap to reveal these royal rewards."
        };
      case "Gold":
        return {
          tier: "Gold",
          title: "Gold Chest",
          icon: "üí∞",
          border: "rgba(244,208,111,0.85)",
          glow: "0 18px 42px rgba(0,0,0,0.65), 0 0 18px rgba(244,208,111,0.40)",
          bg: "linear-gradient(180deg,#fdf6eb,#f2e0c5)",
          backdrop: "rgba(0,0,0,0.62)",
          pillBg: "rgba(255,255,255,0.92)",
          pillBorder: "rgba(244,208,111,0.85)",
          sub: "Rich spoils from great deeds.",
          hint: "Tap to reveal high-value rewards."
        };
      case "Silver":
        return {
          tier: "Silver",
          title: "Silver Chest",
          icon: "ü•à",
          border: "rgba(210,219,233,0.9)",
          glow: "0 16px 38px rgba(0,0,0,0.60)",
          bg: "linear-gradient(180deg,#f7f7fb,#e5e8f0)",
          backdrop: "rgba(0,0,0,0.60)",
          pillBg: "rgba(255,255,255,0.94)",
          pillBorder: "rgba(210,219,233,0.9)",
          sub: "Solid rewards from worthy service.",
          hint: "Tap to reveal your silver spoils."
        };
      case "Bronze":
        return {
          tier: "Bronze",
          title: "Bronze Chest",
          icon: "ü•â",
          border: "rgba(181,120,72,0.95)",
          glow: "0 14px 34px rgba(0,0,0,0.55)",
          bg: "linear-gradient(180deg,#f9ecdc,#f0d3af)",
          backdrop: "rgba(0,0,0,0.55)",
          pillBg: "rgba(255,252,247,0.94)",
          pillBorder: "rgba(181,120,72,0.90)",
          sub: "Modest spoils from everyday efforts.",
          hint: "Tap to see what your people gathered."
        };
      case "Wooden":
      default:
        return {
          tier: "Wooden",
          title: "Wooden Chest",
          icon: "üì¶",
          border: "rgba(99,71,40,0.95)",
          glow: "0 12px 30px rgba(0,0,0,0.50)",
          bg: "linear-gradient(180deg,#f3e2c8,#e0c19a)",
          backdrop: "rgba(0,0,0,0.50)",
          pillBg: "rgba(255,251,243,0.92)",
          pillBorder: "rgba(99,71,40,0.90)",
          sub: "Simple goods gathered by your villagers.",
          hint: "Tap to reveal what was saved for you."
        };
    }
  }

  function makeChestLoot(rarity){
    // New tiered chest loot:
    // - No influence or power; focus on denarii, renown, faith and temporary buffs.
    // - Scales with income, renown, crowns and chest tier.
    if(rarity === "Epic") rarity = "Gold";
    else if(rarity === "Rare") rarity = "Silver";
    else if(rarity === "Common") rarity = "Bronze";

    const tierIndexMap = {
      "Wooden": 0,
      "Bronze": 1,
      "Silver": 2,
      "Gold": 3,
      "Royal": 4
    };
    const tier = tierIndexMap[rarity] ?? 1;

    const mult = cashoutMultiplier();
    const income = Math.max(0, incomePerSec());
    const renown = Number(S.renown) || 0;
    const crowns = Number(S.crowns) || 0;

    // Baseline gold amount leans heavily on current income and a bit on renown/crowns.
    const baseGold = Math.max(
      40,
      Math.round(income * 90 + renown * 1.2 + crowns * 40)
    );

    const goldMultByTier  = [0.9, 1.1, 1.5, 2.2, 3.2];
    const renMultByTier   = [0.8, 1.0, 1.35, 1.8, 2.4];
    const faithMultByTier = [0.9, 1.1, 1.4, 1.9, 2.5];
    const buffMsExtraByTier = [0, 5_000, 10_000, 18_000, 26_000];

    const goldAmt  = Math.round(baseGold * (goldMultByTier[tier] || 1.0) * mult);
    const baseRen  = 4 + Math.sqrt(renown) * 0.6;
    const renAmt   = Math.max(2, Math.round(baseRen * (renMultByTier[tier] || 1.0)));
    const baseFaith = 40 + (Number(S.ascends) || 0) * 12;
    const faithAmt = Math.round(baseFaith * (faithMultByTier[tier] || 1.0));

    const buffMs = 20_000 + (buffMsExtraByTier[tier] || 0);
    const buffSecsLabel = Math.round(buffMs / 1000);

    const options = [
      () => ({
        kind:"den",
        text:`+${fmt(goldAmt)} denarii`,
        apply:()=>{
          S.gold += goldAmt;
          S.lifetimeGold += goldAmt;
          bumpEarnedDenarii(goldAmt);
        }
      }),
      () => ({
        kind:"ren",
        text:`+${fmt(renAmt)} renown`,
        apply:()=>{
          S.renown += renAmt;
          S.lifetimeRenown += renAmt;
        }
      }),
      () => ({
        kind:"faith",
        text:`+${fmt(faithAmt)} faith`,
        apply:()=>{
          S.faith += faithAmt;
        }
      }),
      () => ({
        kind:"buf",
        text:`Prosperity (${buffSecsLabel}s)`,
        apply:()=>{
          const now = Date.now();
          S.prosperUntil = Math.max(S.prosperUntil || 0, now) + buffMs;
          toast("Prosperity!");
        }
      })
    ];

    const buffChanceByTier = [0.18, 0.22, 0.30, 0.38, 0.48];
    const buffChance = buffChanceByTier[tier] ?? 0.22;

    const picks = [];
    for(let i=0;i<3;i++){
      let item;
      if(chance(buffChance) && picks.filter(p=>p.kind === "buf").length === 0){
        item = options[3]();
      }else{
        // pick among den/ren/faith biased towards denarii
        const r = Math.random();
        if(r < 0.58) item = options[0]();
        else if(r < 0.82) item = options[1]();
        else item = options[2]();
      }
      picks.push(item);
    }
    return picks;
  }


  function showChest(source="feast"){
    const rarity = chestRarityFrom(source);
    const loot = makeChestLoot(rarity);

    const overlay = $("#chestOverlay");
    const card = $("#chestCard");
    const title = $("#chestTitle");
    const icon = $("#chestIcon");
    const hint = $("#chestHint");
    const sub = $("#chestSub");
    const backdrop = $("#chestBackdrop");
    const rev = [$("#rev1"), $("#rev2"), $("#rev3")];
    const btnContinue = $("#chestContinue");

    const pal = chestPalette(rarity);

    title.textContent = pal.title;
    icon.textContent = pal.icon;
    card.style.borderColor = pal.border;
    if(pal.bg) card.style.background = pal.bg;
    if(pal.glow) card.style.boxShadow = pal.glow;
    if(backdrop && pal.backdrop) backdrop.style.background = pal.backdrop;
    if(sub && pal.sub) sub.textContent = pal.sub;

    // reset reveal visuals
    rev.forEach(r=>{
      if(!r) return;
      r.textContent = "?";
      if(pal.pillBg) r.style.background = pal.pillBg;
      if(pal.pillBorder) r.style.borderColor = pal.pillBorder;
    });
    hint.textContent = pal.hint || "Tap to reveal rewards";
    if(btnContinue){
      btnContinue.style.display = "none";
      btnContinue.disabled = true;
    }

    overlay.style.display = "flex";
    // small fade/scale-in via CSS class
    overlay.classList.add("visible");

    let opened = false;
    let step = 0;

    const finish = ()=>{
      overlay.classList.remove("visible");
      overlay.onclick = null;
      if(btnContinue){
        btnContinue.onclick = null;
        btnContinue.disabled = true;
      }
      // wait for transition then hide
      setTimeout(()=>{
        overlay.style.display = "none";
      }, 230);

      // tiny burst
      try{
        const rect = card.getBoundingClientRect();
        sparkAt(rect.left + rect.width*0.50, rect.top + rect.height*0.22);
      }catch(e){}
      render();
    };

    const revealNext = ()=>{
      if(step >= 3) return;
      const item = loot[step];
      if(rev[step]) rev[step].textContent = item.text;
      // apply immediately so the HUD updates after close
      item.apply();
      step += 1;
      if(step >= 3){
        hint.textContent = "All rewards claimed.";
        if(btnContinue){
          btnContinue.style.display = "inline-flex";
          btnContinue.disabled = false;
          btnContinue.onclick = finish;
        }else{
          // fallback: tap backdrop closes
          overlay.onclick = finish;
        }
      }
    };

    const open = ()=>{
      if(step >= 3){
        // if already done, do nothing here (continue handled by button)
        return;
      }
      if(opened){
        revealNext();
        return;
      }
      opened = true;
      hint.textContent = "Opening‚Ä¶";
      // fast 3 reveals
      revealNext();
      setTimeout(revealNext, 220);
      setTimeout(revealNext, 440);
    };

    // Tap anywhere on the card/backdrop to open/advance
    overlay.onclick = open;
  }

function canAccess(view){
    if(view==="legion") return true;
    return (S.renown >= (unlock[view] ?? 0));
  }

  function setView(view){
    if(!canAccess(view)){
      const need = unlock[view] ?? 0;
      toast(`Locked ‚Äî need ${need} renown`);
      return;
    }
    currentView = view;
    $$(".view").forEach(v => v.hidden = v.dataset.view !== view);
    $$(".tab").forEach(b => b.classList.toggle("active", b.dataset.go === view));
    render();
  }

  // ---- UI render ----
  function fmt(n){
    n = Math.floor(n);
    if(n < 10000) return String(n);
    if(n < 1_000_000) return (n/1000).toFixed(1).replace(".0","") + "k";
    if(n < 1_000_000_000) return (n/1_000_000).toFixed(1).replace(".0","") + "m";
    return (n/1_000_000_000).toFixed(1).replace(".0","") + "b";
  }

  function renderTabs(){
    $$(".tab").forEach(btn => {
      const v = btn.dataset.go;
      const ok = canAccess(v);
      btn.disabled = !ok;
      btn.title = ok ? "" : `Unlock at ${unlock[v]} renown`;
    });
  }

  function updateTitleProgress(){
    const r = S.renown;
    const {cur, next} = titleInfo();
    $("#title").textContent = cur.name;
    $("#nextTitle").textContent = next.name;

    const span = Math.max(1, next.need - cur.need);
    const t = clamp((r - cur.need) / span, 0, 1);
    $("#progressFill").style.width = (t*100).toFixed(1) + "%";
  }

  
  // ---- Offline Progress + Welcome Back Screen ----
  function applyOfflineProgress(){
    const now = Date.now();
    const last = Number(S.lastSeenAt || 0) || S.created || now;
    let elapsedSec = Math.max(0, (now - last) / 1000);

    // If the player has never actually entered the village (no name yet),
    // don't show a welcome-back popup or grant offline progress.
    if(!S.offlineReady){
      S.lastSeenAt = now;
      return;
    }

    // Skip tiny gaps to avoid spamming the player with popups.
    if(elapsedSec < 15){
      S.lastSeenAt = now;
      return;
    }

    // Cap offline time for balance.
    const cappedSec = Math.min(elapsedSec, 24 * 60 * 60);

    const grossInc = Math.max(0, incomePerSec());
    const upkeep   = Math.max(0, warriorUpkeepPerSec());
    const netRate  = Math.max(0, grossInc - upkeep);

    // Slight dampening so offline is good but not strictly better than active.
    const rateMult = 0.85;
    const goldGain = Math.floor(netRate * cappedSec * rateMult);

    // Offline settlers based on migration rate, clamped to pop cap.
    const cap = populationCap();
    const beforePop = S.population || 0;
    const migRate = (typeof migrationPerSec === "function") ? migrationPerSec() : 0;
    let settlersGain = 0;
    if(beforePop < cap && migRate > 0){
      const potential = Math.floor(migRate * cappedSec);
      settlersGain = Math.min(potential, Math.max(0, cap - beforePop));
    }

    // Apply gains
    if(goldGain > 0){
      S.gold += goldGain;
      S.lifetimeGold += goldGain;
    }
    if(settlersGain > 0){
      S.population = beforePop + settlersGain;
    }

    // ----- Living Realm Offline: build farms and villas while away -----
    // After collecting income and settlers, villagers may cultivate new farms and erect villas.
    // Use a simple time-slicing model: each farm takes ~2h of offline time and each villa ~8h.
    // Only build if you can afford the cost and, for villas, if your village has enough people.
    let offlineFarmsBuilt = 0;
    let offlineVillasBuilt = 0;
    let timeRemaining = cappedSec;
    const farmBuildTime = 2 * 60 * 60;   // 2 hours per farm
    const villaBuildTime = 8 * 60 * 60;  // 8 hours per villa

    // Build farms first: inexpensive economic expansion.
    while(timeRemaining >= farmBuildTime){
      const c = costFarm();
      // Break if you can't afford the next farm.
      if(S.gold < c) break;
      // Deduct cost and build.
      S.gold -= c;
      S.farmCount = (S.farmCount || 0) + 1;
      offlineFarmsBuilt++;
      // Advance time and update any relevant objectives.
      if(typeof bumpObjective === "function") bumpObjective("buildFarm", 1);
      timeRemaining -= farmBuildTime;
    }

    // Then build villas: slow, prestige-oriented expansion.
    while(timeRemaining >= villaBuildTime){
      const c = costVilla();
      // Must have enough gold and at least 20 residents to justify a new villa.
      if(S.gold < c || (S.population || 0) < 20) break;
      S.gold -= c;
      S.villaCount = (S.villaCount || 0) + 1;
      offlineVillasBuilt++;
      if(typeof bumpObjective === "function") bumpObjective("buildVilla", 1);
      timeRemaining -= villaBuildTime;
    }

    // Lifetime offline tracking
    if(!S.lifetimeOfflineSec || !Number.isFinite(S.lifetimeOfflineSec)){
      S.lifetimeOfflineSec = 0;
    }
    S.lifetimeOfflineSec += cappedSec;

    S.lastSeenAt = now;

    // Build a compact summary object for the welcome-back overlay.
    const farmRate  = (S.farmCount || 0) * 0.75;
    const villaRate = (S.villaCount || 0) * 3.0;
    const baseRate  = farmRate + villaRate;
    const landBoost = Math.max(0, grossInc - baseRate);

    const summary = {
      seconds: cappedSec,
      goldGain,
      settlersGain,
      grossRate: grossInc,
      netRate,
      farmRate,
      villaRate,
      landBoost,
      land: S.land || 0,
      territories: (typeof territoryCount === "function") ? territoryCount() : (S.land || 0)
      ,
      farmsBuilt: offlineFarmsBuilt,
      villasBuilt: offlineVillasBuilt
    };

    showOfflineOverlay(summary);
  }

  function formatDuration(seconds){
    const s = Math.floor(seconds);
    const h = Math.floor(s / 3600);
    const m = Math.floor((s % 3600) / 60);
    const rem = s % 60;
    if(h > 0){
      return `${h}h ${m}m`;
    }
    if(m > 0){
      return `${m}m ${rem}s`;
    }
    return `${rem}s`;
  }

  function showOfflineOverlay(summary){
    const overlay = document.getElementById("offlineOverlay");
    const body = document.getElementById("offlineBody");
    if(!overlay || !body) return;

    const duration = formatDuration(summary.seconds || 0);

    // Tiny helper for flavour randomisation.
    const pick = (arr)=> arr[Math.floor(Math.random() * arr.length)];

    // --- Time line ---
    const introOptions = [
      `You were away for about ${duration}.`,
      `While you were gone (${duration}), your people kept busy.`,
      `Time passed: about ${duration}‚Ä¶ but the village did not sleep.`
    ];
    const introLine = pick(introOptions);

    // --- Gold / taxes line ---
    let goldLine;
    if(summary.goldGain > 0){
      const goldPhrases = [
        `üí∞ Your stewards collected ${fmt(summary.goldGain)} denarii in tribute.`,
        `üí∞ Tax collectors brought in around ${fmt(summary.goldGain)} denarii.`,
        `üí∞ Quietly, the coffers filled with ${fmt(summary.goldGain)} denarii.`,
        `üí∞ Farmers and merchants paid in ${fmt(summary.goldGain)} denarii of dues.`
      ];
      goldLine = pick(goldPhrases);
    }else{
      const noGoldPhrases = [
        "üí∞ No meaningful taxes were collected.",
        "üí∞ The coffers stayed much the same.",
        "üí∞ Trade was quiet; almost no taxes came in."
      ];
      goldLine = pick(noGoldPhrases);
    }

    // --- Families / migration line ---
    let familiesLine;
    if(summary.settlersGain > 0){
      const n = summary.settlersGain;
      const familiesWord = `famil${n===1 ? "y" : "ies"}`;
      const famPhrases = [
        `üë• ${n} new ${familiesWord} arrived along the northern roads.`,
        `üë• ${n} ${familiesWord} drifted in from distant hamlets.`,
        `üë• ${n} ${familiesWord} pledged themselves to your protection.`,
        `üë• Word of your realm spread ‚Äî ${n} ${familiesWord} chose your lands.`
      ];
      familiesLine = pick(famPhrases);
    }else{
      const noFamPhrases = [
        "üë• No new families arrived ‚Äî word of your lands is still spreading.",
        "üë• No new families settled; homes and fields are at capacity.",
        "üë• The village held steady; no new faces joined the firelight."
      ];
      familiesLine = pick(noFamPhrases);
    }

    // --- Offline construction lines (farms / villas) ---
    const buildLines = [];
    if(summary.farmsBuilt && summary.farmsBuilt > 0){
      const n = summary.farmsBuilt;
      const farmPhrases = [
        `üåæ ${n} farm${n===1?"":"s"} were carved out of the fields while you were away.`,
        `üåæ Workers raised ${n} new farm${n===1?"":"s"} along the waterways.`,
        `üåæ ${n} farm${n===1?"":"s"} quietly took shape beyond the palisade.`
      ];
      buildLines.push(pick(farmPhrases));
    }
    if(summary.villasBuilt && summary.villasBuilt > 0){
      const n = summary.villasBuilt;
      const villaPhrases = n === 1
        ? [
            "üèõ A new villa was completed for a rising family.",
            "üèõ One villa rose from scaffolds into stone and timber.",
            "üèõ A proud villa now looks over your roads."
          ]
        : [
            `üèõ ${n} stately villas were finished for your wealthiest subjects.`,
            `üèõ Builders completed ${n} villas overlooking the countryside.`,
            `üèõ ${n} villas now house merchants, elders, and minor nobles.`
          ];
      buildLines.push(pick(villaPhrases));
    }

    // --- Economy summary / hint ---
    const farmVillaBits = [];
    if(summary.farmRate > 0)  farmVillaBits.push(`farms bringing in ~${summary.farmRate.toFixed(2)}/s`);
    if(summary.villaRate > 0) farmVillaBits.push(`villas yielding ~${summary.villaRate.toFixed(2)}/s`);
    if(summary.landBoost > 0) farmVillaBits.push("territories quietly boosting income");
    let economyLine;
    if(farmVillaBits.length){
      const joined = farmVillaBits.join(", ");
      const ecoPhrases = [
        `Behind the scenes, your economy ticked on ‚Äî ${joined}.`,
        `Harvests and rents flowed as usual: ${joined}.`,
        `Even without you, stewards kept things running: ${joined}.`
      ];
      economyLine = pick(ecoPhrases);
    }else{
      const ecoPhrases = [
        "Build farms, villas, and claim land to keep gold flowing while you‚Äôre away.",
        "More farms, villas, and territory will let your people thrive in your absence.",
        "Invest in farms, villas, and new lands so the realm prospers between visits."
      ];
      economyLine = pick(ecoPhrases);
    }

    // --- Territory summary ---
    const territories = summary.territories || 0;
    const land = summary.land || 0;
    const terrWord = `territor${territories===1?"y":"ies"}`;
    const tilesPhrases = [
      `Your banner now flies over ${fmt(territories)} ${terrWord} (${fmt(land)} land).`,
      `Elders now count ${fmt(territories)} ${terrWord} under your name (${fmt(land)} land).`,
      `Altogether, your realm spans ${fmt(territories)} ${terrWord} and ${fmt(land)} parcels of land.`
    ];
    const tilesLine = pick(tilesPhrases);

    // --- Render lines into overlay body ---
    body.innerHTML = "";

    const pIntro = document.createElement("p");
    pIntro.textContent = introLine;
    body.appendChild(pIntro);

    for(const line of buildLines){
      const p = document.createElement("p");
      p.textContent = line;
      body.appendChild(p);
    }

    const pFamilies = document.createElement("p");
    pFamilies.textContent = familiesLine;
    body.appendChild(pFamilies);

    const pGold = document.createElement("p");
    pGold.textContent = goldLine;
    body.appendChild(pGold);

    const pEco = document.createElement("p");
    pEco.textContent = economyLine;
    body.appendChild(pEco);

    const pTiles = document.createElement("p");
    pTiles.textContent = tilesLine;
    body.appendChild(pTiles);

    overlay.removeAttribute("hidden");
    overlay.classList.add("visible");
  }
function statsRows(){
    const leg = recalcLegionStrength();
    const rows = [
      ["Gold", S.gold],
      ["Renown", S.renown],
      ["Income / sec", incomePerSec().toFixed(1)],
      ["Tap base (tribute)", S.tribute],
      ["Rank tap bonus", rankTributeBonus(titleInfo().idx)],
      ["Streak", "x"+S.streak],
      ["Crit chance", Math.round(critChance()*100)+"%"],
      ["Farms", S.farmCount],
      ["Villas", S.villaCount],
      ["Milites", S.warriors],
      ["Cavalry", S.cavalry || 0],
      ["Auxilia", S.auxilia || 0],
      ["Equites", S.equites || 0],
      ["Veteran cohorts", S.veterans || 0],
      ["Legion attack", Math.round(leg.atk)],
      ["Legion defence", Math.round(leg.def)],
      ["Legion HP", Math.round(leg.hp)],
      ["Raids won", S.battlesWon],
      ["Territories", territoryCount()],
      ["Frontline (pop used)", S.populationUsed],
      ["Population Cap", populationCap()],
      ["Faith", S.faith],
      ["Crowns (prestige)", S.crowns],
      ["Ascensions", S.ascends || 0],
      ["Best streak (all time)", S.bestStreak || 0],
      ["Biggest cashout", S.biggestCashout || 0],
      ["Multipliers", `Land x${landMult().toFixed(2)} ‚Ä¢ Crown x${crownMult().toFixed(2)}`],
      ["Lifetime denarii", S.lifetimeGold],
      ["Lifetime renown", S.lifetimeRenown],
      ["Glory", S.glory || 0],
      ["Total glory earned", S.lifetimeGlory || 0],
    ];
    return rows;
  }


  // Update the Milites header icon based on rank. For the first few
  // ranks we show the basic milites sprite; higher ranks can later use
  // different art or hide the icon entirely.
  let _militesIconRankIdx = null;

  function updateMilitesIcon(){
    const icon = $("#militesIcon");
    if(!icon) return;
    const info = titleInfo();
    const idx = info.idx || 0;

    // Avoid rebinding the same sprite every render tick; only update when rank changes.
    if(_militesIconRankIdx === idx) return;
    _militesIconRankIdx = idx;

    // First four ranks (Elder ‚Üí Council Elder) use the base sprite.
    if(idx <= 3){
      icon.src = "Sprites/MiliteForElder.png";
      icon.alt = "Milites";
      icon.style.display = "inline-block";
    }else{
      // Hide for now at higher ranks (you can swap to other sprites later)
      icon.style.display = "none";
    }
  }

  function render(){
handleRankUps();
    expireCashoutIfNeeded();
    expireStreakIfNeeded();
    updateTerritoryProjects();

    $("#gold").textContent = fmt(S.gold);
    $("#renown").textContent = fmt(S.renown);
    $("#landHud").textContent = fmt(S.land || 0);

    const grossInc = incomePerSec();
    const upkeepNow = warriorUpkeepPerSec();
    const netInc = Math.max(0, grossInc - upkeepNow);
    $("#incomeRate").textContent = netInc.toFixed(1);
    $("#incomeRate").title = `Gross: ${grossInc.toFixed(2)}/s, Upkeep: -${upkeepNow.toFixed(2)}/s`;

    // Compact income breakdown text under the village panel
    const farmBase = (S.farmCount || 0) * 0.75;
    const villaBase = (S.villaCount || 0) * 3.0;
    const bd = $("#incomeBreakdown");
    if(bd){
      bd.textContent =
        `Farms ${farmBase.toFixed(2)}/s ‚Ä¢ Villas ${villaBase.toFixed(2)}/s ` +
        `‚Ä¢ Upkeep -${upkeepNow.toFixed(2)}/s ‚Ä¢ Net ${netInc.toFixed(2)}/s`;
    }

    // Renown soft-tech: passive decree unlocks from fame (no choices, pure dopamine)
    (function applyRenownPerks(){
      const ren = S.renown || 0;
      const prevLevel = S.renownPerkLevel || 0;
      let level = 0;
      if(ren >= 1500) level = 1;
      if(ren >= 6000) level = 2;
      if(ren >= 20000) level = 3;

      if(level > prevLevel){
        // Base decrees granted by reputation alone; never reduce manual ones.
        const baseFromRenown = level; // 1,2,3
        if((S.decrees||0) < baseFromRenown){
          const gained = baseFromRenown - (S.decrees||0);
          S.decrees = baseFromRenown;
          logLine(`Your fame grants you ${gained} royal decree${gained>1?"s":""}.`, "good");
          toast("Renown unlocks new decrees");
        }
        S.renownPerkLevel = level;
      }
    })();

    // Population display (village capacity)
    const cap = populationCap();
    const totalPop = (S.population||0);
    const warriors = (S.warriors||0); // line infantry
    const cavalry  = (S.cavalry||0);  // mounted troops using population
    const labourers = (typeof totalTypeWorkers === "function") ? totalTypeWorkers() : 0;
    const frontlineUsed = warriors + cavalry;
    const civilians = Math.max(0, totalPop - frontlineUsed);
    const freePop = Math.max(0, civilians - labourers);
    const pu = $("#popUsed"); const pc = $("#popCap");
    const mr = (typeof migrationPerSec === "function") ? migrationPerSec() : 0;
    $("#migRate") && ($("#migRate").textContent = (Math.round(mr*100)/100).toFixed(2));
    if(pu && pc){
      pu.textContent = `${fmt(totalPop)} (Free: ${fmt(freePop)}, Warriors: ${fmt(warriors)}, Cavalry: ${fmt(cavalry)}, Labourers: ${fmt(labourers)})`;
      pc.textContent = fmt(cap);
    }


    // Village
    const t = tapGain();
    $("#tributeGain").textContent = `+${fmt(t.gain)} denarii`;
    const critPct = Math.round(critChance() * 100);
    $("#tributeHint").textContent = `Streak x${S.streak} ‚Ä¢ ${Math.ceil(streakTimeLeftMs()/100)/10}s${rushBonus()>0 ? ` ‚Ä¢ RUSH +${rushBonus()}` : ""}${isBuffed() ? " ‚Ä¢ BLESSED" : ""}${Date.now() < (S.feverUntil||0) ? " ‚Ä¢ FEVER" : ""}${Date.now() < (S.objDoubleUntil||0) ? " ‚Ä¢ DOUBLE OBJ" : ""} ‚Ä¢ CRIT ${critPct}%`;


    // Cash Out UI
    const cbtn = $("#btnCashout");
    if(cbtn){
      const pot = cashoutPotential();
      const ready = cashoutReady();
      cbtn.style.display = "flex";
      cbtn.disabled = !ready;
      const cd = Math.max(0, Math.ceil(((S.cashoutCooldownUntil||0) - Date.now())/1000));
      if(pot <= 0){
        $("#cashoutDesc").textContent = `Unlock at streak x${CASHOUT_MIN_STREAK}`;
      }else if(cd>0){
        $("#cashoutDesc").textContent = `Cooling down (${cd}s)`;
      }else{
        const ms = Math.floor((S.streak||1)/10);
        $("#cashoutDesc").textContent = `Cash out +${fmt(pot)} denarii${ms>0 ? ` ‚Ä¢ Milestones ${ms}` : ""}`;
      }
    }


    $("#hutDesc").textContent   = `${fmt(S.hutCount||0)} huts ‚Ä¢ Cost ${fmt(costHut())} ‚Ä¢ +2 pop cap each`;
    $("#farmDesc").textContent  = `${fmt(S.farmCount)} farms ‚Ä¢ Cost ${fmt(costFarm())} ‚Ä¢ +0.75 denarii/s each`;
    $("#villaDesc").textContent = `${fmt(S.villaCount)} villas ‚Ä¢ Cost ${fmt(costVilla())} ‚Ä¢ +3.0 denarii/s each ‚Ä¢ +10 pop cap`;

    updateTitleProgress();

    // Legion
    const legStats = recalcLegionStrength();
    const wEl = $("#warriors");
    if(wEl) wEl.textContent = fmt(S.warriors);
    const ownedMil = $("#ownedMilites");
    if(ownedMil) ownedMil.textContent = fmt(S.warriors);

    const ownedCav = $("#ownedCavalry");
    if(ownedCav) ownedCav.textContent = fmt(S.cavalry || 0);
    $("#landLegion").textContent = fmt(S.land || 0);
    $("#landHud").textContent = fmt(S.land || 0);

    // Glory HUD (battle-only currency)
    const gNow = S.glory || 0;
    const gloryNowEl = $("#gloryNow");
    if(gloryNowEl) gloryNowEl.textContent = fmt(gNow);
    const gloryOverlayEl = $("#gloryOverlayNow");
    if(gloryOverlayEl) gloryOverlayEl.textContent = fmt(gNow);
    const ownedAuxEl = $("#ownedAux");
    if(ownedAuxEl) ownedAuxEl.textContent = fmt(S.auxilia || 0);
    const ownedEqEl = $("#ownedEquites");
    if(ownedEqEl) ownedEqEl.textContent = fmt(S.equites || 0);
    const ownedVetEl = $("#ownedVets");
    if(ownedVetEl) ownedVetEl.textContent = fmt(S.veterans || 0);

    const up = warriorUpkeepPerSec();
    const upEl = $("#legionUpkeep");
    if(upEl){
      upEl.textContent = up.toFixed(2);
    }

    const rcEl = $("#recruitCost");
    if(rcEl) rcEl.textContent = `Cost ${fmt(recruitCost())}`;

    const rcCavEl = $("#recruitCavCost");
    if(rcCavEl) rcCavEl.textContent = `Cost ${fmt(cavalryRecruitCost())}`;

    const rgEl = $("#recruitGain");
    if(rgEl) rgEl.textContent = `+1 milites`;

    // Update Milites header icon depending on current rank.
    updateMilitesIcon();

    
    
    // Battles (rank-based)
    const bs = currentBattleSet();
    const btns = [
      { btn:"#btnBattleBandits1", titleSel:"#btnBattleBandits1 .t", desc:"#battleBandits1Desc" },
      { btn:"#btnBattleLevy",     titleSel:"#btnBattleLevy .t",     desc:"#battleLevyDesc" },
      { btn:"#btnBattleVillageRaid", titleSel:"#btnBattleVillageRaid .t", desc:"#battleVillageRaidDesc" },
      { btn:"#btnBattleSiege",    titleSel:"#btnBattleSiege .t",    desc:"#battleSiegeDesc" }
    ];
    const { idx } = titleInfo();
    const tier = battleTierFromTitleIdx(idx);

    for(let i=0;i<4;i++){
      const base = bs[i];
      if(!base) continue;
      const tEl = $(btns[i].titleSel);
      const dEl = $(btns[i].desc);

      const arch = battleArchetypeFor(tier, i);
      const ctx  = getBattleContext(tier, i, arch, base);

      const min = base.enemyMin;
      const max = base.enemyMax;
      const range = (min===max) ? `${min}` : `${min}‚Äì${max}`;

      // Keep the archetype label everywhere
      const label = ctx.label;
      base.label = label;

      if(tEl){
        const starsCount = ctx.difficultyStars || 1;
        const stars = "‚òÖ".repeat(starsCount);
        const rarity = ctx.rarityLabel || "";
        const diffName = ctx.difficultyName || "";
        const ariaHint = diffName
          ? (rarity ? diffName + " ‚Ä¢ " + rarity : diffName)
          : rarity;
        tEl.innerHTML =
          `<span class="battleTitleText">${label}</span>` +
          `<span class="battleStars" aria-label="${ariaHint}">${stars}</span>`;
      }
      if(dEl){
        // Structured battle preview:
        //  Line 1: Faction (icon + name)
        //  Line 2: Scale ‚Ä¢ Discipline ‚Ä¢ enemies ‚Ä¢ Tier
        //  Line 3: Leader
        //  Line 4: Outcome hint
        const kind = ctx.kind || (arch && arch.kind) || "";
        const kindTag = kind === "skirmish"
          ? "Skirmish"
          : kind === "feud"
            ? "Feud"
            : kind === "field"
              ? "Field action"
              : kind === "siege"
                ? "Siege"
                : "";

        const faction = battleFactionMetaForTier(tier, kind, min, max);
        const leader = ctx.leader || "";
        const outcome = battleOutcomeLabel(kind, tier);

        const line1 = `${faction.icon} ${faction.name}`;

        const parts2 = [];
        if(faction.scale) parts2.push(faction.scale);
        if(faction.order) parts2.push(faction.order);
        if(range) parts2.push(`${range} enemies`);
        parts2.push(`Tier ${tier}`);
        const line2 = parts2.join(" ‚Ä¢ ");

        const line3 = leader ? `Leader: ${leader}` : "";
        const line4 = outcome;

        let txt = line1;
        if(line2) txt += "\n" + line2;
        if(line3) txt += "\n" + line3;
        if(line4) txt += "\n" + line4;

        dEl.textContent = txt;
      }
    }
    const cd = 0; // battle cooldown disabled

    // Battles: only requirement is "do you have any milites?"
    const hasTroops = (S.warriors || 0) > 0;

    $("#btnBattleBandits1").disabled    = !hasTroops;
    $("#btnBattleLevy").disabled        = !hasTroops;
    $("#btnBattleVillageRaid").disabled = !hasTroops;
    $("#btnBattleSiege").disabled       = !hasTroops;


// Village capacity hint: recruiting uses capacity, but battles are allowed regardless.
    if(!hasVillageCapacity()){
    }

    // Temple
    $("#crowns").textContent = fmt(S.crowns);
    $("#offerCost").textContent = `Cost ${fmt(offerCost())}`;
    $("#faithNow").textContent = `Faith ${fmt(S.faith)}`;
    $("#critRate").textContent = Math.round(critChance()*100) + "%";
    const buffLeft = Math.max(0, Math.ceil((S.buffUntil - Date.now())/1000));
    $("#buffLeft").textContent = buffLeft + "s";
    const blessCd = Math.max(0, Math.ceil((S.blessReadyAt - Date.now())/1000));
    $("#blessDesc").textContent = blessCd>0 ? `CD ${blessCd}s ‚Ä¢ doubles crits` : `Ready ‚Ä¢ doubles crits`;
    $("#btnBless").disabled = blessCd>0;
    const crownsGain = ascendCrownGain();
    $("#ascendDesc").textContent = crownsGain>0 ? `Reset for +${crownsGain} crowns` : `Need 8,000 renown`;


    // Territories (named lands)
    const terrCount = territoryCount();
    if($("#territoryCount")) $("#territoryCount").textContent = fmt(terrCount);
    if($("#landTotal")) $("#landTotal").textContent = fmt(S.land||0);

    // Land output summary
    const landDen = landBaseIncome() + landWorkersIncome();
    const landPop = landBasePopCap();
    if($("#landOutputDen")) $("#landOutputDen").textContent = `+${fmt(landDen)} Denarii / tick`;
    if($("#landOutputPop")) $("#landOutputPop").textContent = `+${fmt(landPop)} Cap`;

    // HUD Land counters show numeric land
    if($("#landHud"))    $("#landHud").textContent = fmt(S.land||0);
    if($("#landLegion")) $("#landLegion").textContent = fmt(S.land||0);

    
    const listEl  = $("#territoryList");
    const emptyEl = $("#territoryEmpty");
    const summaryEl = $("#landSummaryBlock");

    const arr = Array.isArray(S.controlledRegions) ? S.controlledRegions : [];

    
// Compact land summary line, tied to the cards below
    if(summaryEl){
      if(!arr.length){
        summaryEl.style.display = "none";
        summaryEl.textContent = "";
      }else{
        summaryEl.style.display = "block";
        summaryEl.textContent = `Controlled Land ‚Äî ${fmt(arr.length)} Territories`;
      }
    }

    if(listEl){
      listEl.innerHTML = "";

      if(emptyEl){
        emptyEl.style.display = arr.length ? "none" : "block";
      }

      // Group territories by type so each card shows Tiles: X
      const grouped = {};
      for(const terr of arr){
        if(!grouped[terr.name]){
          grouped[terr.name] = {
            count: 0,
            summary: terr.summary,
            den: 0,
            cap: 0
          };
        }
        const g = grouped[terr.name];
        g.count += 1;
        const eff = LAND_TYPE_EFFECTS[terr.name] || {};
        if(eff.den) g.den += eff.den;
        if(eff.pop) g.cap += eff.pop;
      }

      // Render one simple card per land type
      Object.entries(grouped).sort((a,b)=>a[0].localeCompare(b[0])).forEach(([name,info])=>{
        const workers = (S.territoryWorkers && S.territoryWorkers[name]) || 0;
        const tiles = info.count;
        const maxWorkers = tiles * 5; // 5 labourers per tile


        const workerYield = workers * 0.4; // each worker adds +0.4 denarii/s
        const totalDen = info.den + workerYield;
        const card = document.createElement("div");
        card.className = "smallBtn territoryCard";
        card.innerHTML = `
          <div class="territoryCardHeader">
            <div class="t">${name}</div>
          </div>
          <div class="d" style="text-align:left;">
            <div>Tiles: <b>${fmt(tiles)}</b></div>
            <div class="territoryYieldLine">
              These yield:
              ${ (totalDen > 0) ? " &#x1F4B0; +" + fmt(totalDen) + " Denarii" : "" }
              ${info.cap ? " &#x1F465; +" + fmt(info.cap) + " Cap" : ""}
              ${workers ? (" (includes +" + fmt(workerYield) + " from labourers)") : ""}
            </div>
            <div class="territoryWorkersRow">
              <button
                type="button"
                class="tinyBtn terrWorkerBtn"
                data-type="${name}"
                data-delta="-1"
              >
                ‚àí
              </button>
              <div class="territoryWorkersMeta">
                <div class="territoryWorkersValue">
                  <b>${fmt(workers)}</b> / ${fmt(maxWorkers)}
                </div>
                <span class="territoryWorkersHint">(each worker boosts income)</span>
              </div>
              <button
                type="button"
                class="tinyBtn terrWorkerBtn"
                data-type="${name}"
                data-delta="1"
              >
                +
              </button>
            </div>
          </div>
        `;
        listEl.appendChild(card);
      });

      // Wire up worker +/- buttons after all cards are in the DOM
      $$(".terrWorkerBtn").forEach(btn=>{
        btn.addEventListener("click", (e)=>{
          const tName = btn.getAttribute("data-type");
          const delta = Number(btn.getAttribute("data-delta") || "0");
          if(tName && delta){
            adjustTypeWorkers(tName, delta);
          }
        });
      });
    }

// Stats
    const body = $("#statsTable");
    if(body){
      body.innerHTML = "";
      for(const [k,v] of statsRows()){
        const tr = document.createElement("tr");
        const td1 = document.createElement("td");
        const td2 = document.createElement("td");
        td1.textContent = k;
        td2.textContent = (typeof v === "number") ? fmt(v) : String(v);
        tr.appendChild(td1); tr.appendChild(td2);
        body.appendChild(tr);
      }
    }

    // global
    renderTabs();
    renderObjectives();
    $("#subline").textContent = (Date.now() < (S.prosperUntil||0))
      ? "Prosperity active ‚Äî income is boosted."
      : (isBuffed()
          ? "Blessing active ‚Äî crits are juiced."
          : "Unlock tabs by earning renown. Prestige later for crowns.");
    save(true);
  }
  // ---- Actions ----
  $("#btnTribute").addEventListener("click", (e)=>{
    applyStreak();
    const {gain, crit, critMult} = tapGain();

    // Jackpots: rare huge spikes layered on top of small taps
    const jp = rollJackpot();
    let jackpotGain = 0;
    if(jp){
      // Jackpot scales with your effective tap gain (already includes multipliers)
      jackpotGain = Math.round(gain * jp.mult);
      toast(jp.type + "!");
      logLine(`${jp.type}! (+${fmt(jackpotGain)} denarii)`, "good");
    }

    S.gold += (gain + jackpotGain);
    S.lifetimeGold += (gain + jackpotGain);

    bumpObjective("tap", 1);
    bumpEarnedDenarii(gain + jackpotGain);

    // Small renown trickle from visible wealth: big tribute taps
    // and a grown realm make your name travel.
    const totalTapGold = gain + jackpotGain;
    if(totalTapGold > 0){
      const terr = (S.controlledRegions && S.controlledRegions.length) || 0;
      const villas = S.villaCount || 0;
      let tapRen = 0;

      // Wealth-based renown: only kicks in on meaningful taps.
      tapRen += Math.floor(totalTapGold / 18000);

      // Realm size gently boosts it.
      if(terr >= 3)  tapRen += 1;
      if(villas >= 6) tapRen += 1;

      // Soft cap and dampening at higher renown so it doesn't explode midgame.
      if(tapRen > 0){
        const ren = S.renown || 0;
        if(ren > 0){
          tapRen = Math.max(1, Math.round(tapRen / (1 + ren / 9000)));
        }
        tapRen = Math.min(tapRen, 12);
        S.renown += tapRen;
        S.lifetimeRenown += tapRen;
      }
    }


    // Streak taps occasionally attract a new settler directly (population dopamine).
    if(hasVillageCapacity()){
      const s = Math.max(1, S.streak || 1);
      if(s > 1 && s % 5 === 0){
        const beforePop = S.population || 0;
        S.population = Math.min(populationCap(), beforePop + 1);
        if(S.population > beforePop){
          logLine("A villager is impressed by your prosperity and settles in your village.", "good");
          const settlerRect = e.currentTarget.getBoundingClientRect();
          sparkAt(
            settlerRect.left + settlerRect.width * 0.28,
            settlerRect.top  + settlerRect.height * 0.25,
            0.45
          );
        }
      }
    }

    const rect = e.currentTarget.getBoundingClientRect();
    const goldness = crit ? 0.95 : 0.25;
    sparkAt(rect.left + rect.width*0.78, rect.top + rect.height*0.42, goldness);

    if(jp){ for(let i=0;i<3;i++) sparkAt(rect.left + rect.width*(0.55 + i*0.12), rect.top + rect.height*0.30, 0.70); }

    if(crit){
      const multLabel = (typeof critMult === "number" && critMult > 1)
        ? ` x${critMult} `
        : " ";
      toast(`CRIT${multLabel.trim()}!`);
      logLine(`CRIT${multLabel}tribute! (+${fmt(gain)} denarii)`, "good");
    } else if(S.streak % 7 === 0){
      logLine(`Tribute collected. (+${fmt(gain)} denarii)`, "good");
    }
    
    // Cash Out: bank some value as you tap; becomes claimable every few taps.
    S.tapsSinceCashout += 1;
    bankCashout(gain + Math.round(jackpotGain*0.08));
    

    // Chance for a defensive/local skirmish popup (does not break streak)
    maybeSpawnDefenceFromTap();
    
    render();

  });

  $("#btnHut").addEventListener("click", ()=>{
    const c = costHut();
    if(S.gold < c){ toast("Not enough denarii"); return; }
    S.gold -= c;
    S.hutCount = (S.hutCount||0) + 1;
    toast("Huts raised ‚Äî word spreads");
    render();
  });

  $("#btnFarm").addEventListener("click", ()=>{
    const c = costFarm();
    if(S.gold < c){ toast("Not enough denarii"); return; }
    S.gold -= c;
    S.farmCount += 1;
    bumpObjective("buildFarm", 1);
    // Renown removed here; battles now grant renown.
    logLine("A farm feeds your people. (+income)", "good");
    toast("Village capacity grows");
    render();
  });

  $("#btnVilla").addEventListener("click", ()=>{
    const c = costVilla();
    if(S.gold < c){ toast("Not enough denarii"); return; }
    S.gold -= c;
    S.villaCount += 1;
    bumpObjective("buildVilla", 1);
    // Renown removed here; battles now grant renown.
    logLine("A villa rises. The taxes flow.", "good");
    toast("Village capacity grows");
    render();
  });
  $("#btnRecruit").addEventListener("click", (e)=>{
  const c = recruitCost();
  if(S.gold < c){
    toast("Not enough denarii");
    return;
  }

  // You can only recruit if you have an unassigned settler to train.
  // (Population is filled slowly up to the cap by "settlers".)
  const pop = S.population || 0;
  const warriors = S.warriors || 0;
  const cavalry = S.cavalry || 0;
  const labourers = (typeof totalTypeWorkers === "function") ? totalTypeWorkers() : 0;

  // Population is: warriors + cavalry + labourers + free civilians.
  const civilians = Math.max(0, pop - warriors - cavalry - labourers);

  if(civilians < 1){
    toast("No free settlers ‚Äî build housing and wait for more to arrive");
    return;
  }

  // Pay the cost and convert 1 civilian into a milites.
  S.gold -= c;
  S.warriors = warriors + 1;
  S.populationUsed = (S.warriors||0) + (S.cavalry||0); // keep pop-used in sync with milites

  recalcLegionStrength();

  // Recruiting progresses recruit-related objectives.
  bumpObjective("recruit", 1);

  // Nice but safe coin spark (no undefined payout!)
  const rect = e.currentTarget.getBoundingClientRect();
  const goldness = clamp(0.35 + (S.warriors || 0) * 0.015, 0.35, 0.9);
  sparkAt(
    rect.left + rect.width * 0.80,
    rect.top  + rect.height * 0.45,
    goldness
  );

  toast("Recruited");
  logLine(`A milites joins your banner. (Milites: ${fmt(S.warriors)})`, "good");

  render();
});

  $("#btnRecruitCavalry").addEventListener("click", (e)=>{
    const c = cavalryRecruitCost();
    if(S.gold < c){
      toast("Not enough denarii");
      return;
    }

    // Same free population rule: must have an unassigned settler.
    const pop = S.population || 0;
    const warriors = S.warriors || 0;
    const cavalry = S.cavalry || 0;
    const labourers = (typeof totalTypeWorkers === "function") ? totalTypeWorkers() : 0;

    const civilians = Math.max(0, pop - warriors - cavalry - labourers);
    if(civilians < 1){
      toast("No free settlers ‚Äî build housing and wait for more to arrive");
      return;
    }

    // Pay cost and convert 1 civilian into a cavalry unit.
    S.gold -= c;
    S.cavalry = cavalry + 1;
    S.populationUsed = (S.warriors||0) + (S.cavalry||0);

    recalcLegionStrength();
    bumpObjective("recruit", 1);

    const rect = e.currentTarget.getBoundingClientRect();
    const goldness = clamp(0.45 + (S.cavalry || 0) * 0.018, 0.45, 0.92);
    sparkAt(
      rect.left + rect.width * 0.6,
      rect.top  + rect.height* 0.4,
      1,
      (S.tribute || 0) * (goldness)
    );

    toast("New cavalry unit recruited.");
    render();
  });
// ---- Defensive/local skirmish popups ----

// We piggyback off taps: occasionally, your lands are tested.
// These are *defensive* battles: no land gain, just gold + renown.
// Ignoring them is safe but costly (gold + renown loss).

function defenceSpawnChance(){
  const wins = S.battlesWon || 0;
  // Starts small, ramps up as your realm gets bloodier
  const base = 0.012;
  const extra = Math.min(wins * 0.0006, 0.02);
  return base + extra;
}

function defenceIgnoreCostDen(){
  const gold = S.gold || 0;
  const tier = battleTierFromTitleIdx(titleInfo().idx);
  // 6‚Äì18% of current gold, scaled by title tier, with a floor
  const pct = 0.06 + tier * 0.02;
  const pctLoss = Math.round(gold * pct);
  const floor = 12 + tier * 9;
  return Math.max(floor, pctLoss);
}

function defenceIgnoreCostRen(){
  const tier = battleTierFromTitleIdx(titleInfo().idx);
  // Small but non-trivial hit to reputation
  return Math.max(1, tier * 3);
}

function maybeSpawnDefenceFromTap(){
  // Don‚Äôt stack multiple popups, don‚Äôt fire during intro, and only if you actually have troops
  if(window.defenceOverlayOpen) return;
  if(!S.introBattleDone) return;
  if((S.warriors || 0) <= 0) return;

  if(Math.random() > defenceSpawnChance()) return;

  const slot = 0; // use the lowest slot as a local-border defence template
  const b = currentBattleSet()[slot];
  if(!b) return;

  openDefencePopup(slot, b);
}




function openDefencePopup(slot, battle){
  if(window.defenceOverlayOpen) return;
  window.defenceOverlayOpen = true;

  // Protect the streak window while the player is reading this
  S.lastTap = Date.now();

  const overlay = document.createElement("div");
  overlay.id = "defencePopup";
  overlay.style.position = "fixed";
  overlay.style.inset = "0";
  overlay.style.background = "rgba(0,0,0,0.55)";
  overlay.style.display = "flex";
  overlay.style.alignItems = "center";
  overlay.style.justifyContent = "center";
  overlay.style.zIndex = "1600";

  const card = document.createElement("section");
  card.className = "card";
  card.style.maxWidth = "420px";
  card.style.margin = "0 14px";

  const header = document.createElement("div");
  header.className = "sectionTitle";

  // Risk icon based on size of the raid
  const min = battle.enemyMin || 5;
  const max = battle.enemyMax || (min + 10);
  let riskWord = "Small raid";
  let riskIcon = "üü¢";
  if(max >= 60){ riskWord = "Large warband"; riskIcon = "üî¥"; }
  else if(max >= 30){ riskWord = "Raiding party"; riskIcon = "üü†"; }

  header.innerHTML = `<span style="font-weight:700;color:var(--text)">Defence</span>`;

  const bodyWrap = document.createElement("div");
  bodyWrap.className = "cardBody";

  const title = document.createElement("div");
  title.textContent = battle.label;
  title.style.fontFamily = "var(--mono)";
  title.style.fontSize = ".86rem";
  title.style.fontWeight = "700";
  title.style.color = "var(--text)";
  title.style.marginBottom = "4px";

  const desc = document.createElement("div");
  desc.style.fontSize = ".8rem";
  desc.style.marginBottom = "10px";
  desc.textContent = "Enemy raiders are disrupting your lands.";

  const stats = document.createElement("div");
  stats.style.fontFamily = "var(--mono)";
  stats.style.fontSize = ".78rem";
  stats.style.border = "1px solid rgba(158,104,54,.6)";
  stats.style.borderRadius = "12px";
  stats.style.padding = "8px 10px";
  stats.style.marginBottom = "12px";
  stats.style.background = "rgba(255,255,255,0.45)";

  let enemyLine;
  if(min === max){
    enemyLine = `Enemies: ${min} (${riskWord})`;
  }else{
    enemyLine = `Enemies: ${min}‚Äì${max} (${riskWord})`;
  }
  const defendersLine = `Defenders Available: ${fmt(S.warriors||0)} milites`;

  stats.innerHTML = `<div>${enemyLine}</div><div>${defendersLine}</div>`;

  const costsDen = defenceIgnoreCostDen();
  const costsRen = defenceIgnoreCostRen();

  const actions = document.createElement("div");
  actions.style.display = "flex";
  actions.style.flexDirection = "column";
  actions.style.gap = "8px";

  const btnEngage = document.createElement("button");
  btnEngage.className = "smallBtn";
  btnEngage.innerHTML = `<div class="t">üõ°Ô∏è Defend</div><div class="d">Risk milites, no payment.</div>`;

  const btnIgnore = document.createElement("button");
  btnIgnore.className = "smallBtn";
  btnIgnore.innerHTML = `<div class="t">üí∞ Buy Them Off ‚Äî ${fmt(costsDen)}d, ${fmt(costsRen)}r</div><div class="d">Avoid casualties.</div>`;

  btnEngage.addEventListener("click", ()=>{
    closeDefencePopup(overlay);
    // Refresh lastTap so streak window resumes from now
    S.lastTap = Date.now();
    // Launch a tactical defence instead of auto-resolve
    startTacticalBattle(slot, true);
  });

  btnIgnore.addEventListener("click", ()=>{
    const costDen = defenceIgnoreCostDen();
    const costRen = defenceIgnoreCostRen();

    const goldLoss = Math.min(costDen, S.gold || 0);
    S.gold = (S.gold || 0) - goldLoss;
    S.renown = Math.max(0, (S.renown || 0) - costRen);

    closeDefencePopup(overlay);
    S.lastTap = Date.now();

    toast("You pay them off.");
    logLine(
      `You buy off raiders instead of fighting. -${fmt(goldLoss)} denarii, -${fmt(costRen)} renown.`,
      "warn"
    );
    render();
  });

  actions.appendChild(btnEngage);
  actions.appendChild(btnIgnore);

  bodyWrap.appendChild(title);
  bodyWrap.appendChild(desc);
  bodyWrap.appendChild(stats);
  bodyWrap.appendChild(actions);

  card.appendChild(header);
  card.appendChild(bodyWrap);

  overlay.appendChild(card);
  document.body.appendChild(overlay);
}


function closeDefencePopup(overlay){
  window.defenceOverlayOpen = false;
  try{
    if(overlay && overlay.parentNode){
      overlay.parentNode.removeChild(overlay);
    }
  }catch(e){}
}

  // Land allocation buttons: tap to assign a plot if any are free.
  function adjustLandAllocation(key){
    const free = freeLandPlots();
    if(free <= 0){
      toast("No free plots ‚Äî win more land in battle.");
      return;
    }
    switch(key){
      case "agriculture": S.landAgriculture = (S.landAgriculture||0) + 1; break;
      case "military":    S.landMilitary    = (S.landMilitary||0) + 1; break;
      case "housing":     S.landHousing     = (S.landHousing||0) + 1; break;
      case "governance":  S.landGovernance  = (S.landGovernance||0) + 1; break;
    }
    toast("Plot allocated");
    render();
    if(typeof scheduleSave === "function") scheduleSave();
  }

  $("#landAgricultureBtn") && $("#landAgricultureBtn").addEventListener("click", ()=>adjustLandAllocation("agriculture"));
  $("#landMilitaryBtn") && $("#landMilitaryBtn").addEventListener("click", ()=>adjustLandAllocation("military"));
  $("#landHousingBtn") && $("#landHousingBtn").addEventListener("click", ()=>adjustLandAllocation("housing"));
  $("#landGovernanceBtn") && $("#landGovernanceBtn").addEventListener("click", ()=>adjustLandAllocation("governance"));

  
    
// --- Battle Report overlay (after every battle) ---

function showBattleReport(rep){
  const overlay = document.getElementById("battleOverlay");
  const body = document.getElementById("battleBody");
  const title = document.getElementById("battleTitle");
  if(!overlay || !body || !title) return;

  const denChange = rep.denDelta || 0;
  const landChange = rep.landDelta || 0;
  const renChange = rep.renDelta || 0;
  const gloryChange = rep.gloryDelta || 0;
  const slotsChange = rep.landSlots || 0; // kept for mechanics, not shown in UI

  title.textContent = rep.win ? "Battle Victory!" : "Battle Defeat";

  const lines = [];
  lines.push(rep.win ? "Battle Victory!" : "Battle Defeat.");

  // Show treasure tier (if this warband was carrying extra spoils)
  if(rep && rep.win && rep.treasureType && rep.treasureType !== "normal"){
    let tLabel = "";
    if(rep.treasureType === "fat") tLabel = "Treasure: Fat purses";
    else if(rep.treasureType === "rich") tLabel = "Treasure: Rich caravan";
    else if(rep.treasureType === "jackpot") tLabel = "Treasure: Jackpot hoard";
    if(tLabel) lines.push(tLabel);
  }

  // Show the actual battle loot (not just net delta) so it always "feels" like a reward
  if(rep && rep.win && typeof rep.loot === "number" && rep.loot > 0){
    lines.push(`Loot taken: +${fmt(Math.round(rep.loot))} Denarii`);
  }

  if(rep.win){
    const names = Array.isArray(rep.territoryNames) ? rep.territoryNames : [];
    if(names.length > 0){
      // Group captured territory names into a "Captured:" section
      lines.push("Captured:");
      const counts = {};
      for(const n of names){
        counts[n] = (counts[n]||0) + 1;
      }
      Object.entries(counts).sort((a,b)=>a[0].localeCompare(b[0])).forEach(([name,count])=>{
        lines.push(`‚Ä¢ ${name} √ó${fmt(count)}`);
      });
    }else if(landChange > 0){
      // Fallback if we somehow gained land but have no names
      lines.push(`Captured: +${fmt(landChange)} land`);
    }else{
      lines.push("Captured: No new land");
    }
  }

  if(renChange !== 0){
    const r = renChange;
    lines.push(`${r > 0 ? "+" : "‚àí"}${fmt(Math.abs(r))} Renown`);
  }

  if(gloryChange !== 0){
    const g = gloryChange;
    lines.push(`${g > 0 ? "+" : "‚àí"}${fmt(Math.abs(g))} Glory`);
  }

  {
    const d = denChange;
    const denLabel = `${d >= 0 ? "+" : "‚àí"}${fmt(Math.abs(d))} Denarii`;
    lines.push(denLabel);
  }

  lines.push(`Milites lost: ${fmt(rep.losses || 0)}`);

  body.innerHTML = `
    <div class="battleSummaryBlock">
      ${lines.map(l => `<div class="battleSummaryLine">${l}</div>`).join("")}
    </div>
    <div class="battleSummaryNote">
      ${rep.note || ""}
    </div>
  `;

  overlay.style.display = "flex";
  overlay.classList.add("visible");
}

function closeBattleReport(){
  const overlay = document.getElementById("battleOverlay");
  if(!overlay) return;
  overlay.classList.remove("visible");
  setTimeout(()=>{ overlay.style.display = "none"; }, 220);
}
window.closeBattleReport = closeBattleReport;
window.showBattleReport = showBattleReport;

// --- Battle Simulation (cinematic log before the report) ---
function battleTierFoeLabel(tier){
  if(tier===1) return "Bandit gangs & feuding kin";
  if(tier===2) return "Rival clans & raiders";
  if(tier===3) return "Border levies & warbands";
  if(tier===4) return "Rebellions & allied hosts";
  if(tier===5) return "Lords, veterans & garrisons";
  return "Royal armies & great hosts";
}

function battleFlavorByTier(tier){
  if(tier===1) return { place:["farm edge","stone well","fence line","grazing field"], foe:["brawlers","rustlers","feuding kin","thieves"] };
  if(tier===2) return { place:["clan boundary","ancestral fields","ridge path","cattle track"], foe:["militia","raiders","retainers","clansmen"] };
  if(tier===3) return { place:["river ford","hill pass","border track","seasonal camp"], foe:["warband","spearmen","archers","rival host"] };
  if(tier===4) return { place:["council field","palisade","sacred grove","road junction"], foe:["coalition host","rebels","shield wall","champions"] };
  if(tier===5) return { place:["valley pass","border march","stronghold approach","outer works"], foe:["host","defiant chiefs","veterans","garrison"] };
  return { place:["capital outskirts","campaign road","great plain","breached wall"], foe:["coalition army","claimants","elite guard","rival host"] };
}

function showBattleSimulation(rep, tier){
  const makeAsciiBar = (current, max, width = 12) => {
    if (max <= 0) return "‚ñë".repeat(width);
    const ratio  = max > 0 ? current / max : 0;
    const filled = clamp(Math.round(ratio * width), 0, width);
    const empty  = width - filled;
    return "‚ñà".repeat(filled) + "‚ñë".repeat(empty);
  };

  const overlay      = document.getElementById("battleSimOverlay");
  const title        = document.getElementById("battleSimTitle");
  const enemyNameEl  = document.getElementById("battleSimEnemyName");
  const enemyBarImg  = document.getElementById("battleSimEnemyBarImg");
  const yourBarImg   = document.getElementById("battleSimYourBarImg");
  const enemyBarCount = document.getElementById("enemyBarCount");
  const yourBarCount  = document.getElementById("yourBarCount");
  const enemyStatsEl = document.getElementById("battleSimEnemyStats");
  const yourStatsEl  = document.getElementById("battleSimYourStats");
  const eventsEl     = document.getElementById("battleSimEvents");
  const btnSkip      = document.getElementById("battleSimSkip");
  const btnContinue  = document.getElementById("battleSimContinue");

  if(
    !overlay || !title || !enemyNameEl ||
    !enemyBarImg || !yourBarImg || !enemyStatsEl || !yourStatsEl ||
    !eventsEl || !btnSkip || !btnContinue
  ){
    // Fallback: just show the report
    showBattleReport(rep);
    return;
  }

  title.textContent = rep.label;
  enemyNameEl.textContent = `${fmt(rep.enemies)} enemies`;

  // --- Troop counts ---
  const yourStart   = Math.max(0, rep.beforeWarriors || 0);
  const yourEndRaw  = Math.max(0, rep.afterWarriors  || 0);
  const enemyStart  = Math.max(0, rep.enemies        || 0);

  let yourEnd   = yourEndRaw;
  let enemyEnd  = enemyStart;

  // Battles end when one bar hits zero:
  if(enemyStart <= 0){
    enemyEnd = 0;
  }else if(rep.win){
    enemyEnd = 0;
  }else{
    yourEnd = 0;
  }

  const totalYourLoss  = Math.max(0, yourStart  - yourEnd);
  const totalEnemyLoss = Math.max(0, enemyStart - enemyEnd);

  // Small static stats under each bar (final state)
  if(enemyStatsEl){
    enemyStatsEl.textContent =
      `${makeAsciiBar(enemyEnd, enemyStart)}  ${fmt(enemyEnd)} / ${fmt(enemyStart)}`;
  }
  if(yourStatsEl){
    yourStatsEl.textContent =
      `${makeAsciiBar(yourEnd, yourStart)}  ${fmt(yourEnd)} / ${fmt(yourStart)}`;
  }

  // --- Battle log: ultra-short, dopamine-heavy beats (A-style) ---
  const f = battleFlavorByTier(tier);
  const place = f.place[rnd(0, f.place.length - 1)];
  const foe   = f.foe[rnd(0, f.foe.length - 1)];
  const odds  = rep.winP || 0;

  const yourLossPct  = Math.round(100 * (rep.losses       / Math.max(1, yourStart   || 1)));
  const youMax       = Math.max(1, yourStart || 0);
  const enemyMax     = Math.max(1, enemyStart || 0);
  const strengthRatio = youMax / enemyMax;

  const close     = odds > 0.40 && odds < 0.70;
  const desperate = odds <= 0.40;

  const lines = [];
  const pushEntry = (text, tone = "") => {
    lines.push({ text, tone });
  };

  // 1) CLASH ‚Äî instant context + light tension
  pushEntry(
    `‚öî Clash ‚Äî your ${fmt(yourStart)} milites hit ${fmt(enemyStart)} ${foe} at the ${place}.`,
    "warn"
  );

  // 2) TURN ‚Äî one big swing, no micro spam
  if(rep.win){
    if(desperate){
      pushEntry("üî• Break ‚Äî underdogs hold, then roll their front back.", "good");
    }else if(close){
      pushEntry("üî• Break ‚Äî a flank push opens a gap and flips momentum.", "good");
    }else if(strengthRatio >= 1.4){
      pushEntry("üî• Smash ‚Äî your weight slams straight through their centre.", "good");
    }else{
      pushEntry("üî• Push ‚Äî your shieldwall grinds them away from the village.", "good");
    }
  }else{
    if(desperate){
      pushEntry("üí• Collapse ‚Äî numbers wash over you; pockets fight on alone.", "bad");
    }else if(close){
      pushEntry("üí• Slip ‚Äî a small break on the flank snowballs into a rout.", "bad");
    }else{
      pushEntry("üí• Overrun ‚Äî their line walks yours backwards, step by step.", "bad");
    }
  }

  // 3) PAYOFF ‚Äî single summary line (rewards + losses)
  const denChange  = rep.denDelta  || 0;
  const landChange = rep.landDelta || 0;

  const parts = [];
  if(denChange !== 0){
    parts.push(`${denChange > 0 ? "+" : "‚àí"}${fmt(Math.abs(denChange))}d`);
  }
  if(landChange !== 0){
    parts.push(`${landChange > 0 ? "+" : "‚àí"}${fmt(Math.abs(landChange))} land`);
  }
  if(rep.losses > 0){
    const lossBand =
      yourLossPct <= 6  ? "light losses" :
      yourLossPct <= 18 ? "steady losses" :
      "heavy losses";
    parts.push(`${fmt(rep.losses)} lost (${lossBand})`);
  }else{
    parts.push("no losses");
  }

  const summary = parts.join(" ‚Ä¢ ") || "no spoils";

  if(rep.win){
    pushEntry(`üèÜ Victory ‚Äî enemy scatters. ${summary}.`, "good");
  }else{
    pushEntry(`‚ò† Defeat ‚Äî you fall back. ${summary}.`, "bad");
  }

  // --- Health-bar-friendly step curve ---
  const STEPS = 12; // bar story: clash -> swing -> collapse
  const yourSteps  = [];
  const enemySteps = [];

  for(let i = 0; i <= STEPS; i++){
    const t = STEPS > 0 ? (i / STEPS) : 1;
    const ys = Math.round(yourStart  - totalYourLoss  * t);
    const es = Math.round(enemyStart - totalEnemyLoss * t);
    yourSteps.push(ys);
    enemySteps.push(es);
  }

  // Indices where text lines should appear (synced to bar drama)
  const clashStep = 1;
  const breakStep = Math.round(STEPS * 0.5);
  const endStep   = STEPS;

  const barIndexFromCounts = (current, max)=>{
    if(max <= 0) return 0;
    const ratio = clamp(current / max, 0, 1);
    const curved = Math.pow(ratio, 1.25);
    const idx = Math.round(curved * 10);
    return clamp(idx, 0, 10);
  };

  const barSpritePath = (side, idx)=>{
    const base = "Sprites/player and enemy bars/";
    if(side === "player"){
      if(idx <= 0) return base + "Player bar depleted.png";
      if(idx >= 10) return base + "Player bar full.png";
      return base + `Player bar ${idx} out 10.png`;
    }else{
      if(idx <= 0) return base + "enemy bar depleted.png";
      if(idx >= 10) return base + "enemy bar full.png";
      return base + `enemy bar ${idx} out 10.png`;
    }
  };

  let lastYourCount  = yourStart;
  let lastEnemyCount = enemyStart;

  const triggerBarShake = (imgEl)=>{
    if(!imgEl) return;
    const wrapper = imgEl.closest(".battleBar");
    if(!wrapper) return;
    wrapper.classList.remove("barShake");
    void wrapper.offsetWidth;
    wrapper.classList.add("barShake");
  };

  const applyStep = (stepIndex)=>{
    // Clamp into range 0..STEPS
    const i = clamp(stepIndex, 0, STEPS);
    const yNow = yourSteps[i];
    const eNow = enemySteps[i];

    const tookY = yNow < lastYourCount;
    const tookE = eNow < lastEnemyCount;
    if(tookY) triggerBarShake(yourBarImg);
    if(tookE) triggerBarShake(enemyBarImg);
    lastYourCount  = yNow;
    lastEnemyCount = eNow;

    const yourIdx  = barIndexFromCounts(yNow, yourStart);
    const enemyIdx = barIndexFromCounts(eNow, enemyStart);

    if(yourBarImg)  yourBarImg.src  = barSpritePath("player", yourIdx);
    if(enemyBarImg) enemyBarImg.src = barSpritePath("enemy", enemyIdx);

    if(enemyBarCount) enemyBarCount.textContent = `${fmt(eNow)} / ${fmt(enemyStart)}`;
    if(yourBarCount)  yourBarCount.textContent  = `${fmt(yNow)} / ${fmt(yourStart)}`;
  };

  // Log rendering helper
  const MAX_VISIBLE_LINES = 4;

  const appendLine = (entry)=>{
    if(!entry) return;
    const div = document.createElement("div");
    div.className = "simEventLine";

    if(entry && typeof entry === "object"){
      div.textContent = entry.text || "";
      if(entry.tone === "good" || entry.tone === "bad" || entry.tone === "warn"){
        div.classList.add(entry.tone);
      }
    }else{
      div.textContent = entry;
    }

    eventsEl.appendChild(div);

    while(eventsEl.children.length > MAX_VISIBLE_LINES){
      eventsEl.removeChild(eventsEl.firstChild);
    }
  };

  // Initial visual state
  eventsEl.innerHTML = "";
  btnContinue.style.display = "none";
  applyStep(0);

  overlay.style.display = "flex";
  overlay.classList.add("visible");

  let stepIndex = 0;
  let timer = null;
  let nextLineIdx = 0;

  const TICK_MS = 550; // overall battle length ~ 6‚Äì7s

  const tick = ()=>{
    if(stepIndex >= STEPS){
      // ensure final frame
      applyStep(STEPS);
      if(timer){ clearInterval(timer); timer = null; }
      btnContinue.style.display = "inline-flex";
      return;
    }

    stepIndex = Math.min(stepIndex + 1, STEPS);
    applyStep(stepIndex);

    // Trigger log lines on key bar moments
    if(stepIndex === clashStep && nextLineIdx < lines.length){
      appendLine(lines[nextLineIdx++]);
    }
    if(stepIndex === breakStep && nextLineIdx < lines.length){
      appendLine(lines[nextLineIdx++]);
    }
    if(stepIndex === endStep && nextLineIdx < lines.length){
      appendLine(lines[nextLineIdx++]);
    }
  };

  timer = setInterval(tick, TICK_MS);
  // Prime first tick so there's no initial delay
  tick();

  const finish = ()=>{
    overlay.classList.remove("visible");
    if(timer){ clearInterval(timer); timer = null; }
    setTimeout(()=>{ overlay.style.display = "none"; }, 220);
  };

  btnSkip.onclick = ()=>{
    finish();
    showBattleReport(rep);
    if(rep && rep.isIntro){
      toast("This is how legends are born.");
      logLine("First defence of the village: this is where your legend begins.", "good");
      if(typeof scheduleSave === "function") scheduleSave();
    }
  };

  btnContinue.onclick = ()=>{
    finish();
    showBattleReport(rep);
    if(rep && rep.isIntro){
      toast("This is how legends are born.");
      logLine("First defence of the village: this is where your legend begins.", "good");
      if(typeof scheduleSave === "function") scheduleSave();
    }
  };
}function startIntroBattle(){
  if(S.introBattleDone) return;
  S.introBattleDone = 1;

  // Remember pre-intro forces so the visiting warband can leave afterwards
  const prevWarriors = S.warriors || 0;
  const prevPopulation = S.population || 0;

  // Ensure a small visiting warband so the battle feels real
  let warriors = S.warriors || 0;
  let population = S.population || 0;
  if(warriors < 12){
    const add = 12 - warriors;
    warriors += add;
    population += add;
  }
  S.warriors = warriors;
  S.population = population;
  S.populationUsed = (S.warriors||0) + (S.cavalry||0);

  // Use the new battleSim to decide how bloody the intro feels,
  // but always treat it as a hard-won victory in the story.
  const beforeWarriors = S.warriors || 0;
  const introSlot = 0; // first battle tier (usually bandits)
  const sim = battleSim(introSlot);

  // Derive casualties from the sim, but clamp to a "narrow win" band.
  let simLosses = sim && typeof sim.losses === "number" ? sim.losses : Math.round(beforeWarriors * 0.35);
  const minLoss = Math.max(1, Math.round(beforeWarriors * 0.22));
  const maxLoss = Math.max(minLoss, Math.round(beforeWarriors * 0.55));
  const losses = clamp(simLosses, minLoss, maxLoss);

  const afterWarriorsIntro = Math.max(0, beforeWarriors - losses);

  // Enemy numbers from the sim, or a fallback
  const enemies = sim && typeof sim.enemies === "number"
    ? sim.enemies
    : beforeWarriors + rnd(4, 10);

  // Modest early reward so the opener feels impactful
  const denGain = 16;
  const landGain = 0; // Tutorial battle: no land granted
  const renGain = 4;

  S.gold += denGain;
  S.lifetimeGold += denGain;
  // Do NOT grant land for the intro battle ‚Äì rewards are denarii + renown only.
  S.renown = (S.renown || 0) + renGain;
  S.lifetimeRenown = (S.lifetimeRenown || 0) + renGain;

  const rep = {
    label: "First Defence of the Village",
    enemies,
    // Show whatever odds the sim estimated, but the story always counts this as a win.
    winP: sim && typeof sim.winP === "number" ? sim.winP : 0.56,
    win: true,
    beforeWarriors,
    afterWarriors: afterWarriorsIntro,
    losses,
    denDelta: denGain,
    landDelta: landGain,
    renDelta: renGain,
    landSlots: 0,
    territoryNames: [],
    note: "You hold the field when it should have broken.",
    isIntro: true
  };

  // The visiting warband that saved you marches on; you're left as you were before,
  // with only the scars and spoils to show for it.
  S.warriors = prevWarriors;
  S.population = prevPopulation;
  S.populationUsed = (S.warriors||0) + (S.cavalry||0);

  const introLines = [
    "Battle Victory!",
    "Captured: (tutorial ‚Äì no new land)",
    `+${fmt(renGain)} Renown`,
    `+${fmt(denGain)} Denarii`,
    `Milites lost: ${fmt(losses)}`
  ];

  logLine(introLines.join("\n"), "good");
  logLine("The warband that saved your village marches on, leaving you to build your own legion.", "warn");
  toast("The village stands. Barely.");
  showBattleSimulation(rep, 1);
  render();
  if(typeof scheduleSave === "function") scheduleSave();
}

window.startIntroBattle = startIntroBattle;

// --- Battle execution (rank-based) ---
// Optional second arg opts: { defence: true } for pop-up defence battles
function doBattle(slot, opts){
  opts = opts || {};
  const isDefence = !!opts.defence;

  const now = Date.now(); // cooldown disabled
  const b = currentBattleSet()[slot];
  if(!b){ toast("No battle available"); return; }

  // Minimal requirement: you need at least *some* milites for offensive campaigns.
  const w = (S.warriors || 0);
  if (!isDefence && w <= 0) {
    toast("You have no milites to muster.");
    return;
  }

  const sim = battleSim(slot);

  // Allow tactical mode to override win/loss and casualty counts.
  if (opts && typeof opts.overrideLoss === 'number') {
    sim.losses = opts.overrideLoss;
  }
  if (opts && typeof opts.overrideWin === 'boolean') {
    sim.win = opts.overrideWin;
  }
  const beforeWarriors = S.warriors||0;
  const startGold = S.gold;
  const startLand = S.land||0;
  const startRenown = S.renown||0;
  const startGlory = S.glory || 0;

  // Soft warning: under-strength force vs enemy numbers / odds (no hard gate)
  if (!isDefence && sim && typeof sim.enemies === "number") {
    const enemies = sim.enemies;
    const winP = typeof sim.winP === "number" ? sim.winP : 0.5;

    // ‚ÄúRecommended‚Äù force: ~40% of enemy count
    const recommended = Math.max(1, Math.round(enemies * 0.4));

    if (beforeWarriors > 0 && beforeWarriors < recommended && winP < 0.75) {
      toast("Very risky with so few milites ‚Äî expect heavy losses.");
    }
  }

  // Apply casualties
  let losses = Math.min(beforeWarriors, sim.losses);
  S.warriors = Math.max(0, beforeWarriors - losses);

  // Deaths remove population permanently.
  S.population = Math.max(0, (S.population||0) - losses);

  // Special case: if you would be left with exactly 1 milite,
  // treat this as your last soldier falling and apply a harsher consequence.
  if(S.warriors === 1){
    // That last milite is lost.
    S.warriors = 0;
    losses += 1;

    // More people drift away or are lost around the defeat.
    const popBefore = (S.population||0);
    const extraPopLoss = Math.min(popBefore, 1 + Math.round(popBefore * 0.05));
    S.population = Math.max(0, popBefore - extraPopLoss);

    // A portion of your denarii is stripped away in the chaos.
    const goldBefore = (S.gold||0);
    const extraGoldLoss = Math.round(goldBefore * 0.1);
    S.gold = Math.max(0, goldBefore - extraGoldLoss);
  }

  // Keep pop-used in sync with milites
  if((S.population||0) < (S.warriors||0)){
    // Safety clamp (shouldn't happen, but protects old saves)
    S.warriors = S.population;
  }
  S.populationUsed = (S.warriors||0) + (S.cavalry||0);

  recalcLegionStrength();

  // Loot / penalties
  let loot = 0;
  let landGain = 0;
  let capturedNames = [];
  let landSlotsGain = 0;

  if(sim.win){
    // Retire this enemy context so a new named foe can appear next time at this slot.
    if (S.battleContexts && sim && typeof sim.tier === "number") {
      const key = sim.tier + ":" + slot;
      delete S.battleContexts[key];
    }
    S.battlesWon = (S.battlesWon||0) + 1;

    const tier = sim.tier;
    const enemies = sim.enemies;
    const winP = sim.winP;

    // Base loot is now mostly driven by how many enemies you defeat,
    // with per‚Äëbattle noise so some groups carry fatter purses than others.
    const basePerEnemy = 6 + tier * 2.5; // 8.5‚Äì18.5 denarii per enemy (before modifiers)
    const perEnemyNoise = 0.8 + Math.random() * 0.8; // 0.8x‚Äì1.6x variation per battle
    let baseLoot = enemies * basePerEnemy * perEnemyNoise;

    // Risk bonus: riskier fights (lower winP) pay more
    const riskBonus = 0.9 + (1 - winP) * 1.6; // 0.9x at 100% win, up to ~2.5x at very risky

    // Slight extra for higher tiers so late-game fights feel chunky
    const tierBonus = 1 + Math.max(0, tier - 1) * 0.18;

    // Treasure caravans (from battleSim) further swing the payout.
    const treasureLootMult = sim.treasureLootMult || 1;

    loot = Math.round(baseLoot * riskBonus * tierBonus * treasureLootMult);

    if(isDefence){
      // --- DEFENSIVE BATTLE REWARD (no land, safer fantasy) ---
      loot = Math.max(5, Math.round(loot * 0.55));
      S.gold += loot;
      S.lifetimeGold += loot;
      bumpEarnedDenarii(loot);

      // Moderate renown for holding the line (slightly higher now)
      let renGain = Math.max(1, Math.round(enemies / 12) + tier * 3);
      renGain = Math.round(renGain * landAllocRenownMult());
      S.renown += renGain;
      S.lifetimeRenown += renGain;

      // Glory: trophies of war for defensive stands.
      let gloryGain = Math.max(1, Math.round(enemies / 18) + tier);
      // Losses and land allocation (Military) make defence more renowned.
      gloryGain += Math.round(losses / 80);
      gloryGain = Math.max(1, Math.round(gloryGain * landAllocLegionMult()));
      S.glory = (S.glory || 0) + gloryGain;
      S.lifetimeGlory = (S.lifetimeGlory || 0) + gloryGain;

bumpObjective("winBattle", 1);
      maybeBurst("battle");

      toast("Village defended!");

      const yourLossPct = Math.round(100 * losses / Math.max(1, beforeWarriors || 1));
      let winTag;
      if(yourLossPct <= 6)       winTag = "Clean defence";
      else if(yourLossPct <= 18) winTag = "Hard defence";
      else                       winTag = "Pyrrhic defence";

      const lines = [];
      lines.push("Defence Successful!");
      lines.push(`‚Ä¢ ${b.label}`);
      lines.push("");

      if (sim.treasureType && sim.treasureType !== "normal") {
        let tLabel = "";
        if (sim.treasureType === "fat")      tLabel = "Treasure: Fat purses";
        else if (sim.treasureType === "rich")    tLabel = "Treasure: Rich caravan";
        else if (sim.treasureType === "jackpot") tLabel = "Treasure: Jackpot hoard";
        if (tLabel) lines.push(tLabel);
      }

      lines.push(`+${fmt(renGain)} Renown`);
      lines.push(`+${fmt(loot)} Denarii`);
      lines.push(`Milites lost: ${fmt(losses)} (${winTag})`);

      logLine(lines.join("\n"), "good");
    } else {
      // --- OFFENSIVE CAMPAIGN REWARD (normal land-granting battles) ---
      S.gold += loot;
      S.lifetimeGold += loot;
      bumpEarnedDenarii(loot);

      // Land gain: only from territorial battles (field actions, sieges, and some high-tier feuds)
      let baseLand = enemies / (42 - tier * 3); // generous at high tiers
      if(winP < 0.45) baseLand *= 1.35; // reward gutsy wins

      // Raw land from fight size (may be zeroed by archetype rules)
      let rawLand = Math.floor(Math.max(0, baseLand));
      rawLand = clamp(rawLand, 0, 10 + tier * 2);

      let territorial = 0;

      // Archetype-based land rules
      const arch = battleArchetypeFor(tier, slot);
      const kind = arch && arch.kind ? arch.kind : "";

      if(kind === "skirmish"){
        // Slot 1 / pressure: never land, just momentum and loot
        territorial = 0;
      }else if(kind === "feud"){
        // Feuds sometimes displace rivals at higher tiers
        if(tier >= 3 && Math.random() < 0.45){
          territorial = Math.max(1, rawLand || 1);
        }else{
          territorial = 0;
        }
      }else if(kind === "field"){
        // Territorial field actions: always at least 1 land on win
        territorial = Math.max(1, rawLand || 1);
      }else if(kind === "siege"){
        // Sieges / major control changes: heavier land swing
        territorial = Math.max(2, rawLand || 2);
      }else{
        // Fallback: behave like a cautious territorial battle
        territorial = Math.max(1, rawLand || 1);
      }

      landGain = territorial;

      if(landGain > 0){
        S.land = (S.land||0) + landGain;

        // capture named territories (1 per land gained)
        const newTerritories = [];
        for(let i=0;i<landGain;i++){
          const t = captureTerritory(tier);
          if(t) newTerritories.push(t);
        }
        capturedNames = newTerritories.map(t=>t.name);

        // Compute land-effect "slots" from land type system (pop contribution)
        landSlotsGain = 0;
        for(const terr of newTerritories){
          const eff = LAND_TYPE_EFFECTS && LAND_TYPE_EFFECTS[terr.name];
          if(eff && eff.pop) landSlotsGain += eff.pop;
        }
      } else {
        landSlotsGain = 0;
        capturedNames = [];
      }

      // Renown from big wins (buffed so progression feels faster)
      let renGain = Math.max(1, Math.round(loot/90) + Math.round(landGain*3) + tier*4);
      renGain = Math.round(renGain * landAllocRenownMult());
      S.renown += renGain;
      S.lifetimeRenown += renGain;

      // Glory: trophies from major victories.
      // Scales with enemies destroyed, land seized and battle tier.
      let gloryGain = Math.max(1,
        Math.round(loot / 120) +
        Math.round(landGain * 4) +
        Math.round(enemies / 20) +
        tier * 2
      );
      gloryGain = Math.max(1, Math.round(gloryGain * landAllocLegionMult()));
      S.glory = (S.glory || 0) + gloryGain;
      S.lifetimeGlory = (S.lifetimeGlory || 0) + gloryGain;

      bumpObjective("winBattle", 1);
      const objLandGain = landGain > 0 ? landGain : (sim.win ? 1 : 0);
      bumpObjective("gainLand", objLandGain);

      maybeBurst("battle");

      // Political capital: victories generate influence with your realm.
      const infGain = Math.max(1, Math.round(1 + sim.tier * 0.8 + landGain * 0.4));
      
      toast("Victory!");

      const yourLossPct = Math.round(100 * losses / Math.max(1, beforeWarriors || 1));
      let winTag;
      if(yourLossPct <= 6)       winTag = "Clean win";
      else if(yourLossPct <= 18) winTag = "Hard win";
      else                       winTag = "Pyrrhic win";

      const lines = [];
      lines.push("Battle Victory!");

      if(landGain > 0 && capturedNames.length){
        lines.push("Captured:");
        const counts = {};
        for(const name of capturedNames){
          counts[name] = (counts[name]||0) + 1;
        }
        Object.entries(counts).sort((a,b)=>a[0].localeCompare(b[0])).forEach(([name,count])=>{
          lines.push(`‚Ä¢ ${name} √ó${fmt(count)}`);
        });
      }else{
        lines.push("Captured: No new land");
      }

      if (sim.treasureType && sim.treasureType !== "normal") {
        let tLabel = "";
        if (sim.treasureType === "fat")      tLabel = "Treasure: Fat purses";
        else if (sim.treasureType === "rich")    tLabel = "Treasure: Rich caravan";
        else if (sim.treasureType === "jackpot") tLabel = "Treasure: Jackpot hoard";
        if (tLabel) lines.push(tLabel);
      }

      lines.push(`+${fmt(S.renown - startRenown)} Renown`);
      lines.push(`+${fmt(loot)} Denarii`);
      lines.push(`Milites lost: ${fmt(losses)} (${winTag})`);

      logLine(lines.join("\n"), "good");
    }
  }else{
    // Defeat path (same for both defence & offence ‚Äì flavour already good)
    const tier = sim.tier;
    const enemies = sim.enemies;

    // You lose some denarii and power, proportional to fight size.
    const lost = Math.round((enemies * (3 + tier*1.1)) * 0.4);
    S.gold = Math.max(0, (S.gold||0) - lost);

    toast(isDefence ? "Defence lost" : "Defeat");

    const yourLossPct = Math.round(100 * losses / Math.max(1, beforeWarriors || 1));
    let lossTag;
    if(yourLossPct <= 12)      lossTag = isDefence ? "Breach at the edge" : "Setback";
    else if(yourLossPct <= 28) lossTag = "Bloody loss";
    else                       lossTag = "Crushing loss";

    logLine(
      `‚ò† ${b.label} ‚Äî ${lossTag}. -${fmt(lost)}d ‚Ä¢ -${fmt(losses)} milites`,
      "bad"
    );
  }

  // --- Legion morale & veterancy (hidden) ---
  const baseBefore = beforeWarriors || 0;
  const lossFracForMorale = baseBefore > 0 ? losses / baseBefore : 0;
  const fightSize = sim.enemies || 0;

  // Veterancy: bigger / harder fights teach more, even on losses
  let xpGain = 0;
  if(fightSize > 0){
    xpGain = Math.round(fightSize * (sim.win ? 0.7 : 0.45) * (1 + (sim.tier||1) * 0.22));
    if(lossFracForMorale > 0.6) xpGain = Math.round(xpGain * 1.15);
    if(xpGain < 1) xpGain = 1;
  }
  if(xpGain > 0){
    S.legionXp = (S.legionXp || 0) + xpGain;
  }

  let moraleVal = typeof S.legionMorale === "number" ? S.legionMorale : 1;
  if(sim.win){
    const gain = 0.10 + (1 - lossFracForMorale) * 0.25;
    moraleVal += gain;
  }else{
    const drop = 0.18 + lossFracForMorale * 0.5;
    moraleVal -= drop;
  }
  // Gentle pull back toward neutral over time
  moraleVal += (1 - moraleVal) * 0.08;
  S.legionMorale = clamp(moraleVal, 0.4, 2.2);

  // Soft flavour log so battles feel like they change the warband
  if(fightSize > 0 && xpGain > 0){
    if(sim.win){
      logLine("Your milites return more seasoned from the fighting.", "good");
    }else{
      logLine("Survivors carry hard lessons back to the village.", "warn");
    }
  }


  const rep = {
    label: b.label,
    enemies: sim.enemies,
    winP: sim.winP,
    win: sim.win,
    beforeWarriors,
    afterWarriors: S.warriors||0,
    losses,
    denDelta: Math.round(S.gold - startGold),
    loot: loot || 0,
    treasureType: (sim && sim.treasureType) ? sim.treasureType : "normal",
    treasureLootMult: (sim && typeof sim.treasureLootMult === "number") ? sim.treasureLootMult : 1,

    landDelta: Math.round((S.land||0) - startLand),
    renDelta: Math.round((S.renown||0) - startRenown),
    gloryDelta: Math.round((S.glory||0) - startGlory),
    landSlots: sim.win ? landSlotsGain : 0,
    territoryNames: sim.win ? (capturedNames || []) : [],
    note: sim.win
      ? (isDefence ? "You hold the fields around your village." : "You held the field and counted the fallen.")
      : "You retreat to lick your wounds."
  };

  // Show battle results.  If suppressSim flag is set (e.g. tactical battles), skip the cinematic sim and go straight to the report.
  if (opts && opts.suppressSim) {
    showBattleReport(rep);
    render();
  } else {
    showBattleSimulation(rep, sim.tier);
    render();
  }
  return rep;
}
// Battle buttons
// For offensive battles the player can choose to command tactically.  This will launch the tactical overlay rather than immediately resolving.
$("#btnBattleBandits1").addEventListener("click", ()=> startTacticalBattle(0));
$("#btnBattleLevy").addEventListener("click", ()=> startTacticalBattle(1));
$("#btnBattleVillageRaid").addEventListener("click", ()=> startTacticalBattle(2));
$("#btnBattleSiege").addEventListener("click", ()=> startTacticalBattle(3));



// Castrum Victoriae (Glory shop)

  const gloryOverlay = $("#gloryOverlay");
  const btnOpenCastrum = $("#btnOpenCastrum");
  const btnGloryClose = $("#gloryCloseBtn");

  if(btnOpenCastrum && gloryOverlay){
    btnOpenCastrum.addEventListener("click", ()=>{
      const gloryNow = S.glory || 0;
      const el = $("#gloryOverlayNow");
      if(el) el.textContent = fmt(gloryNow);
      const ownedAuxEl = $("#ownedAux");
      if(ownedAuxEl) ownedAuxEl.textContent = fmt(S.auxilia || 0);
      const ownedEqEl = $("#ownedEquites");
      if(ownedEqEl) ownedEqEl.textContent = fmt(S.equites || 0);
      const ownedVetEl = $("#ownedVets");
      if(ownedVetEl) ownedVetEl.textContent = fmt(S.veterans || 0);
      gloryOverlay.removeAttribute("hidden");
      gloryOverlay.classList.add("visible");
    });
  }

  if(btnGloryClose && gloryOverlay){
    btnGloryClose.addEventListener("click", ()=>{
      gloryOverlay.classList.remove("visible");
      gloryOverlay.setAttribute("hidden", "hidden");
    });
  }

  const gloryCost = (kind)=>{
    if(kind === "aux") return 40;
    if(kind === "equites") return 70;
    if(kind === "vets") return 120;
    return 0;
  };
  const addSpecialForces = (kind, count=1)=>{
    if(kind === "aux")      S.auxilia = (S.auxilia || 0) + count;
    else if(kind === "equites") S.equites = (S.equites || 0) + count;
    else if(kind === "vets")    S.veterans = (S.veterans || 0) + count;
  };

  $("#btnBuyAuxilia").addEventListener("click", ()=>{
    const cost = gloryCost("aux");
    if((S.glory || 0) < cost){
      toast("Not enough glory");
      return;
    }
    S.glory -= cost;
    addSpecialForces("aux", 1);
    toast("Auxilia spearmen join your banners.");
    logLine("Auxilia spearmen recruited at Castrum Victoriae.", "good");
    render();
  });

  $("#btnBuyEquites").addEventListener("click", ()=>{
    const cost = gloryCost("equites");
    if((S.glory || 0) < cost){
      toast("Not enough glory");
      return;
    }
    S.glory -= cost;
    addSpecialForces("equites", 1);
    toast("Equites ride under your standard.");
    logLine("Equites (cavalry) recruited at Castrum Victoriae.", "good");
    render();
  });

  $("#btnBuyVeterans").addEventListener("click", ()=>{
    const cost = gloryCost("vets");
    if((S.glory || 0) < cost){
      toast("Not enough glory");
      return;
    }
    S.glory -= cost;
    addSpecialForces("vets", 1);
    toast("A hardened veteran cohort swears loyalty to you.");
    logLine("Veteran cohort recruited at Castrum Victoriae.", "good");
    render();
  });

// Skirmish: optional combat later (tiny screen footprint)

  $("#btnOffer").addEventListener("click", ()=>{
    const c = offerCost();
    if(S.gold < c){ toast("Not enough denarii"); return; }
    S.gold -= c;
    const f = offerFaithGain();
    S.faith += f;
    // Renown is now battle-only; offerings no longer grant renown.

    // Temple objective
    bumpObjective("offerFaith", 1);

    toast("Blessed");
    render();
  });

  $("#btnBless").addEventListener("click", ()=>{
    const now = Date.now();
    if(now < S.blessReadyAt){ toast("Cooling down"); return; }
    S.blessReadyAt = now + blessCooldownMs();
    S.buffUntil = now + blessDurationMs();
    toast("Blessing!");
    render();
  });

  $("#btnAscend").addEventListener("click", ()=>{
    const gain = ascendCrownGain();
    if(gain <= 0){ toast("Need 8,000 renown"); return; }
    if(!confirm(`Ascend for +${gain} crowns? (Resets most progress)`)) return;

    const keepCrowns = (S.crowns || 0) + gain;
    const keepLifetimeGold = S.lifetimeGold || 0;
    const keepLifetimeRenown = S.lifetimeRenown || 0;
    const nextAscends = (S.ascends || 0) + 1;

    S = defaultState();
    S.crowns = keepCrowns;
    S.lifetimeGold = keepLifetimeGold;
    S.lifetimeRenown = keepLifetimeRenown;
    S.ascends = nextAscends;

    $("#log").innerHTML = "";
    logLine(`You ascend. Crowns: ${fmt(S.crowns)}. (Ascensions: ${S.ascends})`, "warn");
    toast("Ascended");
    save(true);
    setView("village");
  });

    $("#btnCashout").addEventListener("click", (e)=>{
    if(!cashoutReady()){ toast("Not ready"); return; }

    const payout = cashoutPotential();
    if(payout <= 0){ toast("No bonus"); return; }

    S.gold += payout;
    S.lifetimeGold += payout;
    bumpEarnedDenarii(payout);

    // Track biggest single cashout across all runs
    if(!S.biggestCashout || payout > S.biggestCashout){
      S.biggestCashout = payout;
    }

    // Cashing out resets streak: this is the decision point.
    S.streak = 1;
    S.lastTap = Date.now();

    // Short cooldown so players can't spam-cash at low streaks.
    S.cashoutCooldownUntil = Date.now() + CASHOUT_COOLDOWN_MS;

    const rect = e.currentTarget.getBoundingClientRect();
    sparkAt(rect.left + rect.width*0.55, rect.top + rect.height*0.55);

    // Cashout burst chance
    maybeBurst("cashout");

    toast("Cashed out!");
    logLine(`Cashed out for +${fmt(payout)} denarii`, "good");
    bumpObjective("cashout", 1);

    render();
  });

$("#btnExport").addEventListener("click", async ()=>{
    try{
      await navigator.clipboard.writeText(JSON.stringify(S));
      toast("Copied");
    }catch(e){
      toast("Clipboard blocked");
    }
  });

  $("#btnReset").addEventListener("click", ()=>{
    // Flavour confirm for New Game
    const msg = "Abandon your realm and begin anew?\nYour lands, wealth, and renown will be lost.";
    if(!confirm(msg)) return;

    // Wipe local save (best-effort)
    try{
      localStorage.removeItem(STORAGE_KEY);
    }catch(e){}

    // Fresh state: back to the very beginning
    S = defaultState();

    // Make absolutely sure intro is considered not done
    S.playerName = "";
    S.introBattleDone = 0;

    // Clear recent events log
    const logEl = $("#log");
    if(logEl) logEl.innerHTML = "";

    // Re-render base UI
    render();

    // Show the intro name screen again
    if(typeof maybeShowIntro === "function"){
      maybeShowIntro();
    }

    // Nice little flavour toast
    toast("A new story begins.");
  });


  const offlineOk = document.getElementById("offlineOkBtn");
  if(offlineOk && !offlineOk._wired){
    offlineOk._wired = true;
    offlineOk.addEventListener("click", ()=>{
      const overlay = document.getElementById("offlineOverlay");
      if(overlay){
        overlay.classList.remove("visible");
        overlay.setAttribute("hidden","hidden");
      }
    });
  }


  // Melvor-like PWA lifecycle handling (iOS/Android Home Screen):
  // - iOS often *suspends* instead of reloading, so we must record lastSeenAt on background
  //   and apply offline progress on resume.
  function stampLastSeenAndSave(){
    try{
      S.lastSeenAt = Date.now();
      save(true);
    }catch(e){}
  }

  let _offlineResumeArmed = false;
  document.addEventListener("visibilitychange", ()=>{
    // When going to background, stamp time.
    if(document.visibilityState === "hidden"){
      _offlineResumeArmed = true;
      stampLastSeenAndSave();
      return;
    }
    // When returning, apply offline if we were actually backgrounded.
    if(document.visibilityState === "visible" && _offlineResumeArmed){
      _offlineResumeArmed = false;
      try{ applyOfflineProgress(); }catch(e){ console && console.warn && console.warn("Offline progress failed", e); }
      render();
    }
  }, {passive:true});

  // Some iOS/PWA flows fire pagehide without visibilitychange.
  window.addEventListener("pagehide", ()=>{
    _offlineResumeArmed = true;
    stampLastSeenAndSave();
  }, {passive:true});

  // Tabs click
  $$(".tab").forEach(btn=>{
    btn.addEventListener("click", ()=> setView(btn.dataset.go));
  });

  // Passive tick (keeps progression going)
  let last = Date.now();
  setInterval(()=>{
    const now = Date.now();
    const dt = (now - last)/1000;
    last = now;

    // Passive income
    const inc = incomePerSec() * dt;
    if(inc > 0){
      S.gold += inc;
      S.lifetimeGold += inc;
    }

    // Objectives: passive income counts toward "Earn denarii"
    if(inc > 0) bumpEarnedDenarii(inc);

    // Passive renown: as your wealth, land, villas and population grow,
    // word of your rule spreads slowly even while you are not tapping.
    if(inc > 0){
      const pop   = S.population || 0;
      const terr  = (S.controlledRegions && S.controlledRegions.length) || 0;
      const villas = S.villaCount || 0;

      // Base chance scales with income and realm size.
      let p = 0;
      p += inc / 25000;
      p += terr * 0.0025;
      p += villas * 0.003;
      p += pop * 0.0004;

      // Soft damping as renown grows, so late-game doesn't explode.
      const ren = S.renown || 0;
      if(ren > 0){
        p = p / (1 + ren / 8000);
      }

      // Never more than a moderate chance per tick.
      p = Math.min(0.45, p);

      if(p > 0 && chance(p)){
        let drip = 1;
        if(terr >= 10)  drip += 1;
        if(villas >= 15) drip += 1;
        S.renown += drip;
        S.lifetimeRenown += drip;
      }
    }

    // --- Milites upkeep: ties legion to village economy ---
    const upkeep = warriorUpkeepPerSec() * dt;
    if(upkeep > 0){
      const nowMs = Date.now();

      if(S.gold >= upkeep){
        // You can afford your forces: just pay.
        S.gold -= upkeep;

        // Gentle warning if upkeep is eating most of your income.
        const incomeNow = incomePerSec();
        if(
          incomeNow > 0 &&
          upkeep > incomeNow * 0.65 &&
          nowMs - (S.lastUpkeepWarnAt || 0) > 10000
        ){
          toast("Your milites are expensive ‚Äî build more farms and villas.");
          S.lastUpkeepWarnAt = nowMs;
        }
      }else{
        // Can't fully pay upkeep: you go broke and desertions start.
        const paid = S.gold;
        S.gold = 0;

        S.unpaidUpkeepSeconds = (S.unpaidUpkeepSeconds || 0) + dt;

        // Every few seconds of unpaid wages, some milites desert.
        if(S.unpaidUpkeepSeconds >= 6 && (S.warriors || 0) > 0){
          S.unpaidUpkeepSeconds -= 6;

          const before = S.warriors || 0;
          const lose = Math.max(1, Math.round(before * 0.06)); // ~6% desert
          S.warriors = Math.max(0, before - lose);

          // They leave the population as well (either gone or dead).
          S.population = Math.max(0, (S.population || 0) - lose);
          S.populationUsed = (S.warriors||0) + (S.cavalry||0);

          recalcLegionStrength();

          logLine(`${lose} milites deserted ‚Äî you could not pay them.`, "bad");

          if(nowMs - (S.lastUpkeepWarnAt || 0) > 6000){
            toast("Unpaid milites deserted your banner.");
            S.lastUpkeepWarnAt = nowMs;
          }
        }
      }
    }else{
      // No army ‚Üí no unpaid timer.
      S.unpaidUpkeepSeconds = 0;
    }


    // --- Settlers: population slowly fills up to your housing cap ---
    const cap = populationCap();
    if(typeof S.population !== "number") S.population = Math.max(0, S.populationUsed||0, S.warriors||0);
    if(typeof S.settlerProg !== "number") S.settlerProg = 0;

    // "Doing well" = better income + bigger settlement attracts more people.
    // Use the same helper the HUD uses so numbers stay in sync.
    const settleRatePerSec = migrationPerSec();


    if((S.population||0) < cap){
      S.settlerProg += settleRatePerSec * dt;
      const add = Math.floor(S.settlerProg);
      if(add > 0){
        S.settlerProg -= add;
        const before = S.population||0;
        S.population = Math.min(cap, before + add);
        const gained = S.population - before;
        if(gained > 0){
          logLine(`${gained} settler${gained===1?"":"s"} joined your village.`, "good");
          const now = Date.now();
          if(now - (S.lastSettlerToastAt||0) > 4000){
            toast(`üë• +${gained} settler${gained===1?"":"s"}`);
            S.lastSettlerToastAt = now;
          }
        }
      }
    }else{
      // bleed off progress so you don't "bank" settlers while capped
      S.settlerProg = Math.max(0, S.settlerProg - 0.25*dt);
    }

    // Keep pop-used synced with milites, and clamp old saves
    if((S.population||0) < (S.warriors||0)) S.warriors = S.population;
    S.populationUsed = (S.warriors||0) + (S.cavalry||0);


    render();
  }, 650);

  // First paint
  $("#log").innerHTML = "";
  logLine("A small village. A few denarii. A long road to the crown.", "warn");
  render();
  maybeShowIntro();
  
  /*
   * Tactical battle system
   *
   * When the player chooses to lead a battle manually, we open a simple
   * turn-based overlay.  Each round the player selects an action
   * (Assault, Defend, Heal) and the game computes casualties based on
   * relative troop strength and the chosen stance.  At the end of the
   * fight, doBattle() is invoked with override flags to apply the
   * casualties and rewards without showing the old cinematic simulation.
   */
  let currentTactical = null;

  function tacBarIndex(current, max){
    if(max <= 0) return 0;
    const ratio = Math.max(0, Math.min(1, current / max));
    const curved = Math.pow(ratio, 1.25);
    const idx = Math.round(curved * 10);
    return Math.max(0, Math.min(10, idx));
  }
  function tacBarSprite(side, idx){
    const base = "Sprites/player and enemy bars/";
    if(side === "player"){
      if(idx <= 0) return base + "Player bar depleted.png";
      if(idx >= 10) return base + "Player bar full.png";
      return base + `Player bar ${idx} out 10.png`;
    }else{
      if(idx <= 0) return base + "enemy bar depleted.png";
      if(idx >= 10) return base + "enemy bar full.png";
      return base + `enemy bar ${idx} out 10.png`;
    }
  }

  function updateTacticalUI(){
    const s = currentTactical;
    if(!s) return;
    const yourImg  = document.getElementById('tacYourBarImg');
    const enemyImg = document.getElementById('tacEnemyBarImg');
    const yourCnt  = document.getElementById('tacYourBarCount');
    const enemyCnt = document.getElementById('tacEnemyBarCount');
    if(yourImg && enemyImg){
      const idxY = tacBarIndex(s.currentPlayer, s.initPlayer);
      const idxE = tacBarIndex(s.currentEnemy, s.sim.enemies);
      yourImg.src  = tacBarSprite('player', idxY);
      enemyImg.src = tacBarSprite('enemy', idxE);
      if(yourCnt)  yourCnt.textContent  = `${fmt(s.currentPlayer)} / ${fmt(s.initPlayer)}`;
      if(enemyCnt) enemyCnt.textContent = `${fmt(s.currentEnemy)} / ${fmt(s.sim.enemies)}`;
    }
    const eventsEl = document.getElementById('tacEvents');
    if(eventsEl){
      eventsEl.innerHTML = '';
      const start = Math.max(0, s.events.length - 6);
      s.events.slice(start).forEach(line=>{
        const div = document.createElement('div');
        div.textContent = line;
        eventsEl.appendChild(div);
      });
    }
  }

  function finishTacticalBattle(didWin){
    const s = currentTactical;
    if(!s) return;
    // Close overlay
    const overlay = document.getElementById('tacticalOverlay');
    if(overlay) overlay.style.display = 'none';
    // Determine losses relative to start
    const losses = s.initPlayer - Math.max(0, s.currentPlayer);
    // Call into main battle function with override values and suppress simulation
    doBattle(s.slot, { overrideLoss: losses, overrideWin: didWin, suppressSim: true, defence: s.defence });
    currentTactical = null;
  }

  function tacAction(action){
    const s = currentTactical;
    if(!s || s.finished) return;
    s.round = (s.round || 0) + 1;
    let factorPlayer = 1;
    let factorEnemy  = 1;
    if(action === 'attack'){
      factorPlayer = 1.3;
      factorEnemy  = 1.25;
    }else if(action === 'defend'){
      factorPlayer = 0.7;
      factorEnemy  = 0.5;
    }else if(action === 'heal'){
      factorPlayer = 0.5;
      factorEnemy  = 0.6;
    }
    const baseP = Math.max(1, Math.floor(s.currentPlayer * 0.08));
    const baseE = Math.max(1, Math.floor(s.currentEnemy * 0.08));
    const ratio = s.currentPlayer / Math.max(1, s.currentEnemy);
    const ratioAdj = Math.max(0.5, Math.min(2.0, ratio));
    let dmgToE = Math.round(baseP * factorPlayer * ratioAdj * (0.8 + Math.random()*0.4));
    let dmgToP = Math.round(baseE * factorEnemy * (1/ratioAdj) * (0.8 + Math.random()*0.4));
    if(dmgToE > s.currentEnemy) dmgToE = s.currentEnemy;
    if(dmgToP > s.currentPlayer) dmgToP = s.currentPlayer;
    // Apply damages
    s.currentEnemy = Math.max(0, s.currentEnemy - dmgToE);
    s.currentPlayer = Math.max(0, s.currentPlayer - dmgToP);
    // Heal if applicable
    let healMsg = '';
    if(action === 'heal'){
      const healable = s.initPlayer - s.currentPlayer;
      let healAmount = Math.min(healable, Math.max(1, Math.floor(s.initPlayer * 0.06)));
      const cost = healAmount * 10;
      if(healAmount > 0 && (S.gold||0) >= cost){
        S.gold -= cost;
        s.currentPlayer += healAmount;
        healMsg = ` Healed ${fmt(healAmount)} milites at cost ${fmt(cost)}d.`;
      }else if(healAmount > 0){
        healMsg = ' (Not enough denarii to heal)';
      }
    }
    let actLabel;
    if(action === 'attack') actLabel = 'Assault';
    else if(action === 'defend') actLabel = 'Defend';
    else if(action === 'heal') actLabel = 'Heal';
    else actLabel = action;
    const msg = `${actLabel}: you lost ${fmt(dmgToP)} milites, enemy lost ${fmt(dmgToE)}.${healMsg}`;
    s.events.push(msg);
    // Check for battle end
    if(s.currentEnemy <= 0){
      s.events.push('Enemy routed!');
      s.finished = true;
      finishTacticalBattle(true);
      return;
    }
    if(s.currentPlayer <= 0){
      s.events.push('Your force was wiped out.');
      s.finished = true;
      finishTacticalBattle(false);
      return;
    }
    updateTacticalUI();
  }

function startTacticalBattle(slot, defenceFlag){
    const initTroops = S.warriors || 0;
    if(initTroops <= 0){
      toast('You have no milites to muster.');
      return;
    }
    const sim = battleSim(slot);
    // Setup battle state
    currentTactical = {
      slot: slot,
      sim: sim,
      initPlayer: initTroops,
      currentPlayer: initTroops,
      currentEnemy: sim && typeof sim.enemies === 'number' ? sim.enemies : 0,
      events: [],
      finished: false,
      round: 0,
      defence: !!defenceFlag
    };
    const overlay = document.getElementById('tacticalOverlay');
    if(overlay) overlay.style.display = 'flex';
    // Attach handlers on first open (or re-bind).  Doing this here ensures
    // elements exist in the DOM because the overlay markup appears after the
    // main script.
    const btnA = document.getElementById('tacBtnAttack');
    const btnD = document.getElementById('tacBtnDefend');
    const btnH = document.getElementById('tacBtnHeal');
    const btnAuto = document.getElementById('tacBtnAuto');
    const btnClose = document.getElementById('tacCloseBtn');
    if(btnA)    btnA.onclick = ()=> tacAction('attack');
    if(btnD)    btnD.onclick = ()=> tacAction('defend');
    if(btnH)    btnH.onclick = ()=> tacAction('heal');
    if(btnAuto) btnAuto.onclick = ()=>{
      // Auto-resolve using the default simulation; hide overlay and call doBattle normally
      if(overlay) overlay.style.display = 'none';
      if(currentTactical){
        const autoSlot = currentTactical.slot;
        currentTactical = null;
        doBattle(autoSlot, { suppressSim: true });
      }
    };
    if(btnClose) btnClose.onclick = ()=>{
      if(currentTactical){
        currentTactical.events.push('Retreat!');
        currentTactical.finished = true;
        finishTacticalBattle(false);
      }
    };
    updateTacticalUI();
  }

  // (handlers attached in startTacticalBattle)

  // Land tier unlock popup helpers
  function showLandTierUnlockPopup(tier, names){
    const overlay = document.getElementById('landTierOverlay');
    const listEl  = document.getElementById('landTierList');
    const textEl  = document.getElementById('landTierText');
    const btn     = document.getElementById('landTierOkBtn');
    if(!overlay || !listEl || !textEl || !btn) return;

    listEl.innerHTML = '';
    names.forEach(n => {
      const li = document.createElement('li');
      li.textContent = n;
      listEl.appendChild(li);
    });

    textEl.textContent = `Your new rank lets you claim:`;
    overlay.style.display = 'flex';

    btn.onclick = function(){
      overlay.style.display = 'none';
    };
  }


  // --- Renown feedback toast (small) ---
  function showRenownToast(amount, label){
    try{
      const s = (amount>=0?"+":"") + amount;
      showToast(`${s} Renown${label?(" ‚Ä¢ "+label):""}`, amount>=0 ? "good" : "bad");
    }catch(e){}
  }

</script>

  
  <!-- Land Tier Unlock Overlay -->
  <div id="landTierOverlay" style="position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:1900;">
    <div style="position:absolute;inset:0;background:rgba(0,0,0,.55);"></div>
    <div class="card" style="position:relative;max-width:420px;width:92%;max-height:80vh;overflow:auto;z-index:10;">
      <div class="sectionTitle"><span>New Lands Unlocked</span><span></span></div>
      <div class="cardBody">
        <p id="landTierText" style="font-size:.85rem;margin:0 0 8px;">
          Your growing renown lets you claim new kinds of territory.
        </p>
        <ul id="landTierList" style="margin:4px 0 10px;padding-left:18px;font-size:.82rem;"></ul>
        <button class="primaryBtn" id="landTierOkBtn" type="button">Continue</button>
      </div>
    </div>
  </div>

<!-- Loot Chest Overlay -->
  <div id="chestOverlay" style="position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:2000;">
    <div id="chestBackdrop" style="position:absolute;inset:0;background:rgba(0,0,0,.55);backdrop-filter:blur(6px);"></div>
    <div id="chestCard" class="card" style="position:relative;width:min(520px, calc(100vw - 26px));border-radius:26px;overflow:hidden;">
      <div class="sectionTitle" style="justify-content:center;">
        <span id="chestTitle" style="color:var(--accent);font-weight:900;">Chest</span>
      </div>
      <div class="cardBody" style="text-align:center; padding:16px 14px 14px;">
        <div id="chestIcon" style="font-size:56px;line-height:1.0;filter:drop-shadow(0 12px 18px rgba(0,0,0,.25));">üß∞</div>
        <div id="chestHint" style="margin-top:10px;font-family:var(--mono);color:var(--muted);font-size:.80rem;">Tap to open</div>

        <div id="revealRow" style="margin-top:14px;display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px;">
          <div class="card" style="box-shadow:none;border-radius:18px;border-color:rgba(31,58,42,.75);">
            <div class="cardBody" style="padding:14px 10px;">
              <div class="pill" id="rev1" style="display:inline-block;">?</div>
            </div>
          </div>
          <div class="card" style="box-shadow:none;border-radius:18px;border-color:rgba(31,58,42,.75);">
            <div class="cardBody" style="padding:14px 10px;">
              <div class="pill" id="rev2" style="display:inline-block;">?</div>
            </div>
          </div>
          <div class="card" style="box-shadow:none;border-radius:18px;border-color:rgba(31,58,42,.75);">
            <div class="cardBody" style="padding:14px 10px;">
              <div class="pill" id="rev3" style="display:inline-block;">?</div>
            </div>
          </div>
        </div>

        <div id="chestSub" style="margin-top:12px;font-family:var(--sans);color:var(--muted);font-size:.78rem;line-height:1.25;">
          Tap each reward, then continue.
        </div>
        <button id="chestContinue" class="tab" style="margin-top:10px;width:100%;justify-content:center;display:none;">
          <span class="dot"></span>Continue
        </button>
      </div>
    </div>
  </div>


  <!-- Battle Report Overlay -->
  <div id="battleOverlay" style="position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:2100;">
    <div style="position:absolute;inset:0;background:rgba(0,0,0,.55);backdrop-filter:blur(6px);" onclick="closeBattleReport()"></div>
    <div id="battleCard" class="card" style="position:relative;width:min(560px, calc(100vw - 26px));border-radius:26px;overflow:hidden;">
      <div class="sectionTitle" style="justify-content:space-between;">
        <span id="battleTitle" style="color:var(--accent);font-weight:900;">Battle Report</span>
        <button class="tab" style="padding:8px 12px;" onclick="closeBattleReport()">Close</button>
      </div>
      <div class="cardBody" style="padding:14px;">
        <div id="battleBody"></div>
      </div>
    </div>
  </div>


  <!-- Battle Simulation Overlay -->
  <div id="battleSimOverlay" style="position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:2050;">
    <div style="position:absolute;inset:0;background:rgba(0,0,0,.55);backdrop-filter:blur(6px);"></div>
    <div id="battleSimCard" class="card" style="position:relative;width:min(560px, calc(100vw - 26px));border-radius:26px;overflow:hidden;">
      <div class="sectionTitle" style="justify-content:space-between;">
        <span id="battleSimTitle" style="color:var(--accent);font-weight:900;">Engagement</span>
        <div style="display:flex;gap:8px;align-items:center;">
          <button class="tab" style="padding:8px 12px;" id="battleSimSkip">Auto resolve</button>
        </div>
      </div>
      <div class="cardBody" style="padding:14px;">

        <div class="simMetaRow">
          <div class="simMetaLeft">
            <div class="simMetaLabel">ENEMY FORCE</div>
            <div class="simMetaText" id="battleSimEnemyName">0 enemies</div>
          </div>
        </div>
<div class="simBlock"> <div class="simLabel">Enemy</div> <div class="simBar"> <div class="battleBar"> <img id="battleSimEnemyBarImg" class="battleBarSprite" src="Sprites/player and enemy bars/enemy bar full.png" alt="Enemy bar"> <div class="battleBarCount battleBarCount--enemy" id="enemyBarCount"></div> </div> </div> <div class="simStats" id="battleSimEnemyStats"></div> </div> <div class="simBlock"> <div class="simLabel">Your force</div> <div class="simBar"> <div class="battleBar"> <img id="battleSimYourBarImg" class="battleBarSprite" src="Sprites/player and enemy bars/Player bar full.png" alt="Your bar"> <div class="battleBarCount battleBarCount--ally" id="yourBarCount"></div> </div> </div> <div class="simStats" id="battleSimYourStats"></div> </div>


        <div class="simEvents" id="battleSimEvents"></div>

        <button id="battleSimContinue" class="tab active" style="margin-top:10px;width:100%;justify-content:center;">
          <span class="dot"></span>View Report
        </button>
      </div>
    </div>
  </div>

  <!-- Tactical Battle Overlay -->
  <div id="tacticalOverlay" style="position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:2250;">
    <div style="position:absolute;inset:0;background:rgba(0,0,0,.55);backdrop-filter:blur(6px);"></div>
    <div class="card" style="position:relative;width:min(560px, calc(100vw - 26px));border-radius:26px;overflow:hidden;">
      <div class="sectionTitle" style="justify-content:space-between;">
        <span id="tacticalTitle" style="color:var(--accent);font-weight:900;">Battle Orders</span>
        <button class="tab" style="padding:8px 12px;" id="tacCloseBtn" type="button">Retreat</button>
      </div>
      <div class="cardBody" style="padding:14px;">
        <div class="simBlock">
          <div class="simLabel">Enemy</div>
          <div class="simBar">
            <div class="battleBar">
              <img id="tacEnemyBarImg" class="battleBarSprite" src="Sprites/player and enemy bars/enemy bar full.png" alt="Enemy bar">
              <div class="battleBarCount battleBarCount--enemy" id="tacEnemyBarCount"></div>
            </div>
          </div>
        </div>
        <div class="simBlock">
          <div class="simLabel">Your force</div>
          <div class="simBar">
            <div class="battleBar">
              <img id="tacYourBarImg" class="battleBarSprite" src="Sprites/player and enemy bars/Player bar full.png" alt="Your bar">
              <div class="battleBarCount battleBarCount--ally" id="tacYourBarCount"></div>
            </div>
          </div>
        </div>
        <div id="tacEvents" class="simEvents" style="margin-top:8px;min-height:60px;max-height:160px;overflow-y:auto;"></div>
        <div style="display:flex;flex-wrap:wrap;gap:8px;margin-top:8px;">
          <button class="tab" id="tacBtnAttack" type="button" style="flex:1 1 auto;">Assault</button>
          <button class="tab" id="tacBtnDefend" type="button" style="flex:1 1 auto;">Defend</button>
          <button class="tab" id="tacBtnHeal" type="button" style="flex:1 1 auto;">Heal</button>
          <button class="tab" id="tacBtnAuto" type="button" style="flex:1 1 auto;">Auto</button>
        </div>
      </div>
    </div>
  </div>



<!-- === Battle Variety & Land Plausibility Patch (appended) === -->
