
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />



  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="ElderToKing">



  <link rel="apple-touch-icon" sizes="180x180" href="icons/icon-180.png">
  <link rel="apple-touch-icon" href="apple-touch-icon.png">



  <title>ElderToKing</title>
  <style>
:root{
      --bg:#0b0f0c;
      --panel:#101a14;
      --panel2:#0d1511;
      --text:#e9f6ea;
      --muted:#a6d4ac;
      --accent:#f4d06f;
      --ok:#6be675;
      --warn:#ffcc66;
      --danger:#ff6b6b;
      --line:#1f3a2a;
      --shadow: 0 14px 36px rgba(0,0,0,.38);
      --radius:22px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    *{box-sizing:border-box;}
    html{font-size:20px;-webkit-text-size-adjust:100%;text-size-adjust:100%;}
    body{
      margin:0;
      min-height:100vh;
      padding: calc(6px + env(safe-area-inset-top)) 14px calc(92px + env(safe-area-inset-bottom));
      font-family:var(--sans);
      color:var(--text);
      background:
        url("Sprites/Game Background ElderToKing.png") center/cover fixed no-repeat,
        radial-gradient(900px 700px at 18% 0%, rgba(244,208,111,.13), transparent 55%),
        radial-gradient(900px 650px at 92% 25%, rgba(192,108,59,.10), transparent 55%),
        linear-gradient(180deg, #070a08, var(--bg));
      -webkit-tap-highlight-color: transparent;
    }
body::after{
      content:"";
      position:fixed;
      inset:0;
      pointer-events:none;
      background: radial-gradient(circle at center,
                  rgba(0,0,0,0) 40%,
                  rgba(0,0,0,0.45) 100%);
      z-index: 0;
    }


    .wrap{max-width:760px;margin:0 auto;display:flex;flex-direction:column;gap:12px;}
    header{
      position:sticky;
      top:0;
      z-index:20;
      padding-bottom:10px;
      background:
        linear-gradient(180deg,
          rgba(247,240,226,.98),
          rgba(242,224,196,.96)
        );
      border-bottom:1px solid rgba(158,104,54,.55);
    }
    .top{display:flex;align-items:flex-end;justify-content:space-between;gap:10px;padding:10px 2px 10px;}
    .top > div:first-child{display:none;}
    h1{margin:0;font-family:var(--mono);font-size:.85rem;letter-spacing:.5px;color:var(--accent);text-shadow: 0 0 14px rgba(244,208,111,.16);}
    .sub{margin:4px 0 0;color:var(--muted);font-size:.78rem;line-height:1.3;max-width:52ch;}
    .hud{display:flex;flex-wrap:wrap;gap:8px;align-items:center;justify-content:flex-start;overflow:visible;scrollbar-width:none;}
    .hud::-webkit-scrollbar{display:none;}
    .pill{
      border:1px solid rgba(244,170,92,.7);
      background: rgba(255,255,255,0.05);
      border-radius:999px;
      padding:10px 12px;
      box-shadow: var(--shadow);
      font-family:var(--mono);
      font-size:.78rem;
      white-space:nowrap;
      user-select:none;
    }
    .pill b{color:var(--accent);font-weight:900;font-size:.9rem;letter-spacing:.03em;}
    .card{
      background: rgba(255,255,255,0.06);
      border:1px solid rgba(244, 170, 92, 0.55);
      border-radius: var(--radius);
      box-shadow: 0 16px 40px rgba(0,0,0,.45);
      backdrop-filter: blur(10px);
      overflow:hidden;
    }
    .cardBody{padding:14px;}
    .sectionTitle{
      display:flex;align-items:center;justify-content:space-between;gap:12px;
      font-family:var(--mono);
      color:var(--muted);
      font-size:.78rem;
      padding: 12px 14px;
      border-bottom:1px solid rgba(244,170,92,.5);
      background: linear-gradient(180deg,
                   rgba(255,255,255,0.12),
                   rgba(244,170,92,0.10));
    }
    .sectionTitle b{color:var(--text);}
    .bigBtn{
      width:100%;
      border:1px solid rgba(244,170,92,.85);
      background: linear-gradient(180deg,
                    rgba(255,255,255,0.22),
                    rgba(244,170,92,0.20));
      color:var(--text);
      border-radius: 22px;
      padding:18px 16px;
      font-family:var(--mono);
      cursor:pointer;
      box-shadow: 0 16px 40px rgba(0,0,0,.45);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      min-height:86px;
      transition: transform .08s ease, border-color .2s ease, filter .2s ease;
      touch-action: manipulation;
      user-select:none;
    }
    .bigBtn:active{transform: translateY(1px) scale(.99);}
    .bigBtn[disabled]{opacity:.55;cursor:not-allowed;transform:none;filter:saturate(.7);}
    .bigBtn:hover{border-color: rgba(244,208,111,.60);}
    .bigLeft{display:flex;flex-direction:column;gap:4px;min-width:0;}
    .bigName{font-size:1.06rem;color:var(--accent);font-weight:1000;letter-spacing:.3px;}
    .bigDesc{font-family:var(--sans);font-size:.84rem;line-height:1.3;color:var(--text);opacity:.78;}
    .bigRight{font-family:var(--mono);text-align:right;}
    .bigRight .gain{font-size:.90rem;}
    .bigRight .hint{font-size:.72rem;color:var(--muted);margin-top:2px;}
    .row2{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px;}
    .row3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px;margin-top:10px;}
    @media (max-width: 520px){ .row3{grid-template-columns:1fr;} }

    .smallBtn{
      border:1px solid rgba(244,170,92,.9);
      background: linear-gradient(180deg,
                   rgba(255,255,255,0.32),
                   rgba(244,170,92,0.28));
      color:var(--text);
      border-radius: 18px;
      padding:14px 14px;
      cursor:pointer;
      font-family:var(--mono);
      min-height:64px;
      display:flex;flex-direction:column;justify-content:center;gap:4px;
      transition: transform .08s ease, border-color .2s ease, opacity .2s ease, filter .2s ease;
      touch-action: manipulation;
      user-select:none;
    }    .smallBtn:active{transform: translateY(1px) scale(.99);}
    .smallBtn[disabled]{opacity:.55;cursor:not-allowed;transform:none;filter:saturate(.75);}
    .smallBtn:hover{border-color: rgba(244,208,111,.38);}
    .smallBtn .t{font-weight:900;color:var(--accent);font-size:.92rem;}
    .smallBtn .d{font-family:var(--sans);color:var(--muted);font-size:.74rem;line-height:1.25;opacity:.82;}

    /* Minimal battle cards (Variant C) */
    .smallBtn.battleCard{
      align-items:flex-start;
      justify-content:flex-start;
      gap:2px;
      padding:8px 11px;
      border-radius:16px;
      border:1px solid rgba(158,104,54,.45);
      background:linear-gradient(180deg,#fbf5ea,#f3e4cf);
      box-shadow:none;
    }

    .smallBtn.battleCard .t{
      font-size:.82rem;
      font-weight:700;
      letter-spacing:.01em;
      color:var(--text);
    }

    .smallBtn.battleCard .d{
      font-family:var(--sans);
      font-size:.7rem;
      line-height:1.35;
      color:var(--muted);
      white-space:pre-line; /* so \n in JS becomes a second line */
    }

    .smallBtn.battleCard .d::first-line{
      font-weight:600;
    }


    .bar{margin-top:12px;border:1px solid rgba(31,58,42,.85);border-radius: 999px;overflow:hidden;background: rgba(0,0,0,.16);}
    .bar > div{height:12px;width:10%;background: linear-gradient(90deg, rgba(244,208,111,.92), rgba(107,230,117,.80));transition: width .22s ease;}
    .villagePopBlock{margin-top:10px;font-family:var(--mono);font-size:.74rem;color:var(--muted);display:flex;flex-direction:column;gap:2px;}
    .villagePopBlock b{color:var(--text);}
    
    .meta{display:flex;justify-content:space-between;gap:10px;font-family:var(--mono);font-size:.74rem;color:var(--muted);margin-top:10px;}
    .meta b{color:var(--text);}
    details{margin-top:12px;border-top:1px solid rgba(31,58,42,.55);padding-top:10px;}
    summary{cursor:pointer;font-family:var(--mono);color:var(--muted);user-select:none;}
    .miniLog{
  margin-top:10px;
  border-radius:16px;
  border:1px solid rgba(244,170,92,.8);
  background: rgba(0,0,0,0.62);
  backdrop-filter: blur(8px);
  overflow:hidden;
}
.miniLogHeader{
  padding:6px 10px;
  font-family:var(--mono);
  font-size:.76rem;
  letter-spacing:.02em;
  text-transform:uppercase;
  color:var(--muted);
  border-bottom:1px solid rgba(31,58,42,.75);
  background: linear-gradient(180deg, rgba(8,12,10,.95), rgba(8,12,10,.88));
}
.log{
  margin-top:10px;
  max-height: 28vh;
  overflow:auto;
  border-radius:18px;
  border:1px solid rgba(244,170,92,.9);
  background: rgba(0,0,0,0.78);
  backdrop-filter: blur(8px);
  padding:12px;
  font-family:var(--mono);
  font-size:.76rem;
  line-height:1.45;
  -webkit-overflow-scrolling: touch;
  scrollbar-width:none; /* Firefox */
}
.log::-webkit-scrollbar{
  display:none; /* WebKit */
}

/* Each log line as a row */
.log-entry{
  display:flex;
  gap:8px;
  align-items:flex-start;
  margin:0 0 6px;
  opacity:0;
  transform:translateY(-4px);
  animation: logIn .18s ease-out forwards;
}

/* Allow multiline battle victory logs */
.log-entry span:last-child{ white-space: pre-line; }

@keyframes logIn{
  to{
    opacity:1;
    transform:translateY(0);
  }
}

/* Timestamp: small + dim */
.log-time{
  opacity:.55;
  font-size:.72rem;
  min-width:44px;
  text-align:right;
  user-select:none;
}

/* Tone colours (same class names you already use) */
.good{color:var(--ok);font-weight:900;}
.bad{color:var(--danger);font-weight:900;}
.warn{color:var(--warn);font-weight:900;}

/* Optional: tiny resource tags if you ever want them */
.log-tag{
  padding:1px 4px;
  border-radius:4px;
  font-size:.72rem;
  opacity:.9;
  user-select:none;
  border:1px solid rgba(31,58,42,.65);
  margin-left:6px;
}
.log-tag-gold{color:var(--accent);}
.log-tag-renown{color:var(--muted);}
.log-tag-land{color:var(--muted);}

/* Bottom tabs */
    .tabbar{
      position:fixed; left:0; right:0; bottom:0;
      padding: 10px 12px calc(10px + env(safe-area-inset-bottom));
      background: linear-gradient(180deg, rgba(11,15,12,.0), rgba(11,15,12,.92) 40%, rgba(11,15,12,.985));
      border-top:1px solid rgba(31,58,42,.75);
      display:flex; gap:10px; justify-content:center;
      overflow-x:auto; overflow-y:hidden;
      -webkit-overflow-scrolling: touch;
      backdrop-filter: blur(6px);
      z-index: 999;
    }
    .tabbar::-webkit-scrollbar{display:none;}
    .tab{
      border:1px solid rgba(31,58,42,.9);
      background: linear-gradient(180deg, rgba(16,26,20,.86), rgba(13,21,17,.86));
      color: var(--muted);
      border-radius: 999px;
      padding: 10px 12px;
      font-family: var(--mono);
      font-size: .76rem;
      cursor:pointer;
      white-space:nowrap;
      user-select:none;
      transition: transform .08s ease, border-color .2s ease, color .2s ease, opacity .2s ease;
      touch-action: manipulation;
    }
    .tab:active{transform: translateY(1px) scale(.99);}
    .tab.active{color:var(--text); border-color: rgba(244,208,111,.45);}
    .tab[disabled]{opacity:.45;cursor:not-allowed;filter:saturate(.75);}
    .dot{display:inline-block;width:8px;height:8px;border-radius:999px;background: rgba(244,208,111,.25);margin-right:8px;vertical-align:middle;}
    .tab.active .dot{background: rgba(244,208,111,.92); box-shadow: 0 0 12px rgba(244,208,111,.25);}

    .toast{
      position: fixed;
      left:50%;
      transform: translateX(-50%);
      bottom: calc(84px + env(safe-area-inset-bottom));
      background: linear-gradient(180deg, var(--card-bg), var(--card-bg-soft));
      border: 1px solid rgba(158,104,54,.55);
      border-radius: 999px;
      padding: 10px 16px;
      font-family: var(--mono);
      font-size: 0.78rem;
      color: var(--card-text);
      box-shadow: 0 12px 30px rgba(0,0,0,.45);
      z-index: 1200;
      display:none;
      max-width: calc(100vw - 24px);
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }

.toast.show{display:block;animation: pop .18s ease-out;}
    @keyframes pop{from{transform:translateX(-50%) scale(.98);opacity:.25;}to{transform:translateX(-50%) scale(1);opacity:1;}}

    /* tiny dopamine confetti */
    .spark{
      position: fixed;
      width: 26px; height: 26px;
      pointer-events:none;
      opacity:.98;
      transform: translate(-50%,-50%);
      animation: fly 650ms ease-out forwards;
      filter: drop-shadow(0 10px 18px rgba(0,0,0,.35));
      z-index: 1300;
      background-image: url("Sprites/Denarii Icon.png");
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
    }
    @keyframes fly{to{ transform: translate(calc(-50% + var(--dx)), calc(-50% + var(--dy))) scale(.65); opacity:0; }}

    .table{
      width:100%;
      border-collapse:separate;
      border-spacing:0 8px;
      font-family:var(--mono);
      font-size:.78rem;
      color:var(--text);
    }
    
    /* Land / Territories visual tweaks */
    .territorySummaryRow{
      display:flex;
      flex-wrap:wrap;
      gap:6px 12px;
      margin:6px 0 4px;
      font-family:var(--mono);
      font-size:.76rem;
    }
    .territorySummaryTag{
      padding:4px 8px;
      border-radius:999px;
      border:1px solid rgba(158,104,54,.6);
      background:rgba(255,255,255,0.6);
      white-space:nowrap;
    }
    .territorySummaryTag b{
      padding-right:4px;
    }
    
    
    .territoryFlavor{
      display:block;
      margin-top:2px;
      font-family:var(--sans);
      font-size:.78rem;
      color:var(--muted);
    }
.territoryCardHeader{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:8px;
      margin-bottom:2px;
    }

    .territoryOwnedTag{
      font-family:var(--mono);
      font-size:.75rem;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid rgba(158,104,54,.7);
      background:rgba(255,255,255,0.7);
    }
.territoryCard{
      text-align:left;
      align-items:flex-start;
    }
    .territoryCard .t{
      font-size:.9rem;
    }
    .territoryCard .d{
      font-size:.8rem;
    }
.table td{
      padding:10px 12px;
      border:1px solid rgba(31,58,42,.85);
      background: linear-gradient(180deg, rgba(10,16,13,.62), rgba(7,10,8,.62));
    }
    .table td:first-child{border-radius:14px 0 0 14px;color:var(--muted);width:46%;}
    .table td:last-child{border-radius:0 14px 14px 0;text-align:right;}
    .danger{border-color: rgba(255,107,107,.35) !important;}
    /* Milites icon label */
    .milites-label{
      display:flex;
      align-items:center;
      gap:8px;
    }
    .milites-icon{
      width:44px;
      height:44px;
      image-rendering: pixelated;
    }
  

    /* Chest overlay transitions */
    #chestOverlay{
      opacity: 0;
      pointer-events: none;
      transition: opacity .22s ease-out;
    }
    #chestOverlay.visible{
      opacity: 1;
      pointer-events: auto;
    }
    #chestCard{
      transform: translateY(18px) scale(.94);
      opacity: 0;
      transition: transform .26s ease-out, opacity .26s ease-out;
    }
    #chestOverlay.visible #chestCard{
      transform: translateY(0) scale(1);
      opacity: 1;
    }

    /* Battle report overlay transitions */
    #battleOverlay{
      opacity: 0;
      pointer-events: none;
      transition: opacity .22s ease-out;
    }
    #battleOverlay.visible{
      opacity: 1;
      pointer-events: auto;
    }
    #battleCard{
      transform: translateY(18px) scale(.94);
      opacity: 0;
      transition: transform .26s ease-out, opacity .26s ease-out;
    }
    #battleOverlay.visible #battleCard{
      transform: translateY(0) scale(1);
      opacity: 1;
    }


    /* --- Mobile header compact mode (keeps HUD, removes banner text) --- */
    @media (max-width: 520px){
      .top{padding:6px 0 6px; align-items:center;}
      .top > div:first-child{display:none;} /* hides title + description */
      .hud{gap:6px; justify-content:flex-start;}
      .pill{padding:8px 10px; font-size:.72rem; box-shadow: 0 10px 24px rgba(0,0,0,.30);}
      header{padding-bottom:6px;}
    }
    /* If description exists anywhere, don't show it */
    .sub{display:none !important;}


    
/* Battle simulation overlay transitions */
#battleSimOverlay{
  position:fixed;
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  background: rgba(0,0,0,0.55);
  backdrop-filter: blur(3px);
  opacity:0;
  pointer-events:none;
  transition: opacity .22s ease-out;
  z-index:1600;
}
#battleSimOverlay.visible{
  opacity:1;
  pointer-events:auto;
}
#battleSimCard{
  transform: translateY(18px) scale(.94);
  opacity:0;
  transition: transform .26s ease-out, opacity .26s ease-out;
}
#battleSimOverlay.visible #battleSimCard{
  transform: translateY(0) scale(1);
  opacity:1;
}
.simLine{
  margin:0 0 6px;
  font-family:var(--mono);
  font-size:.80rem;
  line-height:1.30;
  white-space:pre;
}


.simMetaRow{
  display:flex;
  justify-content:space-between;
  align-items:flex-end;
  gap:10px;
  margin-bottom:10px;
  font-family:var(--mono);
  font-size:.78rem;
  color:var(--muted);
}
.simMetaLabel{
  opacity:.85;
  letter-spacing:.04em;
  text-transform:uppercase;
  font-size:.72rem;
}
.simMetaText{
  font-size:.9rem;
  color:var(--text);
}
.simBlock{
  margin:0;
  padding:0;
}
.simLabel{
  font-family:var(--mono);
  font-size:.78rem;
  margin-bottom:2px;
  color:var(--muted);
  line-height:1.0;
}
.simBar{
  margin:0;
  padding:0;
  border:none;
  background:none;
  display:block;
}
.battleBarSprite{
  display:block;
  width:100%;
  max-width:300px;
  height:auto;
  image-rendering:pixelated;
}
.battleBar{
  position:relative;
  display:inline-block;
}
.battleBar.barShake{
  animation: barShake 0.18s ease-out;
}
@keyframes barShake{
  0%{ transform:translateX(0); }
  25%{ transform:translateX(-1px); }
  50%{ transform:translateX(1px); }
  75%{ transform:translateX(-1px); }
  100%{ transform:translateX(0); }
}



.battleBarCount{
  position:absolute;
  right:24px;
  top:50%;
  transform:translateY(-50%);
  font-family:var(--mono);
  font-size:.9rem;
  color:#000;
  text-shadow:0 0 4px rgba(0,0,0,0.9);
}
.simStats{
  display:none;
  margin-top:4px;
  font-family:var(--mono);
  font-size:.74rem;
  color:var(--muted);
  line-height:1.0;
}
.battleSummaryBlock{
  border-radius:16px;
  border:1px solid rgba(158,104,54,.7);
  background:linear-gradient(180deg,#fbf4e7,#f4e3cf);
  padding:10px 12px;
  font-family:var(--mono);
  font-size:.82rem;
  line-height:1.45;
}
.battleSummaryTitle{
  font-weight:900;
  margin-bottom:4px;
}
.battleSummaryLine{
  margin:0 0 2px;
}
.battleSummaryDivider{
  margin:6px 0;
  border-top:1px solid rgba(158,104,54,.45);
}
.battleSummaryMeta{
  color:var(--muted);
  font-size:.78rem;
}
.battleSummaryNote{
  margin-top:8px;
  font-family:var(--sans);
  font-size:.82rem;
  color:var(--muted);
  line-height:1.3;
}
.simEvents{
  margin-top:8px;
  padding:10px 12px 8px;
  border-radius:14px;
  border:1px solid rgba(158,104,54,.55);
  background:rgba(255,243,222,0.96);
  font-family:var(--sans);
  font-size:.84rem;
  line-height:1.4;
}
.simEventLine{
  margin:0 0 4px;
  line-height:1.35;
  color:#4a2605;
}

/* Stronger contrast for battle sim log tones */
.simEvents .good{color:#32c96b;font-weight:900;}
.simEvents .bad{color:#ff4760;font-weight:900;}
.simEvents .warn{color:#6E7379;font-weight:900;}
    /* Intro overlay */
    .introOverlay{
      position:fixed;
      inset:0;
      z-index:2000;
      display:flex;
      align-items:stretch;
      justify-content:center;
      pointer-events:auto;
    }
    .introBackdrop{
      position:absolute;
      inset:0;
      background:
        url("Sprites/Game Intro Background.png") center/cover no-repeat,
        radial-gradient(900px 700px at 10% 0%, rgba(244,208,111,.22), transparent 55%),
        radial-gradient(900px 650px at 90% 25%, rgba(192,108,59,.22), transparent 55%),
        linear-gradient(180deg, rgba(7,10,8,.96), rgba(7,10,8,.98));
      opacity:1;
    }
    .introCenter{
      position:relative;
      z-index:1;
      flex:1;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px 14px 82px;
    }
    .introCard{
      max-width:720px;
      width:100%;
      transform: translateY(12px) scale(.97);
      opacity:0;
      animation: introPop .28s ease-out forwards;
      background: rgba(255,255,255,0.10);
      border:1px solid rgba(244,170,92,0.80);
      backdrop-filter: blur(12px);
    }
    @keyframes introPop{
      from{ transform: translateY(22px) scale(.96); opacity:0; }
      to{ transform: translateY(0) scale(1); opacity:1; }
    }
    .introNameBlock{
      margin:10px 0 12px;
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .introLabel{
      font-family:var(--mono);
      font-size:.8rem;
      /* warm parchment text colour */
      color:rgb(246, 224, 178);
    }
    .introNameBlock input{
      border-radius:18px;
      border:1px solid rgba(158, 104, 54, 0.95);
      background: linear-gradient(180deg, rgba(24, 14, 8, 0.96), rgba(18, 10, 6, 0.97));
      padding:10px 12px;
      font-family:var(--mono);
      font-size:.86rem;
      color:rgb(249, 233, 196);
      outline:none;
      width:100%;
    }
    .introNameBlock input::placeholder{
      color:rgba(249, 233, 196, .55);
    }
    .introNameBlock input:focus{
      border-color: rgba(244,208,111,.9);
      box-shadow: 0 0 0 1px rgba(244,208,111,.35);
    }
    .introDemo{
      margin-top:4px;
      border-radius:18px;
      border:1px solid rgba(31,58,42,.85);
      padding:10px 10px;
      display:flex;
      gap:10px;
      align-items:stretch;
      background: linear-gradient(180deg, rgba(10,16,13,.9), rgba(7,10,8,.9));
    }
    .introDemoText{
      flex:1;
      display:flex;
      flex-direction:column;
      gap:4px;
      min-width:0;
      padding-right:4px;
    }
    .introDemoTitle{
      font-family:var(--mono);
      font-size:.84rem;
      color:var(--accent);
      font-weight:900;
    }
    .introDemoDesc{
      font-family:var(--sans);
      font-size:.8rem;
      color:var(--muted);
      line-height:1.35;
    }
    .introDemoBtn{
      border-radius:18px;
      border:1px solid rgba(244,208,111,.45);
      background: linear-gradient(180deg, rgba(244,208,111,.18), rgba(244,208,111,.08));
      padding:10px 10px;
      font-family:var(--mono);
      font-size:.76rem;
      color:var(--text);
      cursor:pointer;
      display:flex;
      flex-direction:column;
      justify-content:center;
      gap:4px;
      min-width:0;
      box-shadow: 0 10px 26px rgba(0,0,0,.42);
      touch-action:manipulation;
    }
    .introDemoBtn:active{
      transform: translateY(1px) scale(.985);
    }
    .introDemoMain{
      font-size:.86rem;
    }
    .introDemoMeta{
      font-size:.78rem;
      color:var(--muted);
    }
    .introStartBtn{
      margin-top:12px;
    }
    .introOverlay[hidden]{
      display:none;
    }

.blur{
  backdrop-filter: blur(4px);
}


/* === Creamy parchment + high-contrast black text theme overrides === */

:root{
  --panel:#f7f0e2;
  --panel2:#f1e2c7;
  --text:#111111;
  --muted:#333333;
  --accent:#f4b04a;
  --ok:#14854c;
}

/* Main cards */
.card{
  background: linear-gradient(180deg, var(--panel), var(--panel2));
  border: 1px solid rgba(244,170,92,.9);
  border-radius: var(--radius);
  box-shadow: 0 18px 42px rgba(0,0,0,.55);
  backdrop-filter: none;
  color: var(--text);
}

/* Section headers ("Village", "Legion", etc.) */
.sectionTitle{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
  font-family:var(--mono);
  color:var(--muted);
  font-size:.78rem;
  padding:12px 14px;
  border-bottom:1px solid rgba(158,104,54,.45);
  background: linear-gradient(
    180deg,
    rgba(255,248,234,.98),
    rgba(244,216,176,.96)
  );
}
.sectionTitle span:first-child{
  color:var(--accent);
}
.sectionTitle b{
  color:var(--text);
}

/* Big primary button (Collect Tribute) */
.bigBtn{
  width:100%;
  border:1px solid rgba(158,104,54,.9);
  background: linear-gradient(180deg,#fdf6eb,#f2e0c5);
  color:var(--text);
  border-radius:22px;
  padding:18px 16px;
  font-family:var(--mono);
  box-shadow:0 16px 40px rgba(0,0,0,.45);
}
.bigBtn:hover{
  border-color:rgba(244,208,111,.8);
}

/* Big name / title inside primary button */
.bigName{
  color:var(--accent);
}

/* Secondary small buttons ("Build Huts", nav tabs etc.) */
.smallBtn{
  border:1px solid rgba(158,104,54,.9);
  background: linear-gradient(180deg,#fdf6eb,#f2e0c5);
  color:var(--text);
  border-radius:18px;
  padding:14px 14px;
}
.smallBtn .t{
  font-weight:900;
  color:var(--accent);
  font-size:.92rem;
}
.smallBtn .d{
  font-family:var(--sans);
  color:var(--muted);
  font-size:.74rem;
  line-height:1.25;
}

/* Generic pill (top resources) */
.pill{
  border:1px solid rgba(244,170,92,.7);
  background: rgba(255,255,255,0.5);
  border-radius:999px;
  padding:6px 10px;
  font-family:var(--mono);
  font-size:.78rem;
  white-space:nowrap;
  color:var(--text);
}

/* Objective / nav tabs */
.tab{
  border:1px solid rgba(244,170,92,.9);
  background: rgba(255,255,255,0.4);
  color:var(--text);
  border-radius:999px;
  padding:10px 12px;
  font-family:var(--mono);
  font-size:.78rem;
}
.tab.active{
  color:var(--text);
  border-color:rgba(244,170,92,1);
}
.tab[disabled]{
  opacity:.6;
  cursor:not-allowed;
  filter:none;
}

/* Logs */
.miniLog{
  margin-top:10px;
  border-radius:16px;
  border:1px solid rgba(158,104,54,.55);
  background: linear-gradient(180deg,#fbf4e7,#f4e3cf);
  backdrop-filter:none;
  overflow:hidden;
}
.miniLogHeader{
  padding:6px 10px;
  font-family:var(--mono);
  font-size:.76rem;
  letter-spacing:.02em;
  text-transform:uppercase;
  color:var(--muted);
  border-bottom:1px solid rgba(158,104,54,.4);
  background: linear-gradient(180deg,#f3e1c7,#ebd2b3);
}
.log{
  margin-top:10px;
  max-height:28vh;
  overflow:auto;
  border-radius:18px;
  border:1px solid rgba(158,104,54,.55);
  background:#fdf8ee;
  backdrop-filter:none;
  padding:12px;
  font-family:var(--mono);
  font-size:.76rem;
  line-height:1.45;
  color:var(--text);
}
.log-time{
  opacity:.75;
  font-size:.72rem;
  min-width:44px;
  text-align:right;
  user-select:none;
  color:var(--muted);
}

/* Good/warn/bad accents still use semantic colours */
.good{color:var(--ok);font-weight:900;}
.bad{color:var(--danger);font-weight:900;}
.warn{color:var(--warn);font-weight:900;}

/* Stats table */
.table{
  width:100%;
  border-collapse:separate;
  border-spacing:0 8px;
  font-family:var(--mono);
  font-size:.78rem;
  color:var(--text);
}
.table td{
  padding:10px 12px;
  border:1px solid rgba(158,104,54,.45);
  background: linear-gradient(180deg,#fbf5ea,#f3e4cf);
}
.table td:first-child{
  border-radius:14px 0 0 14px;
  color:var(--muted);
  width:46%;
}
.table td:last-child{
  border-radius:0 14px 14px 0;
  text-align:right;
}

/* Danger rows in stats */
.danger{
  border-color:rgba(255,107,107,.55) !important;
}

/* Ensure generic text colour on cards/logs/stats is black */
.card, .log, .miniLog, .table, .table td, .smallBtn, .bigBtn{
  color:var(--text);
}


/* === Remove top header strip, keep floating counters === */
header{
  background: transparent !important;
  border: none !important;
  padding-bottom: 0 !important;
  backdrop-filter: none !important;
}
/* Add breathing room between counters and first card */
.card:first-of-type{
  margin-top: 18px;
}
</style>
</head>
<body>
  <div id="introOverlay" class="introOverlay">
    <div class="introBackdrop"></div>
    <div class="introCenter">
      
      <section class="card introCard" id="introCard">
        <div class="cardBody" style="padding:18px 16px 18px;">
          <div class="introNameBlock">
            <label for="introNameInput" class="introLabel">Type your name</label>
            <input
              id="introNameInput"
              maxlength="18"
              autocomplete="off"
              placeholder="Your name‚Ä¶"
            />
          </div>

          <button
            class="bigBtn introStartBtn"
            id="introStartBtn"
            type="button"
            disabled
            style="margin-top:8px;"
          >
            <div class="bigLeft">
              <div class="bigName">Start</div>
            </div>
            <div class="bigRight">
              <div class="gain">Enter the village</div>
              <div class="hint" id="introHint">Pick a name to continue</div>
            </div>
          </button>
        </div>
      </section>

    </div>
  </div>

  <header>
    <div class="wrap">
      <div class="top">
        <div>
          <h1>ElderToKing</h1>
          <p class="sub" id="subline">One main action per tab. Everything else is optional.</p>
        </div>
        <div class="hud">
          <div class="pill">
            <span style="display:inline-flex;align-items:center;gap:6px;">
              <img src="Sprites/Denarii Icon.png" alt="Denarii" style="width:18px;height:18px;image-rendering:pixelated;">
              <span>Denarii <b id="gold">0</b></span>
            </span>
          </div>
          <div class="pill">
            <span style="display:inline-flex;align-items:center;gap:6px;">
              <img src="Sprites/Renown Icon.png" alt="Renown" style="width:18px;height:18px;image-rendering:pixelated;">
              <span>Renown <b id="renown">0</b></span>
            </span>
          </div>
          <div class="pill">Land <b id="landHud">0</b></div>
          <div class="pill" id="playerPill" style="display:none;">
            <span>Ruler <b id="playerNameHud"></b></span>
          </div>
        </div>
      </div>
    </div>
  </header>

  <main class="wrap" id="views">

    <!-- VILLAGE -->
    <section class="card view" data-view="village">
      <div class="sectionTitle"><span>Village</span><span style="display:flex;flex-direction:column;align-items:flex-end;gap:2px;font-size:.74rem;"><span>Income <b id="incomeRate">0</b>/s</span></span></div>
      <div class="cardBody">
        <div class="card" style="box-shadow:0 10px 24px rgba(0,0,0,.36); border-radius:18px; overflow:hidden; margin-bottom:12px;">
          <div class="sectionTitle" style="border-bottom:1px solid rgba(31,58,42,.55);">
            <span>Objectives</span><span><b id="objStreak">0</b> streak</span>
          </div>
          <div class="cardBody" style="padding:10px 12px;">
            <div id="objList" style="display:flex;flex-direction:column;gap:8px;"></div>
          </div>
        </div>

        <button class="bigBtn" id="btnTribute">
          <div class="bigLeft">
            <div class="bigName" id="tributeTitle">Collect Tribute</div>
            <div class="bigDesc">Tap for denarii. Keep your streak for extra.</div>
          </div>
          <div class="bigRight">
            <div class="gain" id="tributeGain">+0 denarii</div>
            <div class="hint" id="tributeHint">Streak x1</div>
          </div>
        </button>

        <button class="smallBtn" id="btnCashout" style="margin-top:10px; display:none;">
          <div class="t">Cash Out</div>
          <div class="d" id="cashoutDesc">Bank your streak bonus.</div>
        </button>


        <div class="row3">
          <button class="smallBtn" id="btnHut" style="display:none;">
            <div class="t">Build Huts</div>
            <div class="d" id="hutDesc">Cheap shelter. Attracts settlers.</div>
          </button>
          <button class="smallBtn" id="btnFarm">
            <div class="t">Build Farm</div>
            <div class="d" id="farmDesc">Passive income. Small but forever.</div>
          </button>
          <button class="smallBtn" id="btnVilla">
            <div class="t">Build Villa</div>
            <div class="d" id="villaDesc">Bigger income. Costs more.</div>
          </button>
        </div>

        <div class="villagePopBlock">
          <div>Population: <b id="popUsed">0</b></div>
          <div>Population Capacity: <b id="popCap">0</b></div>
          <div>Migration: <b id="migRate">0.00</b>/s</div>
        </div>

        <div class="bar"><div id="progressFill"></div></div>
        <p id="incomeBreakdown" style="margin:6px 0 0;font-size:.72rem;color:var(--muted);">
          Income: 0.00/s (net)
        </p>
        <div class="meta">
          <div>Title: <b id="title">Elder</b></div>
          <div>Next: <b id="nextTitle">Elder</b></div>
        </div>

        <div class="miniLog">
          <div class="miniLogHeader">Recent Events</div>
          <div class="log" id="log"></div>
        </div>
      </div>
    </section>

    <!-- LEGION -->
    <section class="card view" data-view="legion" hidden>
      <div class="sectionTitle"><span>‚öîÔ∏è</span><span class="milites-label"><img id="militesIcon" class="milites-icon" alt=""><span>Milites <b id="warriors">0</b></span></span></div>
      <div class="cardBody">
        <button class="bigBtn" id="btnRecruit">
          <div class="bigLeft">
            <div class="bigName">Enlist Milites</div>
            <div class="bigDesc">Equip and pay local milites.</div>
          </div>
          <div class="bigRight">
            <div class="gain" id="recruitCost">Cost 0</div>
            <div class="hint" id="recruitGain">+6 strength</div>
          </div>
        </button>

        
        <div class="row2">
          <button class="smallBtn battleCard" id="btnBattleBandits1">
            <div class="t">Crush bandits</div>
            <div class="d" id="battleBandits1Desc">10‚Äì50 enemies ‚Ä¢ quick skirmish</div>
          </button>
          <button class="smallBtn battleCard" id="btnBattleLevy">
            <div class="t">Muster your levy (local lord)</div>
            <div class="d" id="battleLevyDesc">250‚Äì500 enemies ‚Ä¢ moderate risk</div>
          </button>
          <button class="smallBtn battleCard" id="btnBattleVillageRaid">
            <div class="t">Take nearby village</div>
            <div class="d" id="battleVillageRaidDesc">500‚Äì1,000 enemies ‚Ä¢ high risk</div>
          </button>
          <button class="smallBtn battleCard" id="btnBattleSiege">
            <div class="t">Siege town</div>
            <div class="d" id="battleSiegeDesc">1,000‚Äì5,000 enemies ‚Ä¢ deadly</div>
          </button>
        </div>

        <div class="meta">
          <div>Strength: <b id="legionStr">0</b></div>
          <div>Upkeep: <b id="legionUpkeep">0</b>/s</div>
          <div>Land: <b id="landLegion">0</b></div>
        </div>
      </div>
    </section>

    <!-- TEMPLE -->
<section class="card view" data-view="temple" hidden>
      <div class="sectionTitle"><span>Temple</span><span>Crowns <b id="crowns">0</b></span></div>
      <div class="cardBody">
        <button class="bigBtn" id="btnOffer">
          <div class="bigLeft">
            <div class="bigName">Offer to the Gods</div>
            <div class="bigDesc">Spend denarii for faith. Faith boosts crits.</div>
          </div>
          <div class="bigRight">
            <div class="gain" id="offerCost">Cost 0</div>
            <div class="hint" id="faithNow">Faith 0</div>
          </div>
        </button>

        <div class="row2">
          <button class="smallBtn" id="btnBless">
            <div class="t">Blessing</div>
            <div class="d" id="blessDesc">Short buff window. Cooldown.</div>
          </button>
          <button class="smallBtn" id="btnAscend">
            <div class="t">Ascend (Prestige)</div>
            <div class="d" id="ascendDesc">Reset for crowns (permanent boosts).</div>
          </button>
        </div>

        <div class="meta">
          <div>Crit: <b id="critRate">0%</b></div>
          <div>Buff: <b id="buffLeft">0s</b></div>
        </div>
      </div>
    </section>

    <!-- TERRITORIES (replaces old Land allocation UI) -->
    <section class="card view" data-view="land" hidden>
      <div class="sectionTitle">
        <span>Territories</span>
        <span>Total <b id="territoryCount">0</b></span>
      </div>
      <div class="cardBody">
        <p style="margin:0 0 10px;font-size:.78rem;color:var(--muted);">
          Victories add new territories to your domain.
        </p>

        <div style="margin:0 0 8px;font-size:.78rem;color:var(--muted);">
          Output: <b id="landOutputDen">+0 Denarii / tick</b>, <b id="landOutputPop">+0 Cap</b>
        </div>

        <div id="landSummaryBlock" style="margin:8px 0 6px;font-size:.78rem;color:var(--muted);display:none;">
          <!-- Filled with grouped land types, e.g. "3 Riverlands (Income), 2 Farmlands (Cap)" -->
        </div>

        <div id="territoryEmpty" style="margin:4px 0 0;font-size:.78rem;color:var(--muted);">
          You control no named territories yet. Win a battle to seize your first lands.
        </div>

        <div id="territoryList" style="margin-top:8px;display:flex;flex-direction:column;gap:6px;">
          <!-- Filled by render() with cards for each territory -->
        </div>
      </div>
    </section>


<!-- STATS -->
    <section class="card view" data-view="stats" hidden>
      <div class="sectionTitle"><span>Stats</span><span><b>Geek mode</b></span></div>
      <div class="cardBody">
        <table class="table" aria-label="All stats">
          <tbody id="statsTable"></tbody>
        </table>
        <div class="row2">
          <button class="smallBtn" id="btnExport">
            <div class="t">Copy Save</div>
            <div class="d">Copies JSON save to clipboard.</div>
          </button>
          <button class="smallBtn" id="btnReset">
            <div class="t" style="color:var(--danger);">Reset Save</div>
            <div class="d">Erase local save on this device.</div>
          </button>
        </div>
      </div>
    </section>

    <div class="toast" id="toast">Saved.</div>
  </main>

  <nav class="tabbar" aria-label="Sections">
    <button class="tab active" data-go="village"><span class="dot"></span>Village</button>
    <button class="tab" data-go="legion"><span class="dot"></span>‚öîÔ∏è</button>
<button class="tab" data-go="temple"><span class="dot"></span>Temple</button>
    <button class="tab" data-go="land"><span class="dot"></span>Land</button>
    <button class="tab" data-go="stats"><span class="dot"></span>Stats</button>
  </nav>

<script>
(() => {
  "use strict";

  const $ = (q, el=document)=> el.querySelector(q);
  const $$ = (q, el=document)=> Array.from(el.querySelectorAll(q));
  const clamp = (n,min,max)=> Math.max(min, Math.min(max,n));
  const rnd = (a,b)=> Math.floor(Math.random()*(b-a+1))+a;
  const chance = (p)=> Math.random() < p;

  const STORAGE_KEY = "roman_denarii_land_loop_villagecap_v14_save";

  const unlock = {
    legion: 0,
    temple: 0,
    
    
  };

  // Define the title progression and the renown required to reach each rank.
  //
  // The original thresholds allowed players to race through the early ranks too
  // quickly, which in turn unlocked tougher battle tiers before they had
  // enough warriors. To slow early progression and make rank‚Äëups feel like
  // meaningful milestones, the renown requirements have been increased.
  // Each threshold below (except the starting Elder rank) is roughly
  // twice the former value. This keeps later titles at a similar cadence
  // while forcing players to invest more in early renown before the next
  // tier of enemies appears.
  const titles = [
    // Tier 1 ‚Äî Intra‚ÄëVillage Prestige
    { name: "Elder", need: 0 },
    { name: "Respected Elder", need: 300 },    // 150√ó2 ‚Üí 300
    { name: "Clan Speaker", need: 700 },        // 350√ó2 ‚Üí 700
    { name: "Council Elder", need: 1200 },      // 600√ó2 ‚Üí 1200
    { name: "First Elder", need: 1800 },        // 900√ó2 ‚Üí 1800

    // Tier 2 ‚Äî Clan Leadership
    { name: "Patriarch/Matriarch", need: 2600 }, // 1300√ó2 ‚Üí 2600
    { name: "High Patriarch", need: 3600 },      // 1800√ó2 ‚Üí 3600
    { name: "Great Patriarch", need: 4800 },     // 2400√ó2 ‚Üí 4800
    { name: "Clan Warden", need: 6200 },         // 3100√ó2 ‚Üí 6200
    { name: "Clan Protector", need: 7800 },      // 3900√ó2 ‚Üí 7800

    // Tier 3 ‚Äî Tribal Influence
    { name: "Village Chief", need: 9600 },       // 4800√ó2 ‚Üí 9600
    { name: "Senior Chief", need: 11600 },      // 5800√ó2 ‚Üí 11600
    { name: "Paramount Chief", need: 13800 },   // 6900√ó2 ‚Üí 13800
    { name: "Tribal Speaker", need: 16200 },    // 8100√ó2 ‚Üí 16200
    { name: "War Chief", need: 18800 },         // 9400√ó2 ‚Üí 18800
    { name: "Peace Chief", need: 21600 },       // 10800√ó2 ‚Üí 21600

    // Tier 4 ‚Äî Confederation Level
    { name: "High Chief", need: 24600 },       // 12300√ó2 ‚Üí 24600
    { name: "Warlord", need: 28000 },          // 14000√ó2 ‚Üí 28000
    { name: "Lawgiver", need: 32000 },         // 16000√ó2 ‚Üí 32000
    { name: "First Magistrate", need: 36600 }, // 18300√ó2 ‚Üí 36600
    { name: "Sacred Chief", need: 41800 },      // 20900√ó2 ‚Üí 41800
    { name: "Lord of Clans", need: 47600 },     // 23800√ó2 ‚Üí 47600

    // Tier 5 ‚Äî Protoking / Chiefdom‚ÄëState
    { name: "Protector of the People", need: 54000 }, // 27000√ó2 ‚Üí 54000
    { name: "Heir of the Ancestors", need: 61000 },   // 30500√ó2 ‚Üí 61000
    { name: 'Princeps ("First Among Equals")', need: 68800 }, // 34400√ó2 ‚Üí 68800
    { name: "Rex Designatus", need: 77400 },   // 38700√ó2 ‚Üí 77400
    { name: "High Lord", need: 87000 },        // 43500√ó2 ‚Üí 87000
    { name: "Sovereign Chief", need: 97600 },  // 48800√ó2 ‚Üí 97600

    // Tier 6 ‚Äî Kingship
    { name: "King (Rex)", need: 110000 },      // 55000√ó2 ‚Üí 110000
    { name: "High King", need: 124000 },       // 62000√ó2 ‚Üí 124000
    { name: "Divine King", need: 140000 }      // 70000√ó2 ‚Üí 140000
  ];

  const defaultState = () => ({
    created: Date.now(),
    gold: 18,
    renown: 0,
    power: 6,

    // village economy
    tribute: 1,
    farmCount: 0,
    villaCount: 0,
    hutCount: 0,

    // legion
    warriors: 0,    legion: 0,  // derived strength (kept for compatibility)
    battlesWon: 0,

    // upkeep tracking
    unpaidUpkeepSeconds: 0,
    lastUpkeepWarnAt: 0,

    // land & politics
    land: 0,
    
    landAgriculture: 0,
    landMilitary: 0,
    landHousing: 0,
    landGovernance: 0,

    // NEW: named territories captured from battles
    controlledRegions: [],
// village capacity
    population: 0,          // total settlers (includes milites)
    populationUsed: 0,      // milites using population (kept for compatibility)
    settlerProg: 0,         // fractional settlers progress

    // temple / prestige
    faith: 0,
    crowns: 0,
    buffUntil: 0,
    blessReadyAt: 0,

    // decrees from renown
    decrees: 0,

    // renown soft-tech progression
    renownPerkLevel: 0,
    lastTap: 0,
    lifetimeGold: 0,
    lifetimeRenown: 0,
    rankIdx: 0,

    tapsSinceCashout: 0,
    cashoutBanked: 0,

    // objectives
    objectives: null,
    objStreak: 0,

    // burst events
    feverUntil: 0,
    objDoubleUntil: 0,

    // temp buffs
    prosperUntil: 0,

    // prestige meta
    ascends: 0,
    bestStreak: 0,
    biggestCashout: 0,
    lastSettlerToastAt: 0,

    // legion hidden state
    legionMorale: 1,
    legionXp: 0,

    // identity
    playerName: "",
    introBattleDone: 0,
  });

  function normalizeState(state){
    const d = defaultState();
    if(!state || typeof state !== "object") return d;

    // Merge with defaults and coerce numbers safely
    for(const k of Object.keys(d)){
      if(!(k in state)) state[k] = d[k];
      if(typeof d[k] === "number"){
        state[k] = Number(state[k]);
        if(!Number.isFinite(state[k])) state[k] = d[k];
      }
    }

    // --- Territory migration (old saves) ---
    if(!Array.isArray(state.controlledRegions)){
      state.controlledRegions = [];
    }
// If this is an old save with land > 0 but no territories yet,
    // backfill with generic ‚ÄúClaimed Land‚Äù entries so counts stay in sync.
    if(state.controlledRegions.length === 0){
      const legacyLand = Number(state.land) || 0;
      const cap = Math.min(legacyLand, 40); // don‚Äôt spam thousands of rows
      for(let i=0;i<cap;i++){
        state.controlledRegions.push({
          id: "legacy-"+i,
          name: "Claimed Land",
          tier: 1,
          summary: "Territory claimed before the territory update."
        });
      }
    }
    return state;
  }

  let S = normalizeState(load()) || defaultState();
  // --- Population migration / compatibility ---
  // population = total settlers (civilians + milites). populationUsed tracks milites.
  if(typeof S.population !== "number") S.population = Math.max(0, S.populationUsed||0, S.warriors||0);
  if(typeof S.settlerProg !== "number") S.settlerProg = 0;
  if(typeof S.populationUsed !== "number") S.populationUsed = 0;
  // Ensure milites never exceed population
  if((S.warriors||0) > (S.population||0)) S.warriors = S.population;
  S.populationUsed = S.warriors;

  // If localStorage is empty/evicted, try IndexedDB recovery (especially on iPhone).
  recoverSaveFromIDB();
  let currentView = "village";

    // --- Robust saving on iPhone (localStorage + IndexedDB fallback) ---
  // iOS Safari can evict localStorage (especially for file:// or low-storage situations).
  // We write to BOTH localStorage and IndexedDB, and we can recover from IndexedDB if localStorage is empty.
  const SAVE_DB_NAME = "roman_kingdom_save_db_v1";
  const SAVE_STORE = "kv";

  function isStandalone(){
    try{
      return (window.matchMedia && window.matchMedia("(display-mode: standalone)").matches) || (window.navigator && window.navigator.standalone);
    }catch(e){ return false; }
  }

  function openSaveDB(){
    return new Promise((resolve, reject)=>{
      try{
        const req = indexedDB.open(SAVE_DB_NAME, 1);
        req.onupgradeneeded = ()=>{ req.result.createObjectStore(SAVE_STORE); };
        req.onsuccess = ()=> resolve(req.result);
        req.onerror = ()=> reject(req.error);
      }catch(e){ reject(e); }
    });
  }

  async function idbSet(key, value){
    try{
      const db = await openSaveDB();
      await new Promise((resolve, reject)=>{
        const tx = db.transaction(SAVE_STORE, "readwrite");
        tx.objectStore(SAVE_STORE).put(value, key);
        tx.oncomplete = ()=> resolve(true);
        tx.onerror = ()=> reject(tx.error);
      });
      db.close();
    }catch(e){}
  }

  async function idbGet(key){
    try{
      const db = await openSaveDB();
      const val = await new Promise((resolve, reject)=>{
        const tx = db.transaction(SAVE_STORE, "readonly");
        const req = tx.objectStore(SAVE_STORE).get(key);
        req.onsuccess = ()=> resolve(req.result ?? null);
        req.onerror = ()=> reject(req.error);
      });
      db.close();
      return val;
    }catch(e){
      return null;
    }
  }

  function save(silent=false){
    const payload = JSON.stringify(S);
    try{ localStorage.setItem(STORAGE_KEY, payload); }catch(e){}
    // IndexedDB write (best-effort, async)
    idbSet(STORAGE_KEY, payload);
    if(!silent) toast("Saved");
  }

  function load(){
    // Fast path: localStorage
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      if(raw){
        try{ return JSON.parse(raw); }catch(e){}
      }
    }catch(e){}
    // Slow path: handled asynchronously after first render
    return null;
  }

  async function recoverSaveFromIDB(){
    const raw = await idbGet(STORAGE_KEY);
    if(!raw) return false;
    try{
      const parsed = JSON.parse(raw);
      S = normalizeState(parsed);
      try{ localStorage.setItem(STORAGE_KEY, raw); }catch(e){}
      toast("Save recovered");
      render();
      return true;
    }catch(e){
      return false;
    }
  }

// --- iPhone/iOS reliability: persistent storage + autosave + lifecycle saves ---
// iOS Safari can aggressively discard tabs; we save often and also on page hide.
(function setupReliableSaves(){
  // Ask for "persistent" storage when available (reduces eviction on some browsers)
  try{
    if(navigator.storage && navigator.storage.persist){
      navigator.storage.persist().then(()=>{}).catch(()=>{});
    }
  }catch(e){}

  // Detect whether localStorage is actually usable (Private Browsing / restrictions can break it)
  function storageWritable(){
    try{
      const k = STORAGE_KEY + "__probe";
      localStorage.setItem(k, "1");
      localStorage.removeItem(k);
      return true;
    }catch(e){
      return false;
    }
  }

  // iPhone tip: if you're running from file:// and NOT installed to Home Screen,
  // iOS can reset storage when you leave the tab. Warn once.
  try{
    const fromFile = (location && location.protocol === "file:");
    if(fromFile && !isStandalone()){
      setTimeout(()=>toast("üìå iPhone tip: install to Home Screen (Share ‚Üí Add to Home Screen) and launch from the icon for reliable saving."), 650);
    }
  }catch(e){}

  // If storage isn't writable, warn once so the user knows why resets happen.
  try{
    if(!storageWritable()){
      // Keep it subtle; also avoid blocking the game.
      setTimeout(()=>toast("‚ö†Ô∏è Saving is blocked in this mode (iPhone Private Browsing / restrictions). Open in Safari normally or add to Home Screen."), 400);
    }
  }catch(e){}

  // Debounced save helper (avoids spamming writes during rapid taps)
  let _svT = 0;
  window.scheduleSave = function scheduleSave(){
    clearTimeout(_svT);
    _svT = setTimeout(()=>{ try{ save(true); }catch(e){} }, 250);
  };

  // Autosave: iOS may kill the page without firing beforeunload reliably.
  // Keep it lightweight and frequent.
  setInterval(()=>{ try{ save(true); }catch(e){} }, 2500);

  // Save when the page is being backgrounded / suspended.
  function flushSave(){
    try{ save(true); }catch(e){}
  }
  document.addEventListener("visibilitychange", ()=>{
    if(document.visibilityState === "hidden") flushSave();
  });
  window.addEventListener("pagehide", flushSave, {capture:true});
  window.addEventListener("beforeunload", flushSave, {capture:true});
})();


  function toast(text){
    const t = $("#toast");
    t.textContent = text;
    t.classList.add("show");
    clearTimeout(toast._tm);
    toast._tm = setTimeout(()=>t.classList.remove("show"), 900);
  }

  function logLine(text, tone="") {
  const log = $("#log");
  if (!log) return;

  const wrap = document.createElement("div");
  wrap.className = "log-entry";

  const ts = new Date();
  const stamp =
    `${ts.getHours().toString().padStart(2,"0")}:` +
    `${ts.getMinutes().toString().padStart(2,"0")}`;

  // Time column
  const timeEl = document.createElement("span");
  timeEl.className = "log-time";
  timeEl.textContent = stamp;

  // Message column
  const msgEl = document.createElement("span");
  if (tone === "good" || tone === "bad" || tone === "warn") {
    msgEl.classList.add(tone);
  }
  msgEl.textContent = text;

  wrap.appendChild(timeEl);
  wrap.appendChild(msgEl);

  // Prepend newest entry at the top
  if (log.firstChild) {
    log.insertBefore(wrap, log.firstChild);
  } else {
    log.appendChild(wrap);
  }

  // Keep only the latest 4 entries
  while (log.childNodes.length > 4) {
    log.removeChild(log.lastChild);
  }

  // Always show top (newest) entries
  log.scrollTo({
    top: 0,
    behavior: "smooth"
  });
}
  // ---- Intro / naming flow ----
  let introDemoGold = 0;

  function updatePlayerNameHud(){
    const pill = $("#playerPill");
    const nameEl = $("#playerNameHud");
    if(!pill || !nameEl) return;
    if(S.playerName && S.playerName.trim()){
      nameEl.textContent = S.playerName.trim();
      pill.style.display = "inline-block";
    }else{
      pill.style.display = "none";
    }
  }

  function maybeShowIntro(){
    const overlay = $("#introOverlay");
    if(!overlay) return;

    const nameInput = $("#introNameInput");
    const startBtn  = $("#introStartBtn");
    const demoBtn   = $("#introTapBtn");
    const demoGold  = $("#introDemoGold");
    const introHint = $("#introHint");

    // If player already has a name, skip intro.
    if(S.playerName && S.playerName.trim()){
      overlay.setAttribute("hidden","hidden");
      updatePlayerNameHud();
      return;
    }

    // Show overlay
    overlay.removeAttribute("hidden");

    // Wire once
    if(demoBtn && !demoBtn._wired){
      demoBtn._wired = true;
      demoBtn.addEventListener("click", (e)=>{
        introDemoGold += 1;
        if(demoGold) demoGold.textContent = introDemoGold;
        const rect = e.currentTarget.getBoundingClientRect();
        sparkAt(rect.left + rect.width*0.75, rect.top + rect.height*0.35, 0.55);
      });
    }

    if(nameInput && !nameInput._wired){
      nameInput._wired = true;
      nameInput.addEventListener("input", ()=>{
        const raw = nameInput.value || "";
        const trimmed = raw.trim();
        S.playerName = trimmed;
        const ok = trimmed.length >= 1;
        if(startBtn){
          startBtn.disabled = !ok;
        }
        if(introHint){
          introHint.textContent = ok ? "Tap to enter the village" : "Pick a name to continue";
        }
      });
    }

    if(startBtn && !startBtn._wired){
      startBtn._wired = true;
      startBtn.addEventListener("click", ()=>{
        if(!S.playerName || !S.playerName.trim()) return;
        overlay.setAttribute("hidden","hidden");
        updatePlayerNameHud();
        if(typeof scheduleSave === "function") scheduleSave();
        // Intro flavour: invasion hook instead of generic welcome
        toast("Your village is being invaded!");
        // Trigger intro battle once, right after the player enters the village
        if(!S.introBattleDone && typeof startIntroBattle === "function"){
          setTimeout(()=> startIntroBattle(), 650);
        }
      });
    }
  }


  function sparkAt(x,y,gold=0.25){
    const n = 6;
    // gold: 0..1. Higher = warmer, brighter coins.
    const g = clamp(gold, 0, 1);
    const bright = 1 + g*0.45;     // 1.00 .. 1.45
    const sat    = 1 + g*1.10;     // 1.00 .. 2.10
    const hue    = g*12;           // subtle warm shift
    const glowA  = 0.10 + g*0.55;  // glow alpha
    for(let i=0;i<n;i++){
      const s = document.createElement("div");
      s.className = "spark";
      s.style.left = x+"px";
      s.style.top  = y+"px";
      s.style.setProperty("--dx", `${rnd(-90,90)}px`);
      s.style.setProperty("--dy", `${rnd(-140,-40)}px`);
      // Tint coins based on intensity (crit/cashout/jackpot)
      s.style.filter =
        `drop-shadow(0 10px 18px rgba(0,0,0,.35)) `+
        `drop-shadow(0 0 ${8 + g*18}px rgba(255, 215, 120, ${glowA})) `+
        `hue-rotate(${hue}deg) saturate(${sat}) brightness(${bright})`;
      document.body.appendChild(s);
      setTimeout(()=> s.remove(), 700);
    }
  }

  // ---- Scalind + rates (make it LAST longer) ----
  function crownMult(){
    // very strong long-term scaling, but gradual
    return 1 + (S.crowns * 0.12);
  }
  function landMult(){
    return 1 + (S.land * 0.05);
  }
function decreeMult(){
    return 1 + (S.decrees * 0.07);
  }

  // --- Land allocation (plots) hybrid system ---
  function totalLandPlots(){
    const land = S.land || 0;
    if(land <= 0) return 0;
    // Hybrid: soft diminishing (sqrt) scaled, on top of tier-based land rewards.
    return Math.floor(Math.sqrt(land) * 4);
  }
  function usedLandPlots(){
    return (S.landAgriculture||0) + (S.landMilitary||0) + (S.landHousing||0) + (S.landGovernance||0);
  }
  function freeLandPlots(){
    return Math.max(0, totalLandPlots() - usedLandPlots());
  }

  function landAllocIncomeMult(){
    return 1 + (S.landAgriculture||0) * 0.04;
  }
  function landAllocPopMult(){
    return 1 + (S.landHousing||0) * 0.04;
  }
  function landAllocLegionMult(){
    const m = S.landMilitary||0;
    if(m <= 0) return 1;
    // Diminishing returns + cap: strong early, but not runaway.
    const bonus = 0.025 * Math.sqrt(m); // e.g. m=16 ‚Üí +10%, m=64 ‚Üí +20%
    return 1 + Math.min(bonus, 0.75);   // cap at +75% strength
  }
  function warriorUpkeepPerSec(){
    const w = S.warriors || 0;
    if(w <= 0) return 0;

    // Base upkeep per warrior per second.
    // Slightly higher, so mid‚Äësized armies noticeably bite into income,
    // but still something you can sustain with a healthy village.
    let per = 0.028;

    // Agriculture + villas + land (Agriculture) soften upkeep.
    const foodRelief =
      1 - Math.min(
        0.45,
        (S.farmCount * 0.0025) +
        (S.villaCount * 0.0035) +
        ((S.landAgriculture || 0) * 0.011)
      );

    // Military plots also make milites cheaper to maintain.
    const milRelief =
      1 - Math.min(0.30, (S.landMilitary || 0) * 0.0065);

    let mult = foodRelief * milRelief;

    // Very large armies are disproportionately expensive to keep in the field.
    if(w > 60){
      mult *= 1 + Math.log10(w - 50) * 0.35;
    }

    // Never let upkeep vanish completely.
    mult = Math.max(0.45, mult);

    let upkeep = w * per * mult;

    // If your economy is tiny but you somehow have a big army,
    // scale upkeep down a bit so it doesn't instantly implode new runs.
    const inc = incomePerSec();
    if(inc > 0){
      const maxShare = 0.85; // upkeep can eat at most 85% of steady income
      upkeep = Math.min(upkeep, inc * maxShare);
    }

    return upkeep;
  }

  function landAllocRenownMult(){
    const g = S.landGovernance||0;
    if(g <= 0) return 1;
    // Diminishing returns + cap so renown can't spiral.
    const bonus = 0.02 * Math.sqrt(g);  // e.g. g=25 ‚Üí +10%, g=100 ‚Üí +20%
    return 1 + Math.min(bonus, 0.6);    // cap at +60% renown
  }

  function incomePerSec(){
    let farm = S.farmCount * 0.75;
    // Soft cap: without land, extra farms become less effective (nudges you into the land loop)
    const softCap = 6 + (S.land * 2);
    if(S.farmCount > softCap){
      farm *= Math.max(0.60, 1 - (S.farmCount - softCap) * 0.04);
    }
    const villa = S.villaCount * 3.0;
    const base = farm + villa;
    const prosper = (Date.now() < (S.prosperUntil||0)) ? 1.5 : 1.0;
    // Land allocation (Agriculture) further boosts income.
    return base * landMult() * landAllocIncomeMult() * decreeMult() * crownMult() * prosper;
  }

  // --- Migration rate (settlers per second) ---
  // Kept in one place so UI and simulation stay consistent.
  
  // --- Migration rate (settlers per second) ---
  // Includes infinite scaling from tap streak (logarithmic, no hard cap)
  function migrationPerSec(){
    // How fast new settlers join per second.
    // Tweaked so that new people visibly arrive as you build up,
    // especially once you have a few farms/villas online.
    const prosper = (Date.now() < (S.prosperUntil||0)) ? 1.5 : 1.0;

    const baseRate = 0.08; // baseline trickle
    const incomeRate = clamp(incomePerSec()/140, 0, 0.35);
    const sizeRate =
      (S.villaCount||0)*0.010 +
      (S.farmCount||0)*0.0045 +
      (S.hutCount||0)*0.0045;
    const landRate = (S.land||0)*0.0018;

    // üî• Streak-based attraction (infinite, diminishing returns)
    const streak = Math.max(1, S.streak||1);
    const streakMult = 1 + Math.log10(streak) * 0.30;

    // üåü Renown perk: famous realms attract more settlers.
    const ren = S.renown || 0;
    const renMult = 1 + Math.log10(1 + ren/200) * 0.25;

    const raw = (baseRate + incomeRate + sizeRate + landRate)
      * prosper
      * streakMult
      * renMult;

    // Upper cap slightly higher so mid‚Äëgame villages actually fill.
    return clamp(raw, 0.03, 1.4);
  }


  // ---- Village Economy Loop ----
  function populationCap(){
    // Farms provide housing; villas attract families; land improves efficiency.
    // Simple + readable:
    // - Each hut supports 3 people
    // - Each farm supports 5 people
    // - Each villa supports 14 people (bigger households)
    // - Land boosts overall capacity a bit more
    const base = (S.hutCount * 3) + (S.farmCount * 5) + (S.villaCount * 14);
    return Math.floor(base * (1 + S.land * 0.10) * landAllocPopMult());
  }
  function hasVillageCapacity(){
    return (S.population || 0) < populationCap();
  }

  function applyStreak(){
    const now = Date.now();
    const prev = S.streak || 0;
    if(now - (S.lastTap || 0) <= 2600){
      // Infinite streak: no upper cap, just timing-based
      S.streak = prev + 1;
    }else{
      S.streak = 1;
    }
    S.lastTap = now;

    // Objective: reach a streak threshold (counts when you hit/hold it)
    bumpObjective("streak", Math.max(0, S.streak - (prev||0)));

    // Track best streak across all runs
    if(!S.bestStreak || S.streak > S.bestStreak){
      S.bestStreak = S.streak;
    }

    // Streak milestone bursts every 25 taps
    if(S.streak > 0 && S.streak % 25 === 0){
      maybeBurst("streak");
    }
  }

  function critChance(){
    // faith boosts crit chance; buff doubles it
    const base = 0.08 + clamp(S.faith / 12000, 0, 0.18);
    const boosted = isBuffed() ? base * 1.9 : base;
    return clamp(boosted, 0.06, 0.30);
  }

  function isBuffed(){ return Date.now() < S.buffUntil; }

  function tapGain(){
    const base = S.tribute + rankTributeBonus(titleInfo().idx) + rushBonus();
    const streakBonus = 1 + Math.min(0.35, (S.streak-1)*0.018);
    const pMult = landMult() * decreeMult() * crownMult();
    const feverMult = (Date.now() < (S.feverUntil || 0)) ? 2.5 : 1;
    const crit = chance(critChance());
    const gain = Math.round(base * streakBonus * pMult * feverMult * (crit ? 2 : 1));
    return { gain, crit };
  }


  // ---- Streak timer + Gold Rush ----
  const STREAK_WINDOW_MS = 3000;

  function streakTimeLeftMs(){
    if(!S.lastTap) return STREAK_WINDOW_MS;
    return Math.max(0, STREAK_WINDOW_MS - (Date.now() - S.lastTap));
  }

  function expireStreakIfNeeded(){
    // Don‚Äôt let the streak expire while a defensive popup is on screen
    if(window.defenceOverlayOpen) return;

    if(S.streak > 1 && S.lastTap && (Date.now() - S.lastTap) > STREAK_WINDOW_MS){
      S.streak = 1;
    }
  }

  function rushBonus(){
    // Infinite "gold rush" growth: every 10 streak adds a small flat bonus to tap base.
    // Slow enough to not break balance, but feels endless.
    const milestones = Math.max(0, Math.floor((S.streak - 1) / 10));
    return Math.round(milestones * 0.15 * 10) / 10; // +0.15 per milestone, rounded to 0.1
  }


  // ---- Costs (ramp hard so it isn't beaten in 2 mins) ----
  function costHut(){
    // Cheap early housing that becomes gradually more expensive
    const n = S.hutCount||0;
    return Math.floor(60 * Math.pow(1.22, n));
  }

  function costFarm(){
    return 320;
  }
  function costVilla(){
    return 5200;
  }


  function recruitCost(){
    return 220;
  }

  function recruitStrengthGain(){
    return 6;
  }

    function recalcLegionStrength(){
    // Strength derived from warriors only (simple + readable)
    const per = 6;
    // Land allocation (Military) further boosts legion strength.
    S.legion = Math.round(S.warriors * per * landAllocLegionMult());
  }


  
  // --- Battles  ---
  const BATTLE_SETS = [
    [
      { label:"Break Up Farm Brawl", enemyMin:8, enemyMax:14 },
      { label:"Defend Stray Herd", enemyMin:6, enemyMax:11 },
      { label:"Drive Off Rustlers", enemyMin:6, enemyMax:12 },
      { label:"Feud at the Wall", enemyMin:5, enemyMax:10 }
    ], // Elder
    [
      { label:"Break Up Farm Brawl", enemyMin:15, enemyMax:15 },
      { label:"Defend Stray Herd", enemyMin:15, enemyMax:15 },
      { label:"Drive Off Rustlers", enemyMin:10, enemyMax:20 },
      { label:"Feud at the Wall", enemyMin:10, enemyMax:20 }
    ], // Respected Elder
    [
      { label:"Break Up Farm Brawl", enemyMin:20, enemyMax:25 },
      { label:"Defend Stray Herd", enemyMin:20, enemyMax:25 },
      { label:"Drive Off Rustlers", enemyMin:15, enemyMax:25 },
      { label:"Feud at the Wall", enemyMin:15, enemyMax:25 }
    ], // Clan Speaker
    [
      { label:"Break Up Farm Brawl", enemyMin:30, enemyMax:35 },
      { label:"Defend Stray Herd", enemyMin:25, enemyMax:35 },
      { label:"Drive Off Rustlers", enemyMin:20, enemyMax:35 },
      { label:"Feud at the Wall", enemyMin:20, enemyMax:35 }
    ], // Council Elder
    [
      { label:"Break Up Farm Brawl", enemyMin:35, enemyMax:40 },
      { label:"Defend Stray Herd", enemyMin:30, enemyMax:40 },
      { label:"Drive Off Rustlers", enemyMin:30, enemyMax:40 },
      { label:"Feud at the Wall", enemyMin:25, enemyMax:40 }
    ], // First Elder
    [
      { label:"Clan Border Skirmish", enemyMin:30, enemyMax:35 },
      { label:"Retribution Raid", enemyMin:30, enemyMax:35 },
      { label:"Defend Ancestral Fields", enemyMin:25, enemyMax:40 },
      { label:"Honor Retinue Clash", enemyMin:25, enemyMax:40 }
    ], // Patriarch/Matriarch
    [
      { label:"Clan Border Skirmish", enemyMin:45, enemyMax:50 },
      { label:"Retribution Raid", enemyMin:40, enemyMax:55 },
      { label:"Defend Ancestral Fields", enemyMin:35, enemyMax:55 },
      { label:"Honor Retinue Clash", enemyMin:30, enemyMax:60 }
    ], // High Patriarch
    [
      { label:"Clan Border Skirmish", enemyMin:60, enemyMax:70 },
      { label:"Retribution Raid", enemyMin:55, enemyMax:70 },
      { label:"Defend Ancestral Fields", enemyMin:45, enemyMax:70 },
      { label:"Honor Retinue Clash", enemyMin:40, enemyMax:75 }
    ], // Great Patriarch
    [
      { label:"Clan Border Skirmish", enemyMin:75, enemyMax:85 },
      { label:"Retribution Raid", enemyMin:70, enemyMax:85 },
      { label:"Defend Ancestral Fields", enemyMin:60, enemyMax:90 },
      { label:"Honor Retinue Clash", enemyMin:50, enemyMax:90 }
    ], // Clan Warden
    [
      { label:"Clan Border Skirmish", enemyMin:95, enemyMax:100 },
      { label:"Retribution Raid", enemyMin:80, enemyMax:105 },
      { label:"Defend Ancestral Fields", enemyMin:70, enemyMax:105 },
      { label:"Honor Retinue Clash", enemyMin:60, enemyMax:105 }
    ], // Clan Protector
    [
      { label:"Village Raid", enemyMin:80, enemyMax:90 },
      { label:"Hill Ambush", enemyMin:75, enemyMax:95 },
      { label:"Border River Battle", enemyMin:70, enemyMax:105 },
      { label:"Seasonal Warband Clash", enemyMin:60, enemyMax:110 }
    ], // Village Chief
    [
      { label:"Village Raid", enemyMin:110, enemyMax:120 },
      { label:"Hill Ambush", enemyMin:100, enemyMax:130 },
      { label:"Border River Battle", enemyMin:90, enemyMax:135 },
      { label:"Seasonal Warband Clash", enemyMin:80, enemyMax:140 }
    ], // Senior Chief
    [
      { label:"Village Raid", enemyMin:140, enemyMax:155 },
      { label:"Hill Ambush", enemyMin:125, enemyMax:160 },
      { label:"Border River Battle", enemyMin:110, enemyMax:165 },
      { label:"Seasonal Warband Clash", enemyMin:95, enemyMax:170 }
    ], // Paramount Chief
    [
      { label:"Village Raid", enemyMin:170, enemyMax:190 },
      { label:"Hill Ambush", enemyMin:150, enemyMax:195 },
      { label:"Border River Battle", enemyMin:130, enemyMax:200 },
      { label:"Seasonal Warband Clash", enemyMin:110, enemyMax:200 }
    ], // Tribal Speaker
    [
      { label:"Village Raid", enemyMin:200, enemyMax:225 },
      { label:"Hill Ambush", enemyMin:180, enemyMax:225 },
      { label:"Border River Battle", enemyMin:155, enemyMax:230 },
      { label:"Seasonal Warband Clash", enemyMin:130, enemyMax:230 }
    ], // War Chief
    [
      { label:"Village Raid", enemyMin:235, enemyMax:255 },
      { label:"Hill Ambush", enemyMin:205, enemyMax:260 },
      { label:"Border River Battle", enemyMin:175, enemyMax:260 },
      { label:"Seasonal Warband Clash", enemyMin:145, enemyMax:260 }
    ], // Peace Chief
    [
      { label:"Subdue Rebel Clan", enemyMin:200, enemyMax:220 },
      { label:"Assault Palisaded Hamlet", enemyMin:185, enemyMax:240 },
      { label:"Battle at Council Field", enemyMin:170, enemyMax:260 },
      { label:"Sacred Grove Showdown", enemyMin:155, enemyMax:280 }
    ], // High Chief
    [
      { label:"Subdue Rebel Clan", enemyMin:290, enemyMax:320 },
      { label:"Assault Palisaded Hamlet", enemyMin:260, enemyMax:335 },
      { label:"Battle at Council Field", enemyMin:235, enemyMax:355 },
      { label:"Sacred Grove Showdown", enemyMin:205, enemyMax:370 }
    ], // Warlord
    [
      { label:"Subdue Rebel Clan", enemyMin:380, enemyMax:420 },
      { label:"Assault Palisaded Hamlet", enemyMin:340, enemyMax:435 },
      { label:"Battle at Council Field", enemyMin:295, enemyMax:445 },
      { label:"Sacred Grove Showdown", enemyMin:255, enemyMax:460 }
    ], // Lawgiver
    [
      { label:"Subdue Rebel Clan", enemyMin:470, enemyMax:515 },
      { label:"Assault Palisaded Hamlet", enemyMin:415, enemyMax:530 },
      { label:"Battle at Council Field", enemyMin:360, enemyMax:540 },
      { label:"Sacred Grove Showdown", enemyMin:305, enemyMax:555 }
    ], // First Magistrate
    [
      { label:"Subdue Rebel Clan", enemyMin:560, enemyMax:615 },
      { label:"Assault Palisaded Hamlet", enemyMin:490, enemyMax:625 },
      { label:"Battle at Council Field", enemyMin:425, enemyMax:635 },
      { label:"Sacred Grove Showdown", enemyMin:355, enemyMax:645 }
    ], // Sacred Chief
    [
      { label:"Subdue Rebel Clan", enemyMin:650, enemyMax:715 },
      { label:"Assault Palisaded Hamlet", enemyMin:570, enemyMax:720 },
      { label:"Battle at Council Field", enemyMin:485, enemyMax:730 },
      { label:"Sacred Grove Showdown", enemyMin:405, enemyMax:735 }
    ], // Lord of Clans
    [
      { label:"Crush Tax Revolt", enemyMin:500, enemyMax:550 },
      { label:"Punish Defiant Chief", enemyMin:460, enemyMax:600 },
      { label:"Cross-Valley Incursion", enemyMin:425, enemyMax:650 },
      { label:"Siege Border Stronghold", enemyMin:385, enemyMax:700 }
    ], // Protector of the People
    [
      { label:"Crush Tax Revolt", enemyMin:860, enemyMax:945 },
      { label:"Punish Defiant Chief", enemyMin:770, enemyMax:990 },
      { label:"Cross-Valley Incursion", enemyMin:685, enemyMax:1040 },
      { label:"Siege Border Stronghold", enemyMin:595, enemyMax:1085 }
    ], // Heir of the Ancestors
    [
      { label:"Crush Tax Revolt", enemyMin:1220, enemyMax:1340 },
      { label:"Punish Defiant Chief", enemyMin:1085, enemyMax:1385 },
      { label:"Cross-Valley Incursion", enemyMin:945, enemyMax:1425 },
      { label:"Siege Border Stronghold", enemyMin:810, enemyMax:1470 }
    ], // Princeps ("First Among Equals")
    [
      { label:"Crush Tax Revolt", enemyMin:1580, enemyMax:1740 },
      { label:"Punish Defiant Chief", enemyMin:1395, enemyMax:1775 },
      { label:"Cross-Valley Incursion", enemyMin:1205, enemyMax:1815 },
      { label:"Siege Border Stronghold", enemyMin:1020, enemyMax:1855 }
    ], // Rex Designatus
    [
      { label:"Crush Tax Revolt", enemyMin:1940, enemyMax:2135 },
      { label:"Punish Defiant Chief", enemyMin:1705, enemyMax:2170 },
      { label:"Cross-Valley Incursion", enemyMin:1470, enemyMax:2205 },
      { label:"Siege Border Stronghold", enemyMin:1230, enemyMax:2240 }
    ], // High Lord
    [
      { label:"Crush Tax Revolt", enemyMin:2300, enemyMax:2530 },
      { label:"Punish Defiant Chief", enemyMin:2015, enemyMax:2560 },
      { label:"Cross-Valley Incursion", enemyMin:1730, enemyMax:2595 },
      { label:"Siege Border Stronghold", enemyMin:1445, enemyMax:2625 }
    ], // Sovereign Chief
    [
      { label:"Throne Claimant Rebellion", enemyMin:2000, enemyMax:2200 },
      { label:"Grand Campaign of Conquest", enemyMin:1845, enemyMax:2400 },
      { label:"Coalition War", enemyMin:1695, enemyMax:2600 },
      { label:"Storm the Rival Capital", enemyMin:1540, enemyMax:2800 }
    ], // King (Rex)
    [
      { label:"Throne Claimant Rebellion", enemyMin:4700, enemyMax:5170 },
      { label:"Grand Campaign of Conquest", enemyMin:4160, enemyMax:5315 },
      { label:"Coalition War", enemyMin:3620, enemyMax:5455 },
      { label:"Storm the Rival Capital", enemyMin:3080, enemyMax:5600 }
    ], // High King
    [
      { label:"Throne Claimant Rebellion", enemyMin:7400, enemyMax:8140 },
      { label:"Grand Campaign of Conquest", enemyMin:6475, enemyMax:8225 },
      { label:"Coalition War", enemyMin:5545, enemyMax:8315 },
      { label:"Final Divine Showdown", enemyMin:4620, enemyMax:8400 }
    ], // Divine King
  ];

  function battleTierFromTitleIdx(idx){
    if(idx <= 4) return 1;
    if(idx <= 9) return 2;
    if(idx <= 15) return 3;
    if(idx <= 21) return 4;
    if(idx <= 27) return 5;
    return 6;
  }

  // Narrative battle archetypes by tier (Hybrid: title tier √ó slot)
  // kind:
  //  - "skirmish"  ‚Üí never grants land
  //  - "feud"      ‚Üí may grant land at higher tiers
  //  - "field"     ‚Üí always territorial
  //  - "siege"     ‚Üí always territorial, heavier land

  
const BATTLE_ARCHETYPES = {
    1: [
      {
        label: "Drive Off the Ridge Herders",
        kind: "skirmish",
        short: "Border skirmish",
        flavour: "Clans test your borders with small herds."
      },
      {
        label: "Settle the Winter Grazing Feud",
        kind: "feud",
        short: "Grazing feud",
        flavour: "A boundary quarrel draws spears to the wall."
      },
      {
        label: "Seize the Lower Pastures",
        kind: "field",
        short: "Pasture field",
        flavour: "Hold the meadows that feed your village."
      },
      {
        label: "Enclose the Village Palisade",
        kind: "siege",
        short: "Village siege",
        flavour: "Timber walls decide who rules this place."
      }
    ],

    2: [
      {
        label: "Break the Spring Muster at the River Ford",
        kind: "skirmish",
        short: "River skirmish",
        flavour: "A rival clan gathers men where the road runs shallow."
      },
      {
        label: "Subdue the March-Lord of Senna",
        kind: "feud",
        short: "March feud",
        flavour: "A frontier lord refuses your voice in his valley."
      },
      {
        label: "Secure the Broad Valley of Ilma",
        kind: "field",
        short: "Valley field",
        flavour: "Levies muster along the slopes above Ilma."
      },
      {
        label: "Storm the Hill-Fort at Narrow Gate",
        kind: "siege",
        short: "Hill-fort siege",
        flavour: "One gate, one crest, and all the uplands follow."
      }
    ],

    3: [
      {
        label: "Scatter the League Scouts at Reed-Bank",
        kind: "skirmish",
        short: "League skirmish",
        flavour: "League riders test the strength of your watch."
      },
      {
        label: "Answer the League‚Äôs Tribute Demands",
        kind: "feud",
        short: "Tribute feud",
        flavour: "Merchants arrive with terms backed by spears."
      },
      {
        label: "Command the Valley of Three Rivers",
        kind: "field",
        short: "River-valley field",
        flavour: "Three valleys meet; whoever holds them sets the toll."
      },
      {
        label: "Break the Tribal Stronghold of Fen-Croft",
        kind: "siege",
        short: "Tribal siege",
        flavour: "A fen-ringed timber keep shelters your rivals."
      }
    ],

    4: [
      {
        label: "Intercept Confederation Riders",
        kind: "skirmish",
        short: "Confed skirmish",
        flavour: "Messengers race between confederate chiefs."
      },
      {
        label: "Punish the March Coalition‚Äôs Envoys",
        kind: "feud",
        short: "Coalition feud",
        flavour: "Envoys arrive under arms and speak as equals."
      },
      {
        label: "Contest the Confederation Granary Basin",
        kind: "field",
        short: "Granary field",
        flavour: "Grain stores and river land decide the winter."
      },
      {
        label: "Besiege the Confederation Citadel at River-Bend",
        kind: "siege",
        short: "Citadel siege",
        flavour: "A stone keep crowns the bend where two rivers meet."
      }
    ],

    5: [
      {
        label: "Test the Provincial Muster at Low-Ford",
        kind: "skirmish",
        short: "Provincial skirmish",
        flavour: "Provincial banners appear at the shallows."
      },
      {
        label: "Humiliate the Provincial Tax-Farmers",
        kind: "feud",
        short: "Tax feud",
        flavour: "Collectors return with short tribute and long complaints."
      },
      {
        label: "Reduce the Tributary Valley of Altar-Kings",
        kind: "field",
        short: "Tributary field",
        flavour: "Old altar-stones mark a valley that pays two masters."
      },
      {
        label: "Compel Submission of the Provincial Seat",
        kind: "siege",
        short: "Provincial siege",
        flavour: "The province‚Äôs officers shelter behind old walls."
      }
    ],

    6: [
      {
        label: "Scatter the Royal Scouts of the March",
        kind: "skirmish",
        short: "Royal skirmish",
        flavour: "The king‚Äôs riders taste the edge of your realm."
      },
      {
        label: "Defy the Royal Magistrate of the Cross-Road",
        kind: "feud",
        short: "Royal feud",
        flavour: "A royal judge arrives with laws and escorts."
      },
      {
        label: "Enforce Dominion over the River-Marches",
        kind: "field",
        short: "River-march field",
        flavour: "Whole marches decide whether to bow or bleed."
      },
      {
        label: "Take the Captaincy of the Tributary Citadel",
        kind: "siege",
        short: "Royal siege",
        flavour: "The garrison decides who truly rules this frontier."
      }
    ]
  };

  const FRONTIER_PRAENOMEN = [
    "Varro","Lucius","Hostor","Marus","Aulus","Caius","Secundus",
    "Tatius","Brennus","Florus","Silvanus","Drusus","Cassian"
  ];
  const FRONTIER_COGNOMEN = [
    "Tatius","Brennus","of Three Rivers","of the Fen","of the Ridge",
    "of Low-Ford","of Senna","of the March","of the Lower Valley",
    "of Reed-Bank","of Narrow Gate","of the Granary Basin"
  ];

  function sample(arr){
    return arr[Math.floor(Math.random() * arr.length)];
  }

  

  // House / faction identity by tier: early Italic ‚Üí later Roman-provincial
  const HOUSE_ROOTS_TRIBAL = [
    "Tasca","Verro","Serri","Caian","Varno","Tarru","Marro","Hostor","Silvan","Druso"
  ];
  const HOUSE_ROOTS_ROMAN = [
    "Domitia","Flaminia","Claudiana","Tarquitia","Valeria","Aemilia","Cornelia","Fabia"
  ];

  // Faction "classes" stay extremely short and minimal for card readability.
  const HOUSE_CLASSES_TRIBAL = [
    "Herders","Reivers","Rustlers","Spearmen","Youth"
  ];
  const HOUSE_CLASSES_MARCHER = [
    "Levies","Banners","Marchers","Retinue","Shieldmen"
  ];
  const HOUSE_CLASSES_ROMAN = [
    "Decurions","Procurators","Auxilia","Cohorts","Tribunes"
  ];

  function makeHouseIdentity(tier, kind){
    let roots, classes;
    if(tier <= 2){
      // Early Italic tribal: short clan-style roots and pastoral classes
      roots = HOUSE_ROOTS_TRIBAL;
      classes = HOUSE_CLASSES_TRIBAL;
    }else if(tier <= 4){
      // Marcher / levy era: same roots, more organised military classes
      roots = HOUSE_ROOTS_TRIBAL;
      classes = HOUSE_CLASSES_MARCHER;
    }else{
      // Late-game: mixture of Italic and Romanised houses with civic/military classes
      roots = Math.random() < 0.5 ? HOUSE_ROOTS_TRIBAL : HOUSE_ROOTS_ROMAN;
      classes = HOUSE_CLASSES_ROMAN;
    }

    const root = sample(roots);
    const cls  = sample(classes);
    const label = `${root} ‚Äî ${cls}`;
    return { root, cls, label };
  }


  function makeBattleContext(tier, slot, arch, baseDef){
    const kind = arch && arch.kind || "";
    // Generate a house / faction identity that persists per tier+slot until defeated.
    const house = makeHouseIdentity(tier, kind);
    const leader = house.label;
    const min = baseDef.enemyMin;
    const max = baseDef.enemyMax;
    const approx = (min === max) ? `${min}` : `${min}‚Äì${max}`;
    let doing;
    if(arch && arch.flavour){
      doing = arch.flavour;
    }else if(arch && arch.kind === "skirmish"){
      doing = "Their riders test the edges of your land.";
    }else if(arch && arch.kind === "feud"){
      doing = "A feud spills over your borders.";
    }else if(arch && arch.kind === "field"){
      doing = "Two sides gather to decide who holds the ground.";
    }else if(arch && arch.kind === "siege"){
      doing = "A garrison braces behind its walls.";
    }else{
      doing = "Steel gathers somewhere beyond your boundary.";
    }
    return {
      tier,
      slot,
      label: arch && arch.label || baseDef.label,
      kind: arch && arch.kind,
      leader,
      approx,
      doing
    };
  }

  function getBattleContext(tier, slot, arch, baseDef){
    if(typeof S !== "object") return makeBattleContext(tier, slot, arch, baseDef);
    if(!S.battleContexts) S.battleContexts = {};
    const key = tier + ":" + slot;
    const existing = S.battleContexts[key];
    const archLabel = arch && arch.label || baseDef.label;
    if(existing && existing.label === archLabel){
      return existing;
    }
    const ctx = makeBattleContext(tier, slot, arch, baseDef);
    S.battleContexts[key] = ctx;
    return ctx;
  }
function battleArchetypeFor(tier, slot){
    const t = BATTLE_ARCHETYPES[tier] || BATTLE_ARCHETYPES[1];
    return t && t[slot] ? t[slot] : t ? t[0] : null;
  }

  function currentBattleSet(){
    const { idx } = titleInfo();
    return BATTLE_SETS[Math.min(idx, BATTLE_SETS.length-1)];
  }


  
// === Land Type Effects (flat base output) ===
const LAND_TYPE_EFFECTS = {
  "Riverlands":      { den: 2, pop: 1 },
  "Farmlands":       { den: 1, pop: 2 },
  "Forest Edge":     { den: 1, pop: 1 },
  "Grazing Commons": { den: 1, pop: 1 },
  "Marsh Flats":     { den: 0, pop: 1 },
  "Old Quarry":      { den: 2, pop: 0 },

  // higher-tier examples (future-safe)
  "Hamlet":          { den: 3, pop: 3 },
  "Village":         { den: 5, pop: 6 },
  "Market Town":     { den: 8, pop: 8 },
  "Stronghold":      { den: 6, pop: 4 },
  "City":            { den: 12, pop: 12 }
};

function landBaseIncome(){
  if(!Array.isArray(S.controlledRegions)) return 0;
  let sum = 0;
  for(const r of S.controlledRegions){
    const eff = LAND_TYPE_EFFECTS[r.name];
    if(eff && eff.den) sum += eff.den;
  }
  return sum;
}

function landBasePopCap(){
  if(!Array.isArray(S.controlledRegions)) return 0;
  let sum = 0;
  for(const r of S.controlledRegions){
    const eff = LAND_TYPE_EFFECTS[r.name];
    if(eff && eff.pop) sum += eff.pop;
  }
  return sum;
}

// === Territory System (named lands instead of abstract plots) ===
  function territoryCount(){
    return Array.isArray(S.controlledRegions) ? S.controlledRegions.length : 0;
  }

  const TERRITORY_POOLS = {
  // Tier 1 ‚Äî Intra-Village Prestige: *lands*, not settlements (no "tribute from hamlets")
  1: [
    { id:"riverlands",   name:"Riverlands",       tier:1, summary:"Fertile banks that feed your village." },
    { id:"forest_edge",  name:"Forest Edge",     tier:1, summary:"Woodlots and game close to home." },
    { id:"farmlands",    name:"Farmlands",       tier:1, summary:"Open fields you can work and defend." },
    { id:"pastures",     name:"Grazing Commons", tier:1, summary:"Common pastureland for herds and carts." },
    { id:"marsh",        name:"Marsh Flats",     tier:1, summary:"Difficult ground that hides you from raiders." },
    { id:"quarry",       name:"Old Quarry",      tier:1, summary:"Stone and clay to shore up walls and huts." }
  ],

  // Tier 2 ‚Äî Clan Leadership: small holdings begin to appear
  2: [
    { id:"orchards",     name:"Orchard Lands",   tier:2, summary:"Fruit and cider for trade and feasts." },
    { id:"timber",       name:"Timber Stand",    tier:2, summary:"Good lumber for palisades and carts." },
    { id:"streamford",   name:"Streamford",      tier:2, summary:"A ford you can watch and tax lightly." },
    { id:"outstead",     name:"Outlying Stead",  tier:2, summary:"A distant homestead sworn to your clan." }
  ],

  // Tier 3 ‚Äî Tribal Influence: hamlets and villages become plausible
  3: [
    { id:"palisaded",    name:"Palisaded Hamlet", tier:3, summary:"A small hamlet protected by timber walls." },
    { id:"rivervillage", name:"River Village",    tier:3, summary:"A riverside village that boosts trade and food." },
    { id:"hillvillage",  name:"Hill Village",     tier:3, summary:"High ground that makes musters safer." },
    { id:"marketcross",  name:"Market Crossing",  tier:3, summary:"A crossroads where coin begins to flow." }
  ],

  // Tier 4 ‚Äî Confederation Level: fortified settlements and sacred sites
  4: [
    { id:"walled",       name:"Walled Village",   tier:4, summary:"Stonework and gates harden your reach." },
    { id:"councilfield", name:"Council Field",    tier:4, summary:"A meeting ground that strengthens legitimacy." },
    { id:"shrine",       name:"Shrine Settlement",tier:4, summary:"A holy place drawing pilgrims and prestige." },
    { id:"traderoad",    name:"Trade Road",       tier:4, summary:"A route that lifts steady denarii." }
  ],

  // Tier 5 ‚Äî Proto-king / Chiefdom-State: towns, forts, industry
  5: [
    { id:"bordertower",  name:"Border Fort",      tier:5, summary:"A strong point that steadies your frontier." },
    { id:"mines",        name:"Mineworks",        tier:5, summary:"Ore and coin for arms and pay." },
    { id:"sacredgrove",  name:"Sacred Grove",     tier:5, summary:"Oaths and rites bind clans to you." },
    { id:"smalltown",    name:"Growing Town",     tier:5, summary:"Markets and craftsmen expand your treasury." }
  ],

  // Tier 6 ‚Äî Kingship: capitals and major strongholds
  6: [
    { id:"stronghold",   name:"Border Stronghold", tier:6, summary:"A major fortress anchoring your realm." },
    { id:"capital",      name:"Regional Capital",  tier:6, summary:"A seat of rule where taxes and law flow." },
    { id:"greatmarket",  name:"Great Market",      tier:6, summary:"Trade surges under your banner." },
    { id:"subduedseat",  name:"Subdued Seat",      tier:6, summary:"A rival seat brought into your domain." }
  ]
};

  function pickTerritoryTemplate(tier){
    const pool = TERRITORY_POOLS[tier] || TERRITORY_POOLS[1];
    if(!pool || !pool.length){
      return { id:"wilds", name:"Unmarked Land", tier:tier||1, summary:"Rough country slowly being tamed." };
    }
    return pool[rnd(0, pool.length - 1)];
  }

  
function titleTier(){
    const { idx } = titleInfo();
    return titleTierFromIdx(idx);
  }

  function titleTierFromIdx(idx){
    // Your title ladder (index ranges):
    // Tier 1: 0‚Äì4, Tier 2: 5‚Äì9, Tier 3: 10‚Äì15, Tier 4: 16‚Äì21, Tier 5: 22‚Äì27, Tier 6: 28+
    if(idx <= 4) return 1;
    if(idx <= 9) return 2;
    if(idx <= 15) return 3;
    if(idx <= 21) return 4;
    if(idx <= 27) return 5;
    return 6;
  }

function captureTerritory(battleTier){
    if(!Array.isArray(S.controlledRegions)) S.controlledRegions = [];

    // IMPORTANT: Your title limits *what kind* of land you can realistically claim.
    // Elders can only be associated with local features (riverlands, forest edge, farmlands),
    // even if they win larger fights. Higher titles unlock settlement/holdings names.
    const tier = clamp(Math.min((battleTier||1), titleTier()), 1, 6);

    const tmpl = pickTerritoryTemplate(tier);
    const index = S.controlledRegions.length + 1;

    const terr = {
      id: `${tmpl.id}#${index}`,
      name: tmpl.name,
      tier: tmpl.tier,
      summary: tmpl.summary
    };

    S.controlledRegions.push(terr);
    return terr;
  }


  function battleSim(slot){
  const b = currentBattleSet()[slot];
  const enemyCount = rnd(b.enemyMin, b.enemyMax);

  const wins = (S.battlesWon || 0);
  const tier = battleTierFromTitleIdx(titleInfo().idx);
  const arch = battleArchetypeFor(tier, slot);
  if(arch && arch.label) b.label = arch.label;

  // --- YOUR TROOPS ---
  const yourTroops = Math.max(0, S.warriors || 0);
  const baseWarriorStrength = 6;
  let yourPower = yourTroops * baseWarriorStrength;

  const crowns = S.crowns || 0;
  const crownMult = 1 + Math.min(crowns * 0.045, 0.7);

  const decrees = S.decrees || 0;
  const decreeMult = 1 + Math.min(decrees * 0.03, 0.5);

  const land = S.land || 0;
  const landMult = 1 + Math.min(land * 0.012, 0.45);

  const faith = S.faith || 0;
  let faithMult = 1 + Math.min(faith / 18000, 0.25);
  try{
    if(typeof isBuffed === "function" && isBuffed()){
      faithMult *= 1.15;
    }
  }catch(e){}

  yourPower *= crownMult * decreeMult * landMult * faithMult;

  // Hidden veterancy + morale
  const legionXp = S.legionXp || 0;
  const expLevel = 1 + Math.min(legionXp / 6000, 0.30); // up to +30%

  let legionMorale = typeof S.legionMorale === "number" ? S.legionMorale : 1;
  legionMorale = clamp(legionMorale, 0.4, 2.0);
  const moraleMult = 0.85 + legionMorale * 0.30; // ~0.97‚Äì1.45

  yourPower *= expLevel * moraleMult;

  // --- ENEMY POWER ---
  const baseEnemyStrength = 6;
  let enemyPower = enemyCount * baseEnemyStrength;

  const tierMults = [0.9, 1.0, 1.2, 1.4, 1.7, 2.0];
  const slotMults = [0.9, 1.0, 1.15, 1.3];
  const tierMult = tierMults[tier - 1] || 1.0;
  const slotMult = slotMults[slot] || 1.0;

  enemyPower *= tierMult * slotMult;

  // Enemies "learn" you as you win more.
  const learnDivBase = [1000, 260, 190, 140];
  const learnDiv = learnDivBase[Math.min(slot, learnDivBase.length - 1)] || 250;
  const learn = 1 + Math.min(wins / learnDiv, 0.18);
  enemyPower *= learn;

  // --- CONVERT POWER ‚Üí HIDDEN STATS (HP / ATK / DEF / Armor) ---
  const hpPerPower   = 14;
  const atkPerPower  = 0.14;
  const defPerPower  = 0.10;
  const armPerPower  = 0.04;

  let yourHPmax  = Math.max(20, yourPower * hpPerPower);
  let enemyHPmax = Math.max(20, enemyPower * hpPerPower);

  let yourHP  = yourHPmax;
  let enemyHP = enemyHPmax;

  let yourATK = yourPower * atkPerPower;
  let enemyATK = enemyPower * atkPerPower;

  let yourDEF = yourPower * defPerPower;
  let enemyDEF = enemyPower * defPerPower;

  const yourArmor  = 1 + yourPower  * armPerPower * 0.10;
  const enemyArmor = 1 + enemyPower * armPerPower * (0.08 + tier * 0.04);

  // --- BATTLE LOOP: FAST TICK DAMAGE + SIMPLE ROUTING ---
  const TICK_SEC = 0.35;
  const MAX_TIME = 18; // seconds
  const maxTicks = Math.floor(MAX_TIME / TICK_SEC);

  let routed = null; // 'you' | 'enemy' | null

  function moraleBreakChance(myFrac, theirFrac, morale){
    const gap = clamp(theirFrac - myFrac, -0.9, 0.9);
    if(gap <= 0) return 0;
    const base = 0.06 + gap * 0.50;
    const moraleMod = 1 / clamp(morale, 0.4, 2.0);
    return clamp(base * moraleMod, 0, 0.65);
  }

  for(let i=0;i<maxTicks;i++){
    if(yourHP <= 0 || enemyHP <= 0) break;

    // Damage with a bit of noise
    const atkRollYou = 0.85 + Math.random() * 0.4;
    const atkRollEn  = 0.85 + Math.random() * 0.4;

    const rawToEnemy = Math.max(0, yourATK * atkRollYou - enemyDEF * 0.22);
    const rawToYou   = Math.max(0, enemyATK * atkRollEn  - yourDEF * 0.22);

    const armorMitEnemy = enemyArmor / (enemyArmor + 420);
    const armorMitYou   = yourArmor  / (yourArmor  + 420);

    const dmgToEnemy = rawToEnemy * (1 - armorMitEnemy) * TICK_SEC;
    const dmgToYou   = rawToYou   * (1 - armorMitYou)   * TICK_SEC;

    enemyHP -= dmgToEnemy;
    yourHP  -= dmgToYou;

    const yourFrac  = clamp(yourHP  / yourHPmax, 0, 1);
    const enemyFrac = clamp(enemyHP / enemyHPmax, 0, 1);

    // Morale checks after initial clash
    if(i > 4){
      const enemyMorale = 1.0; // generic
      const enemyBreak = moraleBreakChance(enemyFrac, yourFrac, enemyMorale);
      if(!routed && Math.random() < enemyBreak){
        routed = "enemy";
        break;
      }

      // Your side uses hidden legionMorale
      const yourMoraleVal = legionMorale;
      const yourBreak = moraleBreakChance(yourFrac, enemyFrac, yourMoraleVal);
      if(!routed && Math.random() < yourBreak){
        routed = "you";
        break;
      }
    }
  }

  const yourFracFinal  = clamp(yourHP  / yourHPmax, 0, 1);
  const enemyFracFinal = clamp(enemyHP / enemyHPmax, 0, 1);

  // Decide winner
  let win;
  if(routed === "enemy" || enemyHP <= 0){
    win = true;
  }else if(routed === "you" || yourHP <= 0){
    win = false;
  }else{
    const scoreYou = yourFracFinal  * yourPower;
    const scoreEn  = enemyFracFinal * enemyPower;
    win = scoreYou >= scoreEn || Math.random() < scoreYou / Math.max(scoreYou + scoreEn, 1);
  }

  // Convert HP loss ‚Üí troop casualties
  let lossFrac = (yourHPmax - Math.max(0, yourHP)) / yourHPmax;
  lossFrac = clamp(lossFrac, 0, win ? 0.65 : 0.90);

  let losses = Math.round(yourTroops * lossFrac);
  if(yourTroops > 0 && losses <= 0) losses = 1;
  losses = Math.min(yourTroops, Math.max(0, losses));

  // Approximate win chance for UI based on starting power + morale
  const powerRatio = yourPower / Math.max(enemyPower, 1);
  let winP = powerRatio / (1 + powerRatio);
  const moraleBias = (legionMorale - 1) * 0.18;
  winP = clamp(winP + moraleBias, 0.04, 0.96);

  return {
    label: b.label,
    enemies: enemyCount,
    winP,
    win,
    losses,
    tier
  };
}

  function offerCost(){
    return Math.round(600 * Math.pow(1.34, Math.floor((S.faith||0)/120)));
  }

  function offerFaithGain(){
    return Math.round(22 + (S.land*2));
  }

  function blessCooldownMs(){ return 60_000; }
  function blessDurationMs(){ return 22_000; }

  function ascendCrownGain(){
    // you need renown to ascend; crowns scale gently to keep long-term
    const r = S.renown;
    if(r < 25000) return 0;
    return Math.floor(Math.sqrt(r/650)); // e.g. 5000=>2, 20k=>5, 80k=>11
  }

  
  

  


  
  

  // ---- Titles + unlocks ----
  function titleInfo(){
    const r = S.renown;
    let idx = 0;
    for(let i=0;i<titles.length;i++) if(r >= titles[i].need) idx = i;
    const cur = titles[idx];
    const next = titles[Math.min(idx+1, titles.length-1)];
    return { cur, next, idx };
  }

  function rankTributeBonus(idx){
    // Slight per-rank boost. Early ranks are small to keep the start tough.
    // Elder=0 ‚Üí +0.0, Elder=1 ‚Üí +0.2, Chief=2 ‚Üí +0.5, etc.
    return Math.round((0.10*idx + 0.08*idx*idx) * 10) / 10; // to nearest 0.1
  }

  
function handleRankUps(){
    const { idx } = titleInfo();
    if(typeof S.rankIdx !== "number") S.rankIdx = 0;
    const prevIdx = S.rankIdx;

    if(idx <= prevIdx) return;

    const gained = idx - prevIdx;
    // Award a small permanent tap increase each rank-up
    // (this stacks with multipliers like Provinces/Decrees/Crowns and crit/streak).
    const before = S.tribute;
    S.tribute = Math.max(1, Math.round((S.tribute + gained * 0.25) * 10) / 10);
    S.rankIdx = idx;

    logLine(`Rank up! Your tribute grows. (+${(S.tribute - before).toFixed(1)} tap base)`, "warn");
    toast("Rank up!");

    // NEW: notify when a new land tier unlocks
    try{
      const prevTier = titleTierFromIdx(prevIdx);
      const newTier  = titleTierFromIdx(idx);

      if(!S.maxTerritoryTierNotified || typeof S.maxTerritoryTierNotified !== "number"){
        S.maxTerritoryTierNotified = prevTier;
      }

      if(newTier > S.maxTerritoryTierNotified){
        const unlockedNames = [];
        for(let t = S.maxTerritoryTierNotified + 1; t <= newTier; t++){
          const pool = TERRITORY_POOLS[t];
          if(pool && pool.length){
            pool.forEach(p => unlockedNames.push(p.name));
          }
        }
        S.maxTerritoryTierNotified = newTier;
        if(unlockedNames.length && typeof showLandTierUnlockPopup === "function"){
          showLandTierUnlockPopup(newTier, unlockedNames);
        }
      }
    }catch(e){
      if(console && console.warn) console.warn("Land tier unlock notify failed", e);
    }
  }


  // ---- Dopamine layers: Jackpots + Cash Out ----
  function cashoutMultiplier(){
    // Scales with prestige + progression systems
    return landMult() * decreeMult() * crownMult();
  }

  function rollJackpot(){
    // Returns {type, mult} or null
    // Lucky: common-ish; Imperial: rare but huge.
    const pMult = cashoutMultiplier();
    const luckyP = clamp(0.010 + (S.faith/200000), 0.010, 0.020);     // 1.0% ‚Üí 2.0%
    const impP   = clamp(0.0020 + (S.crowns*0.00015), 0.0020, 0.0060); // 0.20% ‚Üí 0.60%
    if(chance(impP))   return { type:"Imperial Tribute", mult: rnd(220, 650) * pMult };
    if(chance(luckyP)) return { type:"Lucky Denarius",  mult: rnd(40, 140) * pMult };
    return null;
  }

  function bankCashout(amount){
    // Bank grows with streak so players feel momentum.
    const streakBoost = 1 + Math.min(0.85, (S.streak-1)*0.02);
    S.cashoutBanked += Math.round(amount * 0.35 * streakBoost);
    S.cashoutBanked = clamp(S.cashoutBanked, 0, 9_999_999_999);
  }
  function expireCashoutIfNeeded(){ /* handled by cooldown + streak timer */ }

// ---- Cash Out Rework (streak-driven, timing & milestones) ----
  // Goal: tempt players to *cash* their streak at milestones instead of mindlessly holding it.
  const CASHOUT_MIN_STREAK = 6;       // when cashing becomes available
  const CASHOUT_COOLDOWN_MS = 2500;   // after cashing out

  function cashoutPotential(){
    const s = Math.max(1, S.streak || 1);
    if(s < CASHOUT_MIN_STREAK) return 0;

    const milestones = Math.floor(s / 10); // every 10 feels special
    const within = streakTimeLeftMs() / STREAK_WINDOW_MS; // 0..1
    const timing = 0.70 + 0.30 * within; // more if you're actively tapping

    // Softer streak curve so players can't hoard absurd jackpots from endless tapping.
    const curve = Math.pow(s, 1.05); // was 1.22
    const kicker = 1 + milestones * 0.12;
    const rush = 1 + (rushBonus() * 0.05);

    const raw = (4 + curve) * kicker * timing * rush;
    let payout = Math.round(raw * cashoutMultiplier());

    // Hard cap: tie cashout to current empire power instead of infinite streaks.
    const baseIncome = Math.max(10, (S.tribute || 1) * landMult());
    const cap = Math.round(baseIncome * 80); // roughly 80 taps worth at current strength
    if(payout > cap) payout = cap;

    return payout;
  }

  function cashoutReady(){
    const now = Date.now();
    return (now >= (S.cashoutCooldownUntil || 0)) && cashoutPotential() > 0;
  }
// ---- Micro objectives (state-driven, procedural, always something to do) ----
const OBJ_SLOTS = 3;

// Lanes:
//  slot 0 = "village / economy"
//  slot 1 = "legion / land / battles"
//  slot 2 = "meta / temple / streak / cashout"
function ensureObjectives(){
  if(!Array.isArray(S.objectives) || S.objectives.length !== OBJ_SLOTS){
    S.objectives = [];
    for(let i=0;i<OBJ_SLOTS;i++) S.objectives.push(makeObjective(i));
    S.objStreak = Number(S.objStreak) || 0;
  }else{
    // Make sure each slot is at least a valid objective object
    for(let i=0;i<OBJ_SLOTS;i++){
      if(!S.objectives[i] || typeof S.objectives[i] !== "object"){
        S.objectives[i] = makeObjective(i);
      }
    }
    S.objStreak = Number(S.objStreak) || 0;
  }
}

function makeObjective(slotIndex = 0){
  // Procedural objectives: scale off current progress + unlocks.
  const r        = Number(S.renown)   || 0;
  const land     = Number(S.land)     || 0;
  const w        = Number(S.warriors) || 0;
  const crowns   = Number(S.crowns)   || 0;
  const income   = Math.max(0, incomePerSec());
  const farms    = Number(S.farmCount) || 0;
  const villas   = Number(S.villaCount) || 0;
  const battles  = Number(S.battlesWon) || 0;

  // Rough progression tier: renown + crowns pushes things up.
  const progTier = Math.max(
    1,
    1 + Math.floor(r / 1400) + Math.floor(crowns / 3)
  );

  // Slightly discourage giving the same type in every slot.
  const existingTypes = (Array.isArray(S.objectives) ? S.objectives : [])
    .filter(Boolean)
    .map(o => o.type);
  const existingSet = new Set(existingTypes);

  // Each slot has a preferred "lane", but can fall back if that lane is weak.
  let lane = "village";
  if(slotIndex === 1) lane = "legion";
  if(slotIndex === 2) lane = "meta";

  const pool = [];
  const pushObj = (spec)=>{
    if(!spec || spec.weight <= 0) return;
    let weight = spec.weight;
    if(existingSet.has(spec.type)){
      // still allowed, but less likely so you see variety
      weight *= 0.35;
    }
    if(weight <= 0) return;
    pool.push({ ...spec, weight });
  };

  // --- Lane: village / economy (slot 0 bias) ---
  if(lane === "village"){
    // Core tap loop ‚Äì short chains early, longer chains later
    const tapMin = 8 + (progTier-1)*3;
    const tapMax = tapMin + 10 + progTier*4;
    pushObj({ type: "tap", min: tapMin, max: tapMax, weight: 6 });

    // Denarii milestones tied to your current income
    const earnBase = Math.max(120, Math.round(income * (16 + progTier*4)));
    pushObj({
      type: "earnDen",
      min: earnBase,
      max: Math.round(earnBase * 1.6),
      weight: 6
    });

    if(progTier >= 3){
      const big = earnBase * (1.9 + progTier*0.20);
      pushObj({
        type: "earnDen",
        min: Math.round(big),
        max: Math.round(big * 1.4),
        weight: 3
      });
    }

    // Farms ramp from 1 ‚Üí 2 ‚Üí 3+ as your village gets big.
    let farmMin = 1;
    if(farms >= 6)  farmMin = 2;
    if(farms >= 16) farmMin = 3;
    const farmMax = farmMin + (progTier >= 4 ? 1 : 0);
    pushObj({
      type: "buildFarm",
      min: farmMin,
      max: farmMax,
      weight: 4
    });

    // Villas show up once you're mid-game.
    if(r >= 900){
      let villaMin = 1;
      if(villas >= 4) villaMin = 2;
      if(villas >= 9) villaMin = 3;
      const villaMax = Math.min(villaMin + 1, 4);
      pushObj({
        type:"buildVilla",
        min: villaMin,
        max: villaMax,
        weight: 3
      });
    }
  }

  // --- Lane: legion / land / battles (slot 1 bias) ---
  if(lane === "legion"){
    if(r >= unlock.legion){
      // Recruit ramp: early 1‚Äì2, later 3‚Äì6 per objective.
      let recMin = 1;
      let recMax = 2;
      if(w >= 10){ recMin = 2; recMax = 4; }
      if(w >= 30){ recMin = 3; recMax = 6; }
      if(w >= 70){ recMin = 4; recMax = 8; }
      pushObj({
        type:"recruit",
        min: recMin,
        max: recMax,
        weight: 5
      });

      // Win battles: starts at 1, grows gently.
      let winMin = 1;
      let winMax = 1;
      if(battles >= 5){ winMax = 2; }
      if(battles >= 18){ winMin = 2; winMax = 3; }
      if(battles >= 40){ winMin = 3; winMax = 4; }
      pushObj({
        type:"winBattle",
        min: winMin,
        max: winMax,
        weight: 4
      });

      // Gain land ‚Äì more relevant as you scale.
      let landMin = 1;
      let landMax = 2 + Math.floor(progTier*0.8);
      landMax = Math.min(8, landMax);
      pushObj({
        type:"gainLand",
        min: landMin,
        max: landMax,
        weight: 4
      });
    }

    // Back-up econ task if legion is locked
    if(r < unlock.legion){
      const earnBase = Math.max(140, Math.round(income * (14 + progTier*3)));
      pushObj({
        type:"earnDen",
        min: earnBase,
        max: Math.round(earnBase * 1.5),
        weight: 4
      });
    }
  }

  // --- Lane: meta / temple / streak / cashout (slot 2 bias) ---
  if(lane === "meta"){
    // Streak objective encourages tap rhythm play
    pushObj({
      type:"streak",
      min: 6 + progTier*2,
      max: 10 + progTier*4,
      weight: 5
    });

    // Cashout objective: push players to actually hit the button
    if(r >= 400){
      pushObj({
        type:"cashout",
        min: 1,
        max: Math.min(2, 1 + Math.floor(progTier/3)),
        weight: 3
      });
    }

    // Temple objectives
    if(r >= unlock.temple){
      pushObj({
        type:"offerFaith",
        min: 1,
        max: Math.min(3, 1 + progTier),
        weight: 3
      });
    }

    // Always have *something* simple available
    const earnBase = Math.max(100, Math.round(income * (10 + progTier*2)));
    pushObj({
      type:"earnDen",
      min: earnBase,
      max: Math.round(earnBase * 1.4),
      weight: 3
    });
  }

  // Global fallbacks if lane ended up too thin
  if(pool.length === 0){
    const earnBase = Math.max(80, Math.round(income * (8 + progTier*2)));
    pushObj({ type:"tap",    min: 8,         max: 20,                weight: 4 });
    pushObj({ type:"earnDen",min: earnBase,  max: Math.round(earnBase*1.4), weight: 4 });
  }

  // Weighted pick
  const totalW = pool.reduce((a,p)=>a+p.weight,0);
  let roll = Math.random() * totalW;
  let pick = pool[0];
  for(const p of pool){
    roll -= p.weight;
    if(roll <= 0){ pick = p; break; }
  }

  const target = rnd(pick.min, pick.max);
  const id = `${pick.type}_${Date.now()}_${rnd(100,999)}`;

  // Reward design:
  // - scales with renown, land, crowns, income and target
  // - gets a small push from objStreak so back-to-back completions feel hot
  const streak = Number(S.objStreak)||0;
  const streakMult = 1 + Math.min(0.45, streak * 0.04);

  const baseDen   = 22 + Math.floor(r/110) + (crowns*16) + Math.floor(land*3.5);
  const incomeDen = income * (12 + progTier*4);
  const targetFactor = 0.85 + target*0.08 + progTier*0.25;

  let rewardDen = Math.round((baseDen + incomeDen) * targetFactor * streakMult);

  // soft caps just to keep early game sane
  const softCap =
    (r < 1500)   ?  900 :
    (r < 8000)   ? 5000 :
    (r < 25000)  ? 30000 :
                   1e12;
  rewardDen = Math.min(rewardDen, softCap);

  // Power rewards removed; objectives now grant denarii only.
  const rewardPower = 0;

  return {
    id,
    type: pick.type,
    target,
    progress: 0,
    rewardDen,
    rewardPower,
    claimed: false
  };
}

function objText(o){
  const left = Math.max(0, o.target - o.progress);

  if(o.type==="tap")
    return `Tap ${o.target} times (${left} left)`;

  if(o.type==="streak")
    return `Reach streak x${o.target} (best this run: x${Math.max(1, S.streak||1)})`;

  if(o.type==="winBandits")
    return `Win ${o.target} bandit skirmish${o.target>1?"es":""} (${left} left)`;

  if(o.type==="winLevy")
    return `Win ${o.target} levy battle${o.target>1?"s":""} (${left} left)`;

  if(o.type==="winVillage")
    return `Win ${o.target} village assault${o.target>1?"s":""} (${left} left)`;

  if(o.type==="winSiege")
    return `Win ${o.target} siege${o.target>1?"s":""} (${left} left)`;

  if(o.type==="buildFarm")
    return `Build ${o.target} farm${o.target>1?"s":""} (${left} left)`;

  if(o.type==="buildVilla")
    return `Build ${o.target} villa${o.target>1?"s":""} (${left} left)`;

  if(o.type==="earnDen")
    return `Earn ${fmt(o.target)} denarii (${fmt(left)} left)`;

  if(o.type==="recruit")
    return `Recruit ${o.target} milites${o.target>1?"s":""} (${left} left)`;

  if(o.type==="winBattle")
    return `Win ${o.target} battle${o.target>1?"s":""} (${left} left)`;

  if(o.type==="gainLand")
    return `Gain ${o.target} land (${left} left)`;

  if(o.type==="offerFaith")
    return `Make ${o.target} temple offering${o.target>1?"s":""} (${left} left)`;

  if(o.type==="cashout")
    return `Cash out ${o.target} time${o.target>1?"s":""} (${left} left)`;

  return `Complete this task (${left} left)`;
}

function objComplete(o){ return o.progress >= o.target; }
function objComplete(o){ return o.progress >= o.target; }
function bumpObjective(type, amount=1){
  for(const o of S.objectives){
    if(o.claimed) continue;
    if(o.type !== type) continue;
    o.progress = clamp(o.progress + amount, 0, o.target);
  }
}

function bumpEarnedDenarii(amount){
  ensureObjectives();
  for(const o of S.objectives){
    if(o.claimed) continue;
    if(o.type !== "earnDen") continue;
    o.progress = clamp(o.progress + amount, 0, o.target);
  }
}

function claimObjective(idx){
  ensureObjectives();
  const o = S.objectives[idx];
  if(!o || o.claimed || !objComplete(o)) return;

  o.claimed = true;
  S.objStreak = (Number(S.objStreak)||0) + 1;

  const now = Date.now();
  const objMult = now < (S.objDoubleUntil || 0) ? 2 : 1;
  const rewardDen = o.rewardDen * objMult;

  // payout
  S.gold += rewardDen;
  S.lifetimeGold += rewardDen;

  const doubledText = objMult > 1 ? " (doubled)" : "";
  logLine(`Objective complete! (+${fmt(rewardDen)} denarii${doubledText})`, "good");
  toast("Objective claimed");

  // üîî Objective streak dopamine:
  //  - Hook into the existing burst engine
  //  - Occasionally spit out a chest on streak milestones
  maybeBurst("streak");
  if(S.objStreak > 0 && S.objStreak % 4 === 0){
    try{
      showChest("objective");
    }catch(e){
      // chest UI missing / not loaded? silently ignore
    }
  }

  // replace with a new one in the same lane
  S.objectives[idx] = makeObjective(idx);
}

function renderObjectives(){
  const list = $("#objList");
  if(!list) return;
  ensureObjectives();

  $("#objStreak").textContent = fmt(S.objStreak || 0);

  list.innerHTML = "";
  S.objectives.forEach((o, i) => {
    const row = document.createElement("div");
    row.style.display = "flex";
    row.style.alignItems = "center";
    row.style.justifyContent = "space-between";
    row.style.gap = "10px";

    const left = document.createElement("div");
    left.style.display = "flex";
    left.style.flexDirection = "column";
    left.style.gap = "2px";

    const title = document.createElement("div");
    title.style.fontFamily = "var(--mono)";
    title.style.fontSize = ".78rem";
    title.style.color = "var(--text)";
    title.textContent = objText(o);

    const small = document.createElement("div");
    small.style.fontFamily = "var(--sans)";
    small.style.fontSize = ".74rem";
    small.style.color = "var(--muted)";
    small.textContent = `Reward: +${fmt(o.rewardDen)} denarii`;

    left.appendChild(title);
    left.appendChild(small);

    const btn = document.createElement("button");
    btn.className = "tab"; // reuse pill button style
    btn.style.padding = "10px 12px";
    btn.style.fontSize = ".74rem";
    btn.textContent = objComplete(o) ? "Claim" : `${Math.floor((o.progress/Math.max(1,o.target))*100)}%`;
    btn.disabled = !objComplete(o);
    if(objComplete(o)) btn.classList.add("active");
    btn.addEventListener("click", () => { claimObjective(i); render(); });

    row.appendChild(left);
    row.appendChild(btn);
    list.appendChild(row);
  });
}





  // ---- Burst Events (RNG micro-spikes) ----
  function triggerTributeFever(){
    const now = Date.now();
    const dur = 6000; // 6s
    S.feverUntil = Math.max(S.feverUntil || 0, now) + dur;
    toast("Tribute Fever! +250% taps for 6s");
    logLine("Tribute Fever surges through the village!", "good");
  }

  function triggerDoubleObjectives(){
    const now = Date.now();
    const dur = 20000; // 20s
    S.objDoubleUntil = Math.max(S.objDoubleUntil || 0, now) + dur;
    toast("Double Objectives! Rewards boosted");
    logLine("For a short time, objectives are doubled.", "warn");
  }

  function triggerCommanderVisit(){
    S.warriors = (S.warriors || 0) + 1;
    recalcLegionStrength();
    toast("Commander visits: +1 free warrior");
    logLine("A seasoned commander grants you a free warrior.", "good");
  }

  function triggerGoldStorm(){
    const now = Date.now();
    // Small burst of gold
    const base = 18 + Math.floor((S.renown||0)/160) + (S.crowns||0)*4;
    const gain = Math.max(10, Math.round(base * (1 + Math.random()*3)));
    S.gold += gain;
    S.lifetimeGold += gain;
    bumpEarnedDenarii(gain);

    toast("Gold storm!");

    // Visual coins: reuse sparkAt across random positions
    try{
      const vw = window.innerWidth || 400;
      const vh = window.innerHeight || 700;
      for(let i=0;i<10;i++){
        const x = rnd(Math.floor(vw*0.1), Math.floor(vw*0.9));
        const y = rnd(Math.floor(vh*0.15), Math.floor(vh*0.7));
        sparkAt(x,y, 0.60);
      }
    }catch(e){}
    logLine(`Gold storm! (+${fmt(gain)} denarii)`, "good");
  }

  function maybeBurst(source){
    // Base chance per trigger source
    let base;
    if(source === "streak") base = 0.18;
    else if(source === "cashout") base = 0.15;
    else if(source === "battle") base = 0.16;
    else base = 0.10;

    if(Math.random() > base) return;

    const roll = Math.random();
    if(roll < 0.35){
      triggerTributeFever();
    }else if(roll < 0.60){
      triggerDoubleObjectives();
    }else if(roll < 0.80){
      triggerCommanderVisit();
    }else{
      triggerGoldStorm();
    }
  }

// ---- Loot Chests (2-second dopamine overlay) ----
  function chestRarityFrom(source){
    // source: "skirmish" | "objective" | "battle" | other
    // For skirmishes, we bias rarity by total battles won so early fights feel juicy:
    // e.g. after 5 wins, guaranteed Common; after 8+, Rare+; after 12+, Epic chance.
    if(source === "skirmish"){
      const wins = S.battlesWon || 0;
      if(wins >= 12){
        const roll = Math.random();
        if(roll < 0.45) return "Epic";
        if(roll < 0.85) return "Rare";
        return "Common";
      }else if(wins >= 8){
        const roll = Math.random();
        if(roll < 0.30) return "Epic";
        if(roll < 0.80) return "Rare";
        return "Common";
      }else if(wins >= 5){
        // first few chests are almost always common, to teach the loop
        const roll = Math.random();
        if(roll < 0.15) return "Rare";
        return "Common";
      }else{
        // before 5 wins, very small chance from skirmish
        if(Math.random() < 0.30) return "Common";
        // no chest; caller shouldn't have asked for rarity
        return "Common";
      }
    }

    // Events / gifts are mostly RNG with a slight rarity curve.
    const roll = Math.random();
    let epicP = 0.05;
    let rareP = 0.28;

    // üåü Renown perk: famous rulers see better gifts.
    const ren = S.renown || 0;
    const renBonus = Math.min(0.08, Math.log10(1 + ren/400) * 0.05);
    if(renBonus > 0){
      epicP += renBonus * 0.4;
      rareP += renBonus * 0.6;
    }
    // keep things sane
    epicP = clamp(epicP, 0, 0.40);
    rareP = clamp(rareP, 0, 0.80);

    if(roll < epicP) return "Epic";
    if(roll < epicP + rareP) return "Rare";
    return "Common";
  }

  function chestPalette(rarity){
    if(rarity==="Epic") return { title:"Epic Chest", icon:"üëë", border:"rgba(244,208,111,.55)" };
    if(rarity==="Rare") return { title:"Rare Chest", icon:"üè∫", border:"rgba(166,212,172,.55)" };
    return { title:"Common Chest", icon:"üß∞", border:"rgba(31,58,42,.85)" };
  }

  function makeChestLoot(rarity){
    // Build 3 rewards. Keep it simple: denarii / power / renown OR a temp buff.
    const mult = cashoutMultiplier();
    const base = 35 + Math.floor(S.renown/160) + (S.crowns*7);

    const rarityMult = (rarity==="Epic") ? 2.6 : (rarity==="Rare" ? 1.65 : 1.0);

    const options = [
      () => ({ kind:"den",  text:`+${fmt(Math.round((base*10) * rarityMult * mult))} denarii`, apply:()=>{
        const amt = Math.round((base*10) * rarityMult * mult);
        S.gold += amt; S.lifetimeGold += amt; bumpEarnedDenarii(amt);
      }}),
      () => ({ kind:"pow",  text:`+${fmt(Math.round((2 + base*0.03) * rarityMult))} power`, apply:()=>{
        S.power += Math.round((2 + base*0.03) * rarityMult);
      }}),
      () => ({ kind:"ren",  text:`+${fmt(Math.round((6 + base*0.06) * rarityMult))} power`, apply:()=>{
        const amt = Math.round((6 + base*0.06) * rarityMult);
        S.power += amt;
      }}),
      () => ({ kind:"buf",  text:`Prosperity (20s)`, apply:()=>{
        // income multiplier via prosperUntil (stacks by extending)
        const now = Date.now();
        const add = 20_000 + (rarity==="Epic" ? 12_000 : (rarity==="Rare" ? 6_000 : 0));
        S.prosperUntil = Math.max(S.prosperUntil||0, now) + add;
        toast("Prosperity!");
      }}),
    ];

    // Rarity influences chance of buff appearing
    const buffChance = (rarity==="Epic") ? 0.45 : (rarity==="Rare" ? 0.25 : 0.12);

    const picks = [];
    for(let i=0;i<3;i++){
      let item;
      if(chance(buffChance) && picks.filter(p=>p.kind==="buf").length===0){
        item = options[3]();
      }else{
        // pick among den/pow/ren biased towards denarii
        const r = Math.random();
        item = (r < 0.55) ? options[0]() : (r < 0.78 ? options[1]() : options[2]());
      }
      picks.push(item);
    }
    return picks;
  }


  function showChest(source="feast"){
    const rarity = chestRarityFrom(source);
    const loot = makeChestLoot(rarity);

    const overlay = $("#chestOverlay");
    const card = $("#chestCard");
    const title = $("#chestTitle");
    const icon = $("#chestIcon");
    const hint = $("#chestHint");
    const rev = [$("#rev1"), $("#rev2"), $("#rev3")];
    const btnContinue = $("#chestContinue");

    const pal = chestPalette(rarity);
    title.textContent = pal.title;
    icon.textContent = pal.icon;
    card.style.borderColor = pal.border;

    // reset reveal
    rev.forEach(r=>r.textContent = "?");
    hint.textContent = "Tap to reveal rewards";
    if(btnContinue){
      btnContinue.style.display = "none";
      btnContinue.disabled = true;
    }

    overlay.style.display = "flex";
    // small fade/scale-in via CSS class
    overlay.classList.add("visible");

    let opened = false;
    let step = 0;

    const finish = ()=>{
      overlay.classList.remove("visible");
      overlay.onclick = null;
      if(btnContinue){
        btnContinue.onclick = null;
        btnContinue.disabled = true;
      }
      // wait for transition then hide
      setTimeout(()=>{
        overlay.style.display = "none";
      }, 230);

      // tiny burst
      try{
        const rect = card.getBoundingClientRect();
        sparkAt(rect.left + rect.width*0.50, rect.top + rect.height*0.22);
      }catch(e){}
      render();
    };

    const revealNext = ()=>{
      if(step >= 3) return;
      const item = loot[step];
      rev[step].textContent = item.text;
      // apply immediately so the HUD updates after close
      item.apply();
      step += 1;
      if(step >= 3){
        hint.textContent = "All rewards claimed.";
        if(btnContinue){
          btnContinue.style.display = "inline-flex";
          btnContinue.disabled = false;
          btnContinue.onclick = finish;
        }else{
          // fallback: tap backdrop closes
          overlay.onclick = finish;
        }
      }
    };

    const open = ()=>{
      if(step >= 3){
        // if already done, do nothing here (continue handled by button)
        return;
      }
      if(opened){
        revealNext();
        return;
      }
      opened = true;
      hint.textContent = "Opening‚Ä¶";
      // fast 3 reveals
      revealNext();
      setTimeout(revealNext, 220);
      setTimeout(revealNext, 440);
    };

    // Tap anywhere on the card/backdrop to open/advance
    overlay.onclick = open;
  }


  function canAccess(view){
    if(view==="legion") return true;
    return (S.renown >= (unlock[view] ?? 0));
  }

  function setView(view){
    if(!canAccess(view)){
      const need = unlock[view] ?? 0;
      toast(`Locked ‚Äî need ${need} renown`);
      return;
    }
    currentView = view;
    $$(".view").forEach(v => v.hidden = v.dataset.view !== view);
    $$(".tab").forEach(b => b.classList.toggle("active", b.dataset.go === view));
    render();
  }

  // ---- UI render ----
  function fmt(n){
    n = Math.floor(n);
    if(n < 10000) return String(n);
    if(n < 1_000_000) return (n/1000).toFixed(1).replace(".0","") + "k";
    if(n < 1_000_000_000) return (n/1_000_000).toFixed(1).replace(".0","") + "m";
    return (n/1_000_000_000).toFixed(1).replace(".0","") + "b";
  }

  function renderTabs(){
    $$(".tab").forEach(btn => {
      const v = btn.dataset.go;
      const ok = canAccess(v);
      btn.disabled = !ok;
      btn.title = ok ? "" : `Unlock at ${unlock[v]} renown`;
    });
  }

  function updateTitleProgress(){
    const r = S.renown;
    const {cur, next} = titleInfo();
    $("#title").textContent = cur.name;
    $("#nextTitle").textContent = next.name;

    const span = Math.max(1, next.need - cur.need);
    const t = clamp((r - cur.need) / span, 0, 1);
    $("#progressFill").style.width = (t*100).toFixed(1) + "%";
  }

  function statsRows(){
    const rows = [
      ["Gold", S.gold],
      ["Renown", S.renown],
      ["Income / sec", incomePerSec().toFixed(1)],
      ["Tap base (tribute)", S.tribute],
      ["Rank tap bonus", rankTributeBonus(titleInfo().idx)],
      ["Streak", "x"+S.streak],
      ["Crit chance", Math.round(critChance()*100)+"%"],
      ["Farms", S.farmCount],
      ["Villas", S.villaCount],
      ["Milites", S.warriors],
      ["Legion strength", S.legion],
      ["Raids won", S.battlesWon],
      ["Territories", territoryCount()],
      
      ["Milites (pop used)", S.populationUsed],
      ["Population Cap", populationCap()],
      ["Faith", S.faith],
      ["Crowns (prestige)", S.crowns],
      ["Ascensions", S.ascends || 0],
      ["Best streak (all time)", S.bestStreak || 0],
      ["Biggest cashout", S.biggestCashout || 0],
      ["Multipliers", `Land x${landMult().toFixed(2)} ‚Ä¢ Crown x${crownMult().toFixed(2)}`],
      ["Lifetime denarii", S.lifetimeGold],
      ["Lifetime renown", S.lifetimeRenown],
    ];
    return rows;
  }

  // Update the Milites header icon based on rank. For the first few
  // ranks we show the basic milites sprite; higher ranks can later use
  // different art or hide the icon entirely.
  let _militesIconRankIdx = null;

  function updateMilitesIcon(){
    const icon = $("#militesIcon");
    if(!icon) return;
    const info = titleInfo();
    const idx = info.idx || 0;

    // Avoid rebinding the same sprite every render tick; only update when rank changes.
    if(_militesIconRankIdx === idx) return;
    _militesIconRankIdx = idx;

    // First four ranks (Elder ‚Üí Council Elder) use the base sprite.
    if(idx <= 3){
      icon.src = "Sprites/MiliteForElder.png";
      icon.alt = "Milites";
      icon.style.display = "inline-block";
    }else{
      // Hide for now at higher ranks (you can swap to other sprites later)
      icon.style.display = "none";
    }
  }

  function render(){
    handleRankUps();
    expireCashoutIfNeeded();
    expireStreakIfNeeded();

    $("#gold").textContent = fmt(S.gold);
    $("#renown").textContent = fmt(S.renown);
    $("#landHud").textContent = fmt(S.land || 0);

    const grossInc = incomePerSec();
    const upkeepNow = warriorUpkeepPerSec();
    const netInc = Math.max(0, grossInc - upkeepNow);
    $("#incomeRate").textContent = netInc.toFixed(1);
    $("#incomeRate").title = `Gross: ${grossInc.toFixed(2)}/s, Upkeep: -${upkeepNow.toFixed(2)}/s`;

    // Compact income breakdown text under the village panel
    const farmBase = (S.farmCount || 0) * 0.75;
    const villaBase = (S.villaCount || 0) * 3.0;
    const bd = $("#incomeBreakdown");
    if(bd){
      bd.textContent =
        `Farms ${farmBase.toFixed(2)}/s ‚Ä¢ Villas ${villaBase.toFixed(2)}/s ` +
        `‚Ä¢ Upkeep -${upkeepNow.toFixed(2)}/s ‚Ä¢ Net ${netInc.toFixed(2)}/s`;
    }

    // Renown soft-tech: passive decree unlocks from fame (no choices, pure dopamine)
    (function applyRenownPerks(){
      const ren = S.renown || 0;
      const prevLevel = S.renownPerkLevel || 0;
      let level = 0;
      if(ren >= 1500) level = 1;
      if(ren >= 6000) level = 2;
      if(ren >= 20000) level = 3;

      if(level > prevLevel){
        // Base decrees granted by reputation alone; never reduce manual ones.
        const baseFromRenown = level; // 1,2,3
        if((S.decrees||0) < baseFromRenown){
          const gained = baseFromRenown - (S.decrees||0);
          S.decrees = baseFromRenown;
          logLine(`Your fame grants you ${gained} royal decree${gained>1?"s":""}.`, "good");
          toast("Renown unlocks new decrees");
        }
        S.renownPerkLevel = level;
      }
    })();

    // Population display (village capacity)
    const cap = populationCap();
    const used = (S.population||0);
    const pu = $("#popUsed"); const pc = $("#popCap");
    const mr = (typeof migrationPerSec === "function") ? migrationPerSec() : 0;
    $("#migRate") && ($("#migRate").textContent = (Math.round(mr*100)/100).toFixed(2));
    if(pu && pc){ pu.textContent = fmt(used); pc.textContent = fmt(cap); }


    // Village
    const t = tapGain();
    $("#tributeGain").textContent = `+${fmt(t.gain)} denarii`;
    $("#tributeHint").textContent = `Streak x${S.streak} ‚Ä¢ ${Math.ceil(streakTimeLeftMs()/100)/10}s${rushBonus()>0 ? ` ‚Ä¢ RUSH +${rushBonus()}` : ""}${isBuffed() ? " ‚Ä¢ BLESSED" : ""}${Date.now() < (S.feverUntil||0) ? " ‚Ä¢ FEVER" : ""}${Date.now() < (S.objDoubleUntil||0) ? " ‚Ä¢ DOUBLE OBJ" : ""}`;


    // Cash Out UI
    const cbtn = $("#btnCashout");
    if(cbtn){
      const pot = cashoutPotential();
      const ready = cashoutReady();
      cbtn.style.display = "flex";
      cbtn.disabled = !ready;
      const cd = Math.max(0, Math.ceil(((S.cashoutCooldownUntil||0) - Date.now())/1000));
      if(pot <= 0){
        $("#cashoutDesc").textContent = `Unlock at streak x${CASHOUT_MIN_STREAK}`;
      }else if(cd>0){
        $("#cashoutDesc").textContent = `Cooling down (${cd}s)`;
      }else{
        const ms = Math.floor((S.streak||1)/10);
        $("#cashoutDesc").textContent = `Cash out +${fmt(pot)} denarii${ms>0 ? ` ‚Ä¢ Milestones ${ms}` : ""}`;
      }
    }


    $("#hutDesc").textContent   = `${fmt(S.hutCount||0)} huts ‚Ä¢ Cost ${fmt(costHut())} ‚Ä¢ +2 pop cap each`;
    $("#farmDesc").textContent  = `${fmt(S.farmCount)} farms ‚Ä¢ Cost ${fmt(costFarm())} ‚Ä¢ +0.75 denarii/s each`;
    $("#villaDesc").textContent = `${fmt(S.villaCount)} villas ‚Ä¢ Cost ${fmt(costVilla())} ‚Ä¢ +3.0 denarii/s each ‚Ä¢ +10 pop cap`;

    updateTitleProgress();

    // Legion
    recalcLegionStrength();
    $("#warriors").textContent = fmt(S.warriors);
    $("#legionStr").textContent = fmt(S.legion);
    $("#landLegion").textContent = fmt(S.land);
    $("#landHud").textContent = fmt(S.land);

    const up = warriorUpkeepPerSec();
    const upEl = $("#legionUpkeep");
    if(upEl){
      upEl.textContent = up.toFixed(2);
    }

    $("#recruitCost").textContent = `Cost ${fmt(recruitCost())}`;
    $("#recruitGain").textContent = `+${fmt(recruitStrengthGain())} strength`;

    // Update Milites header icon depending on current rank.
    updateMilitesIcon();

    
    
    // Battles (rank-based)
    const bs = currentBattleSet();
    const btns = [
      { btn:"#btnBattleBandits1", titleSel:"#btnBattleBandits1 .t", desc:"#battleBandits1Desc" },
      { btn:"#btnBattleLevy",     titleSel:"#btnBattleLevy .t",     desc:"#battleLevyDesc" },
      { btn:"#btnBattleVillageRaid", titleSel:"#btnBattleVillageRaid .t", desc:"#battleVillageRaidDesc" },
      { btn:"#btnBattleSiege",    titleSel:"#btnBattleSiege .t",    desc:"#battleSiegeDesc" }
    ];
    const { idx } = titleInfo();
    const tier = battleTierFromTitleIdx(idx);

    for(let i=0;i<4;i++){
      const base = bs[i];
      if(!base) continue;
      const tEl = $(btns[i].titleSel);
      const dEl = $(btns[i].desc);

      const arch = battleArchetypeFor(tier, i);
      const ctx  = getBattleContext(tier, i, arch, base);

      const min = base.enemyMin;
      const max = base.enemyMax;
      const range = (min===max) ? `${min}` : `${min}‚Äì${max}`;

      // Keep the archetype label everywhere
      const label = ctx.label;
      base.label = label;

      if(tEl) tEl.textContent = label;
      if(dEl){
        // Example: "10‚Äì25 enemies ‚Ä¢ Skirmish ‚Ä¢ Led by Varro Tatius"
        const kind = ctx.kind || (arch && arch.kind) || "";
        const kindTag = kind === "skirmish"
          ? "Skirmish"
          : kind === "feud"
            ? "Feud"
            : kind === "field"
              ? "Field action"
              : kind === "siege"
                ? "Siege"
                : "";

        // Line 1: short mechanical summary
        const line1 = kindTag
          ? `${range} enemies ‚Ä¢ ${kindTag}`
          : `${range} enemies`;

        // Line 2: minimal faction identity (root ‚Äî class)
        const leader = ctx.leader || "";

        dEl.textContent = leader ? `${line1}\n${leader}` : line1;
      }
    }
    const cd = 0; // battle cooldown disabled

    // Battles: only requirement is "do you have any milites?"
    const hasTroops = (S.warriors || 0) > 0;

    $("#btnBattleBandits1").disabled    = !hasTroops;
    $("#btnBattleLevy").disabled        = !hasTroops;
    $("#btnBattleVillageRaid").disabled = !hasTroops;
    $("#btnBattleSiege").disabled       = !hasTroops;


// Village capacity hint: recruiting uses capacity, but battles are allowed regardless.
    if(!hasVillageCapacity()){
    }

    // Temple
    $("#crowns").textContent = fmt(S.crowns);
    $("#offerCost").textContent = `Cost ${fmt(offerCost())}`;
    $("#faithNow").textContent = `Faith ${fmt(S.faith)}`;
    $("#critRate").textContent = Math.round(critChance()*100) + "%";
    const buffLeft = Math.max(0, Math.ceil((S.buffUntil - Date.now())/1000));
    $("#buffLeft").textContent = buffLeft + "s";
    const blessCd = Math.max(0, Math.ceil((S.blessReadyAt - Date.now())/1000));
    $("#blessDesc").textContent = blessCd>0 ? `CD ${blessCd}s ‚Ä¢ doubles crits` : `Ready ‚Ä¢ doubles crits`;
    $("#btnBless").disabled = blessCd>0;
    const crownsGain = ascendCrownGain();
    $("#ascendDesc").textContent = crownsGain>0 ? `Reset for +${crownsGain} crowns` : `Need 25,000 renown`;


    // Territories (named lands)
    const terrCount = territoryCount();
    if($("#territoryCount")) $("#territoryCount").textContent = fmt(terrCount);
    if($("#landTotal")) $("#landTotal").textContent = fmt(S.land||0);

    // Land output summary
    const landDen = landBaseIncome();
    const landPop = landBasePopCap();
    if($("#landOutputDen")) $("#landOutputDen").textContent = `+${fmt(landDen)} Denarii / tick`;
    if($("#landOutputPop")) $("#landOutputPop").textContent = `+${fmt(landPop)} Cap`;

    // HUD Land counters show numeric land
    if($("#landHud"))    $("#landHud").textContent = fmt(S.land||0);
    if($("#landLegion")) $("#landLegion").textContent = fmt(S.land||0);

    
    const listEl  = $("#territoryList");
    const emptyEl = $("#territoryEmpty");
    const summaryEl = $("#landSummaryBlock");

    const arr = Array.isArray(S.controlledRegions) ? S.controlledRegions : [];

    // Compact land summary line, tied to the cards below
    if(summaryEl){
      if(!arr.length){
        summaryEl.style.display = "none";
        summaryEl.textContent = "";
      }else{
        summaryEl.style.display = "block";
        summaryEl.textContent = `Controlled Land ‚Äî ${fmt(arr.length)} Territories`;
      }
    }

    if(listEl){
      listEl.innerHTML = "";

      if(emptyEl){
        emptyEl.style.display = arr.length ? "none" : "block";
      }

      // Group territories by type so each card shows Owned: X
      const grouped = {};
      for(const terr of arr){
        if(!grouped[terr.name]){
          grouped[terr.name] = {
            count: 0,
            summary: terr.summary,
            den: 0,
            cap: 0
          };
        }
        const g = grouped[terr.name];
        g.count += 1;
        const eff = LAND_TYPE_EFFECTS[terr.name] || {};
        if(eff.den) g.den += eff.den;
        if(eff.pop) g.cap += eff.pop;
      }

      // Render one card per land type
      Object.entries(grouped).sort((a,b)=>a[0].localeCompare(b[0])).forEach(([name,info])=>{
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "smallBtn territoryCard";

        btn.innerHTML = `
          <div class="territoryCardHeader">
            <div class="t">${name}</div>
            <div class="territoryOwnedTag">Owned: ${fmt(info.count)}</div>
          </div>
          <div class="d" style="text-align:left;">
            ${info.den ? "&#x1F4B0; +" + fmt(info.den) + " Denarii (Income)<br>" : ""}
            ${info.cap ? "&#x1F465; +" + fmt(info.cap) + " Cap (Population)<br>" : ""}
            <span class="territoryFlavor">${info.summary || "Claimed territory."}</span>
          </div>
        `;
        listEl.appendChild(btn);
      });
    }
// Stats
    const body = $("#statsTable");
    if(body){
      body.innerHTML = "";
      for(const [k,v] of statsRows()){
        const tr = document.createElement("tr");
        const td1 = document.createElement("td");
        const td2 = document.createElement("td");
        td1.textContent = k;
        td2.textContent = (typeof v === "number") ? fmt(v) : String(v);
        tr.appendChild(td1); tr.appendChild(td2);
        body.appendChild(tr);
      }
    }

    // global
    renderTabs();
    renderObjectives();
    $("#subline").textContent = (Date.now() < (S.prosperUntil||0))
      ? "Prosperity active ‚Äî income is boosted."
      : (isBuffed()
          ? "Blessing active ‚Äî crits are juiced."
          : "Unlock tabs by earning renown. Prestige later for crowns.");
    save(true);
  }

  // ---- Actions ----
  $("#btnTribute").addEventListener("click", (e)=>{
    applyStreak();
    const {gain, crit} = tapGain();

    // Jackpots: rare huge spikes layered on top of small taps
    const jp = rollJackpot();
    let jackpotGain = 0;
    if(jp){
      // Jackpot scales with your effective tap gain (already includes multipliers)
      jackpotGain = Math.round(gain * jp.mult);
      toast(jp.type + "!");
      logLine(`${jp.type}! (+${fmt(jackpotGain)} denarii)`, "good");
    }

    S.gold += (gain + jackpotGain);
    S.lifetimeGold += (gain + jackpotGain);

    bumpObjective("tap", 1);
    bumpEarnedDenarii(gain + jackpotGain);
    // Renown is now battle-only; no passive renown from tapping.
    S.power += 1 + (crit ? 1 : 0);

    // Streak taps occasionally attract a new settler directly (population dopamine).
    if(hasVillageCapacity()){
      const s = Math.max(1, S.streak || 1);
      if(s > 1 && s % 5 === 0){
        const beforePop = S.population || 0;
        S.population = Math.min(populationCap(), beforePop + 1);
        if(S.population > beforePop){
          logLine("A villager is impressed by your prosperity and settles in your village.", "good");
          const settlerRect = e.currentTarget.getBoundingClientRect();
          sparkAt(
            settlerRect.left + settlerRect.width * 0.28,
            settlerRect.top  + settlerRect.height * 0.25,
            0.45
          );
        }
      }
    }

    const rect = e.currentTarget.getBoundingClientRect();
    const goldness = crit ? 0.95 : 0.25;
    sparkAt(rect.left + rect.width*0.78, rect.top + rect.height*0.42, goldness);

    if(jp){ for(let i=0;i<3;i++) sparkAt(rect.left + rect.width*(0.55 + i*0.12), rect.top + rect.height*0.30, 0.70); }

    if(crit){ toast("CRIT!"); logLine(`CRIT tribute! (+${fmt(gain)} denarii)`, "good"); }
    else if(S.streak % 7 === 0) logLine(`Tribute collected. (+${fmt(gain)} denarii)`, "good");

    // gentle soft cap
    S.power = clamp(S.power, 0, 99999);
    
    // Cash Out: bank some value as you tap; becomes claimable every few taps.
    S.tapsSinceCashout += 1;
    bankCashout(gain + Math.round(jackpotGain*0.08));
    

    // Chance for a defensive/local skirmish popup (does not break streak)
    maybeSpawnDefenceFromTap();
    
    render();

  });

  $("#btnHut").addEventListener("click", ()=>{
    const c = costHut();
    if(S.gold < c){ toast("Not enough denarii"); return; }
    S.gold -= c;
    S.hutCount = (S.hutCount||0) + 1;
    toast("Huts raised ‚Äî word spreads");
    render();
  });

  $("#btnFarm").addEventListener("click", ()=>{
    const c = costFarm();
    if(S.gold < c){ toast("Not enough denarii"); return; }
    S.gold -= c;
    S.farmCount += 1;
    bumpObjective("buildFarm", 1);
    // Renown removed here; battles now grant renown.
    logLine("A farm feeds your people. (+income)", "good");
    toast("Village capacity grows");
    render();
  });

  $("#btnVilla").addEventListener("click", ()=>{
    const c = costVilla();
    if(S.gold < c){ toast("Not enough denarii"); return; }
    S.gold -= c;
    S.villaCount += 1;
    bumpObjective("buildVilla", 1);
    // Renown removed here; battles now grant renown.
    logLine("A villa rises. The taxes flow.", "good");
    toast("Village capacity grows");
    render();
  });
  $("#btnRecruit").addEventListener("click", (e)=>{
  const c = recruitCost();
  if(S.gold < c){
    toast("Not enough denarii");
    return;
  }

  // You can only recruit if you have an unassigned settler to train.
  // (Population is filled slowly up to the cap by "settlers".)
  const pop = S.population || 0;
  const warriors = S.warriors || 0;
  const civilians = Math.max(0, pop - warriors);

  if(civilians < 1){
    toast("No free settlers ‚Äî build housing and wait for more to arrive");
    return;
  }

  // Pay the cost and convert 1 civilian into a milites.
  S.gold -= c;
  S.warriors = warriors + 1;
  S.populationUsed = S.warriors; // keep pop-used in sync with milites

  recalcLegionStrength();

  // Recruiting progresses recruit-related objectives.
  bumpObjective("recruit", 1);

  // Nice but safe coin spark (no undefined payout!)
  const rect = e.currentTarget.getBoundingClientRect();
  const goldness = clamp(0.35 + (S.warriors || 0) * 0.015, 0.35, 0.9);
  sparkAt(
    rect.left + rect.width * 0.80,
    rect.top  + rect.height * 0.45,
    goldness
  );

  toast("Recruited");
  logLine(`A milites joins your banner. (Milites: ${fmt(S.warriors)})`, "good");

  render();
});
// ---- Defensive/local skirmish popups ----

// We piggyback off taps: occasionally, your lands are tested.
// These are *defensive* battles: no land gain, just gold + renown.
// Ignoring them is safe but costly (gold + renown loss).

function defenceSpawnChance(){
  const wins = S.battlesWon || 0;
  // Starts small, ramps up as your realm gets bloodier
  const base = 0.012;
  const extra = Math.min(wins * 0.0006, 0.02);
  return base + extra;
}

function defenceIgnoreCostDen(){
  const gold = S.gold || 0;
  const tier = battleTierFromTitleIdx(titleInfo().idx);
  // 6‚Äì18% of current gold, scaled by title tier, with a floor
  const pct = 0.06 + tier * 0.02;
  const pctLoss = Math.round(gold * pct);
  const floor = 12 + tier * 9;
  return Math.max(floor, pctLoss);
}

function defenceIgnoreCostRen(){
  const tier = battleTierFromTitleIdx(titleInfo().idx);
  // Small but non-trivial hit to reputation
  return Math.max(1, tier * 3);
}

function maybeSpawnDefenceFromTap(){
  // Don‚Äôt stack multiple popups, don‚Äôt fire during intro, and only if you actually have troops
  if(window.defenceOverlayOpen) return;
  if(!S.introBattleDone) return;
  if((S.warriors || 0) <= 0) return;

  if(Math.random() > defenceSpawnChance()) return;

  const slot = 0; // use the lowest slot as a local-border defence template
  const b = currentBattleSet()[slot];
  if(!b) return;

  openDefencePopup(slot, b);
}




function openDefencePopup(slot, battle){
  if(window.defenceOverlayOpen) return;
  window.defenceOverlayOpen = true;

  // Protect the streak window while the player is reading this
  S.lastTap = Date.now();

  const overlay = document.createElement("div");
  overlay.id = "defencePopup";
  overlay.style.position = "fixed";
  overlay.style.inset = "0";
  overlay.style.background = "rgba(0,0,0,0.55)";
  overlay.style.display = "flex";
  overlay.style.alignItems = "center";
  overlay.style.justifyContent = "center";
  overlay.style.zIndex = "1600";

  const card = document.createElement("section");
  card.className = "card";
  card.style.maxWidth = "420px";
  card.style.margin = "0 14px";

  const header = document.createElement("div");
  header.className = "sectionTitle";

  // Risk icon based on size of the raid
  const min = battle.enemyMin || 5;
  const max = battle.enemyMax || (min + 10);
  let riskWord = "Small raid";
  let riskIcon = "üü¢";
  if(max >= 60){ riskWord = "Large warband"; riskIcon = "üî¥"; }
  else if(max >= 30){ riskWord = "Raiding party"; riskIcon = "üü†"; }

  header.innerHTML = `<span style="font-weight:700;color:var(--text)">Defence</span>`;

  const bodyWrap = document.createElement("div");
  bodyWrap.className = "cardBody";

  const title = document.createElement("div");
  title.textContent = battle.label;
  title.style.fontFamily = "var(--mono)";
  title.style.fontSize = ".86rem";
  title.style.fontWeight = "700";
  title.style.color = "var(--text)";
  title.style.marginBottom = "4px";

  const desc = document.createElement("div");
  desc.style.fontSize = ".8rem";
  desc.style.marginBottom = "10px";
  desc.textContent = "Enemy raiders are disrupting your lands.";

  const stats = document.createElement("div");
  stats.style.fontFamily = "var(--mono)";
  stats.style.fontSize = ".78rem";
  stats.style.border = "1px solid rgba(158,104,54,.6)";
  stats.style.borderRadius = "12px";
  stats.style.padding = "8px 10px";
  stats.style.marginBottom = "12px";
  stats.style.background = "rgba(255,255,255,0.45)";

  let enemyLine;
  if(min === max){
    enemyLine = `Enemies: ${min} (${riskWord})`;
  }else{
    enemyLine = `Enemies: ${min}‚Äì${max} (${riskWord})`;
  }
  const defendersLine = `Defenders Available: ${fmt(S.warriors||0)} milites`;

  stats.innerHTML = `<div>${enemyLine}</div><div>${defendersLine}</div>`;

  const costsDen = defenceIgnoreCostDen();
  const costsRen = defenceIgnoreCostRen();

  const actions = document.createElement("div");
  actions.style.display = "flex";
  actions.style.flexDirection = "column";
  actions.style.gap = "8px";

  const btnEngage = document.createElement("button");
  btnEngage.className = "smallBtn";
  btnEngage.innerHTML = `<div class="t">üõ°Ô∏è Defend</div><div class="d">Risk milites, no payment.</div>`;

  const btnIgnore = document.createElement("button");
  btnIgnore.className = "smallBtn";
  btnIgnore.innerHTML = `<div class="t">üí∞ Buy Them Off ‚Äî ${fmt(costsDen)}d, ${fmt(costsRen)}r</div><div class="d">Avoid casualties.</div>`;

  btnEngage.addEventListener("click", ()=>{
    closeDefencePopup(overlay);
    // Refresh lastTap so streak window resumes from now
    S.lastTap = Date.now();
    // Run this as a *defensive* battle: no land, different rewards
    doBattle(slot, { defence: true });
  });

  btnIgnore.addEventListener("click", ()=>{
    const costDen = defenceIgnoreCostDen();
    const costRen = defenceIgnoreCostRen();

    const goldLoss = Math.min(costDen, S.gold || 0);
    S.gold = (S.gold || 0) - goldLoss;
    S.renown = Math.max(0, (S.renown || 0) - costRen);

    closeDefencePopup(overlay);
    S.lastTap = Date.now();

    toast("You pay them off.");
    logLine(
      `You buy off raiders instead of fighting. -${fmt(goldLoss)} denarii, -${fmt(costRen)} renown.`,
      "warn"
    );
    render();
  });

  actions.appendChild(btnEngage);
  actions.appendChild(btnIgnore);

  bodyWrap.appendChild(title);
  bodyWrap.appendChild(desc);
  bodyWrap.appendChild(stats);
  bodyWrap.appendChild(actions);

  card.appendChild(header);
  card.appendChild(bodyWrap);

  overlay.appendChild(card);
  document.body.appendChild(overlay);
}


function closeDefencePopup(overlay){
  window.defenceOverlayOpen = false;
  try{
    if(overlay && overlay.parentNode){
      overlay.parentNode.removeChild(overlay);
    }
  }catch(e){}
}

  // Land allocation buttons: tap to assign a plot if any are free.
  function adjustLandAllocation(key){
    const free = freeLandPlots();
    if(free <= 0){
      toast("No free plots ‚Äî win more land in battle.");
      return;
    }
    switch(key){
      case "agriculture": S.landAgriculture = (S.landAgriculture||0) + 1; break;
      case "military":    S.landMilitary    = (S.landMilitary||0) + 1; break;
      case "housing":     S.landHousing     = (S.landHousing||0) + 1; break;
      case "governance":  S.landGovernance  = (S.landGovernance||0) + 1; break;
    }
    toast("Plot allocated");
    render();
    if(typeof scheduleSave === "function") scheduleSave();
  }

  $("#landAgricultureBtn") && $("#landAgricultureBtn").addEventListener("click", ()=>adjustLandAllocation("agriculture"));
  $("#landMilitaryBtn") && $("#landMilitaryBtn").addEventListener("click", ()=>adjustLandAllocation("military"));
  $("#landHousingBtn") && $("#landHousingBtn").addEventListener("click", ()=>adjustLandAllocation("housing"));
  $("#landGovernanceBtn") && $("#landGovernanceBtn").addEventListener("click", ()=>adjustLandAllocation("governance"));

  
    
// --- Battle Report overlay (after every battle) ---

function showBattleReport(rep){
  const overlay = document.getElementById("battleOverlay");
  const body = document.getElementById("battleBody");
  const title = document.getElementById("battleTitle");
  if(!overlay || !body || !title) return;

  const denChange = rep.denDelta || 0;
  const landChange = rep.landDelta || 0;
  const renChange = rep.renDelta || 0;
  const slotsChange = rep.landSlots || 0; // kept for mechanics, not shown in UI

  title.textContent = rep.win ? "Battle Victory!" : "Battle Defeat";

  const lines = [];
  lines.push(rep.win ? "Battle Victory!" : "Battle Defeat.");

  if(rep.win){
    const names = Array.isArray(rep.territoryNames) ? rep.territoryNames : [];
    if(names.length > 0){
      // Group captured territory names into a "Captured:" section
      lines.push("Captured:");
      const counts = {};
      for(const n of names){
        counts[n] = (counts[n]||0) + 1;
      }
      Object.entries(counts).sort((a,b)=>a[0].localeCompare(b[0])).forEach(([name,count])=>{
        lines.push(`‚Ä¢ ${name} √ó${fmt(count)}`);
      });
    }else if(landChange > 0){
      // Fallback if we somehow gained land but have no names
      lines.push(`Captured: +${fmt(landChange)} land`);
    }else{
      lines.push("Captured: No new land");
    }
  }

  if(renChange !== 0){
    const r = renChange;
    lines.push(`${r > 0 ? "+" : "‚àí"}${fmt(Math.abs(r))} Renown`);
  }

  {
    const d = denChange;
    const denLabel = `${d >= 0 ? "+" : "‚àí"}${fmt(Math.abs(d))} Denarii`;
    lines.push(denLabel);
  }

  lines.push(`Milites lost: ${fmt(rep.losses || 0)}`);

  body.innerHTML = `
    <div class="battleSummaryBlock">
      ${lines.map(l => `<div class="battleSummaryLine">${l}</div>`).join("")}
    </div>
    <div class="battleSummaryNote">
      ${rep.note || ""}
    </div>
  `;

  overlay.style.display = "flex";
  overlay.classList.add("visible");
}

function closeBattleReport(){
  const overlay = document.getElementById("battleOverlay");
  if(!overlay) return;
  overlay.classList.remove("visible");
  setTimeout(()=>{ overlay.style.display = "none"; }, 220);
}
window.closeBattleReport = closeBattleReport;
window.showBattleReport = showBattleReport;

// --- Battle Simulation (cinematic log before the report) ---
function battleFlavorByTier(tier){
  if(tier===1) return { place:["farm edge","stone well","fence line","grazing field"], foe:["brawlers","rustlers","feuding kin","thieves"] };
  if(tier===2) return { place:["clan boundary","ancestral fields","ridge path","cattle track"], foe:["militia","raiders","retainers","clansmen"] };
  if(tier===3) return { place:["river ford","hill pass","border track","seasonal camp"], foe:["warband","spearmen","archers","rival host"] };
  if(tier===4) return { place:["council field","palisade","sacred grove","road junction"], foe:["coalition host","rebels","shield wall","champions"] };
  if(tier===5) return { place:["valley pass","border march","stronghold approach","outer works"], foe:["host","defiant chiefs","veterans","garrison"] };
  return { place:["capital outskirts","campaign road","great plain","breached wall"], foe:["coalition army","claimants","elite guard","rival host"] };
}

function showBattleSimulation(rep, tier){
  const makeAsciiBar = (current, max, width = 12) => {
    if (max <= 0) return "‚ñë".repeat(width);
    const ratio  = max > 0 ? current / max : 0;
    const filled = clamp(Math.round(ratio * width), 0, width);
    const empty  = width - filled;
    return "‚ñà".repeat(filled) + "‚ñë".repeat(empty);
  };

  const overlay      = document.getElementById("battleSimOverlay");
  const title        = document.getElementById("battleSimTitle");
  const enemyNameEl  = document.getElementById("battleSimEnemyName");
  const enemyBarImg  = document.getElementById("battleSimEnemyBarImg");
  const yourBarImg   = document.getElementById("battleSimYourBarImg");
  const enemyBarCount = document.getElementById("enemyBarCount");
  const yourBarCount  = document.getElementById("yourBarCount");
  const enemyStatsEl = document.getElementById("battleSimEnemyStats");
  const yourStatsEl  = document.getElementById("battleSimYourStats");
  const eventsEl     = document.getElementById("battleSimEvents");
  const btnSkip      = document.getElementById("battleSimSkip");
  const btnContinue  = document.getElementById("battleSimContinue");

  if(
    !overlay || !title || !enemyNameEl ||
    !enemyBarImg || !yourBarImg || !enemyStatsEl || !yourStatsEl ||
    !eventsEl || !btnSkip || !btnContinue
  ){
    // Fallback: just show the report
    showBattleReport(rep);
    return;
  }

  title.textContent = rep.label;
  enemyNameEl.textContent = `${fmt(rep.enemies)} enemies`;

  // --- Troop counts ---
  const yourStart   = Math.max(0, rep.beforeWarriors || 0);
  const yourEndRaw  = Math.max(0, rep.afterWarriors  || 0);
  const enemyStart  = Math.max(0, rep.enemies        || 0);

  let yourEnd   = yourEndRaw;
  let enemyEnd  = enemyStart;

  // Battles end when one bar hits zero:
  if(enemyStart <= 0){
    enemyEnd = 0;
  }else if(rep.win){
    enemyEnd = 0;
  }else{
    yourEnd = 0;
  }

  const totalYourLoss  = Math.max(0, yourStart  - yourEnd);
  const totalEnemyLoss = Math.max(0, enemyStart - enemyEnd);

  // Small static stats under each bar (final state)
  if(enemyStatsEl){
    enemyStatsEl.textContent =
      `${makeAsciiBar(enemyEnd, enemyStart)}  ${fmt(enemyEnd)} / ${fmt(enemyStart)}`;
  }
  if(yourStatsEl){
    yourStatsEl.textContent =
      `${makeAsciiBar(yourEnd, yourStart)}  ${fmt(yourEnd)} / ${fmt(yourStart)}`;
  }

  // --- Battle log: ultra-short, dopamine-heavy beats (A-style) ---
  const f = battleFlavorByTier(tier);
  const place = f.place[rnd(0, f.place.length - 1)];
  const foe   = f.foe[rnd(0, f.foe.length - 1)];
  const odds  = rep.winP || 0;

  const yourLossPct  = Math.round(100 * (rep.losses       / Math.max(1, yourStart   || 1)));
  const youMax       = Math.max(1, yourStart || 0);
  const enemyMax     = Math.max(1, enemyStart || 0);
  const strengthRatio = youMax / enemyMax;

  const close     = odds > 0.40 && odds < 0.70;
  const desperate = odds <= 0.40;

  const lines = [];
  const pushEntry = (text, tone = "") => {
    lines.push({ text, tone });
  };

  // 1) CLASH ‚Äî instant context + light tension
  pushEntry(
    `‚öî Clash ‚Äî your ${fmt(yourStart)} milites hit ${fmt(enemyStart)} ${foe} at the ${place}.`,
    "warn"
  );

  // 2) TURN ‚Äî one big swing, no micro spam
  if(rep.win){
    if(desperate){
      pushEntry("üî• Break ‚Äî underdogs hold, then roll their front back.", "good");
    }else if(close){
      pushEntry("üî• Break ‚Äî a flank push opens a gap and flips momentum.", "good");
    }else if(strengthRatio >= 1.4){
      pushEntry("üî• Smash ‚Äî your weight slams straight through their centre.", "good");
    }else{
      pushEntry("üî• Push ‚Äî your shieldwall grinds them away from the village.", "good");
    }
  }else{
    if(desperate){
      pushEntry("üí• Collapse ‚Äî numbers wash over you; pockets fight on alone.", "bad");
    }else if(close){
      pushEntry("üí• Slip ‚Äî a small break on the flank snowballs into a rout.", "bad");
    }else{
      pushEntry("üí• Overrun ‚Äî their line walks yours backwards, step by step.", "bad");
    }
  }

  // 3) PAYOFF ‚Äî single summary line (rewards + losses)
  const denChange  = rep.denDelta  || 0;
  const landChange = rep.landDelta || 0;

  const parts = [];
  if(denChange !== 0){
    parts.push(`${denChange > 0 ? "+" : "‚àí"}${fmt(Math.abs(denChange))}d`);
  }
  if(landChange !== 0){
    parts.push(`${landChange > 0 ? "+" : "‚àí"}${fmt(Math.abs(landChange))} land`);
  }
  if(rep.losses > 0){
    const lossBand =
      yourLossPct <= 6  ? "light losses" :
      yourLossPct <= 18 ? "steady losses" :
      "heavy losses";
    parts.push(`${fmt(rep.losses)} lost (${lossBand})`);
  }else{
    parts.push("no losses");
  }

  const summary = parts.join(" ‚Ä¢ ") || "no spoils";

  if(rep.win){
    pushEntry(`üèÜ Victory ‚Äî enemy scatters. ${summary}.`, "good");
  }else{
    pushEntry(`‚ò† Defeat ‚Äî you fall back. ${summary}.`, "bad");
  }

  // --- Health-bar-friendly step curve ---
  const STEPS = 12; // bar story: clash -> swing -> collapse
  const yourSteps  = [];
  const enemySteps = [];

  for(let i = 0; i <= STEPS; i++){
    const t = STEPS > 0 ? (i / STEPS) : 1;
    const ys = Math.round(yourStart  - totalYourLoss  * t);
    const es = Math.round(enemyStart - totalEnemyLoss * t);
    yourSteps.push(ys);
    enemySteps.push(es);
  }

  // Indices where text lines should appear (synced to bar drama)
  const clashStep = 1;
  const breakStep = Math.round(STEPS * 0.5);
  const endStep   = STEPS;

  const barIndexFromCounts = (current, max)=>{
    if(max <= 0) return 0;
    const ratio = clamp(current / max, 0, 1);
    const curved = Math.pow(ratio, 1.25);
    const idx = Math.round(curved * 10);
    return clamp(idx, 0, 10);
  };

  const barSpritePath = (side, idx)=>{
    const base = "Sprites/player and enemy bars/";
    if(side === "player"){
      if(idx <= 0) return base + "Player bar depleted.png";
      if(idx >= 10) return base + "Player bar full.png";
      return base + `Player bar ${idx} out 10.png`;
    }else{
      if(idx <= 0) return base + "enemy bar depleted.png";
      if(idx >= 10) return base + "enemy bar full.png";
      return base + `enemy bar ${idx} out 10.png`;
    }
  };

  let lastYourCount  = yourStart;
  let lastEnemyCount = enemyStart;

  const triggerBarShake = (imgEl)=>{
    if(!imgEl) return;
    const wrapper = imgEl.closest(".battleBar");
    if(!wrapper) return;
    wrapper.classList.remove("barShake");
    void wrapper.offsetWidth;
    wrapper.classList.add("barShake");
  };

  const applyStep = (stepIndex)=>{
    // Clamp into range 0..STEPS
    const i = clamp(stepIndex, 0, STEPS);
    const yNow = yourSteps[i];
    const eNow = enemySteps[i];

    const tookY = yNow < lastYourCount;
    const tookE = eNow < lastEnemyCount;
    if(tookY) triggerBarShake(yourBarImg);
    if(tookE) triggerBarShake(enemyBarImg);
    lastYourCount  = yNow;
    lastEnemyCount = eNow;

    const yourIdx  = barIndexFromCounts(yNow, yourStart);
    const enemyIdx = barIndexFromCounts(eNow, enemyStart);

    if(yourBarImg)  yourBarImg.src  = barSpritePath("player", yourIdx);
    if(enemyBarImg) enemyBarImg.src = barSpritePath("enemy", enemyIdx);

    if(enemyBarCount) enemyBarCount.textContent = `${fmt(eNow)} / ${fmt(enemyStart)}`;
    if(yourBarCount)  yourBarCount.textContent  = `${fmt(yNow)} / ${fmt(yourStart)}`;
  };

  // Log rendering helper
  const MAX_VISIBLE_LINES = 4;

  const appendLine = (entry)=>{
    if(!entry) return;
    const div = document.createElement("div");
    div.className = "simEventLine";

    if(entry && typeof entry === "object"){
      div.textContent = entry.text || "";
      if(entry.tone === "good" || entry.tone === "bad" || entry.tone === "warn"){
        div.classList.add(entry.tone);
      }
    }else{
      div.textContent = entry;
    }

    eventsEl.appendChild(div);

    while(eventsEl.children.length > MAX_VISIBLE_LINES){
      eventsEl.removeChild(eventsEl.firstChild);
    }
  };

  // Initial visual state
  eventsEl.innerHTML = "";
  btnContinue.style.display = "none";
  applyStep(0);

  overlay.style.display = "flex";
  overlay.classList.add("visible");

  let stepIndex = 0;
  let timer = null;
  let nextLineIdx = 0;

  const TICK_MS = 550; // overall battle length ~ 6‚Äì7s

  const tick = ()=>{
    if(stepIndex >= STEPS){
      // ensure final frame
      applyStep(STEPS);
      if(timer){ clearInterval(timer); timer = null; }
      btnContinue.style.display = "inline-flex";
      return;
    }

    stepIndex = Math.min(stepIndex + 1, STEPS);
    applyStep(stepIndex);

    // Trigger log lines on key bar moments
    if(stepIndex === clashStep && nextLineIdx < lines.length){
      appendLine(lines[nextLineIdx++]);
    }
    if(stepIndex === breakStep && nextLineIdx < lines.length){
      appendLine(lines[nextLineIdx++]);
    }
    if(stepIndex === endStep && nextLineIdx < lines.length){
      appendLine(lines[nextLineIdx++]);
    }
  };

  timer = setInterval(tick, TICK_MS);
  // Prime first tick so there's no initial delay
  tick();

  const finish = ()=>{
    overlay.classList.remove("visible");
    if(timer){ clearInterval(timer); timer = null; }
    setTimeout(()=>{ overlay.style.display = "none"; }, 220);
  };

  btnSkip.onclick = ()=>{
    finish();
    showBattleReport(rep);
    if(rep && rep.isIntro){
      toast("This is how legends are born.");
      logLine("First defence of the village: this is where your legend begins.", "good");
      if(typeof scheduleSave === "function") scheduleSave();
    }
  };

  btnContinue.onclick = ()=>{
    finish();
    showBattleReport(rep);
    if(rep && rep.isIntro){
      toast("This is how legends are born.");
      logLine("First defence of the village: this is where your legend begins.", "good");
      if(typeof scheduleSave === "function") scheduleSave();
    }
  };
}function startIntroBattle(){
  if(S.introBattleDone) return;
  S.introBattleDone = 1;

  // Remember pre-intro forces so the visiting warband can leave afterwards
  const prevWarriors = S.warriors || 0;
  const prevPopulation = S.population || 0;

  // Ensure a small visiting warband so the battle feels real
  let warriors = S.warriors || 0;
  let population = S.population || 0;
  if(warriors < 12){
    const add = 12 - warriors;
    warriors += add;
    population += add;
  }
  S.warriors = warriors;
  S.population = population;
  S.populationUsed = S.warriors;

  // Use the new battleSim to decide how bloody the intro feels,
  // but always treat it as a hard-won victory in the story.
  const beforeWarriors = S.warriors || 0;
  const introSlot = 0; // first battle tier (usually bandits)
  const sim = battleSim(introSlot);

  // Derive casualties from the sim, but clamp to a "narrow win" band.
  let simLosses = sim && typeof sim.losses === "number" ? sim.losses : Math.round(beforeWarriors * 0.35);
  const minLoss = Math.max(1, Math.round(beforeWarriors * 0.22));
  const maxLoss = Math.max(minLoss, Math.round(beforeWarriors * 0.55));
  const losses = clamp(simLosses, minLoss, maxLoss);

  const afterWarriorsIntro = Math.max(0, beforeWarriors - losses);

  // Enemy numbers from the sim, or a fallback
  const enemies = sim && typeof sim.enemies === "number"
    ? sim.enemies
    : beforeWarriors + rnd(4, 10);

  // Modest early reward so the opener feels impactful
  const denGain = 16;
  const landGain = 0; // Tutorial battle: no land granted
  const renGain = 4;

  S.gold += denGain;
  S.lifetimeGold += denGain;
  // Do NOT grant land for the intro battle ‚Äì rewards are denarii + renown only.
  S.renown = (S.renown || 0) + renGain;
  S.lifetimeRenown = (S.lifetimeRenown || 0) + renGain;

  const rep = {
    label: "First Defence of the Village",
    enemies,
    // Show whatever odds the sim estimated, but the story always counts this as a win.
    winP: sim && typeof sim.winP === "number" ? sim.winP : 0.56,
    win: true,
    beforeWarriors,
    afterWarriors: afterWarriorsIntro,
    losses,
    denDelta: denGain,
    landDelta: landGain,
    renDelta: renGain,
    landSlots: 0,
    territoryNames: [],
    note: "You hold the field when it should have broken.",
    isIntro: true
  };

  // The visiting warband that saved you marches on; you're left as you were before,
  // with only the scars and spoils to show for it.
  S.warriors = prevWarriors;
  S.population = prevPopulation;
  S.populationUsed = S.warriors;

  const introLines = [
    "Battle Victory!",
    "Captured: (tutorial ‚Äì no new land)",
    `+${fmt(renGain)} Renown`,
    `+${fmt(denGain)} Denarii`,
    `Milites lost: ${fmt(losses)}`
  ];

  logLine(introLines.join("\n"), "good");
  logLine("The warband that saved your village marches on, leaving you to build your own legion.", "warn");
  toast("The village stands. Barely.");
  showBattleSimulation(rep, 1);
  render();
  if(typeof scheduleSave === "function") scheduleSave();
}

window.startIntroBattle = startIntroBattle;

// --- Battle execution (rank-based) ---
// Optional second arg opts: { defence: true } for pop-up defence battles
function doBattle(slot, opts){
  opts = opts || {};
  const isDefence = !!opts.defence;

  const now = Date.now(); // cooldown disabled
  const b = currentBattleSet()[slot];
  if(!b){ toast("No battle available"); return; }

  // Minimal requirement: you need at least *some* milites for offensive campaigns.
  const w = (S.warriors || 0);
  if (!isDefence && w <= 0) {
    toast("You have no milites to muster.");
    return;
  }

  const sim = battleSim(slot);
  const beforeWarriors = S.warriors||0;
  const startGold = S.gold;
  const startLand = S.land||0;
  const startRenown = S.renown||0;

  // Soft warning: under-strength force vs enemy numbers / odds (no hard gate)
  if (!isDefence && sim && typeof sim.enemies === "number") {
    const enemies = sim.enemies;
    const winP = typeof sim.winP === "number" ? sim.winP : 0.5;

    // ‚ÄúRecommended‚Äù force: ~40% of enemy count
    const recommended = Math.max(1, Math.round(enemies * 0.4));

    if (beforeWarriors > 0 && beforeWarriors < recommended && winP < 0.75) {
      toast("Very risky with so few milites ‚Äî expect heavy losses.");
    }
  }

  // Apply casualties
  let losses = Math.min(beforeWarriors, sim.losses);
  S.warriors = Math.max(0, beforeWarriors - losses);

  // Deaths remove population permanently.
  S.population = Math.max(0, (S.population||0) - losses);

  // Special case: if you would be left with exactly 1 milite,
  // treat this as your last soldier falling and apply a harsher consequence.
  if(S.warriors === 1){
    // That last milite is lost.
    S.warriors = 0;
    losses += 1;

    // More people drift away or are lost around the defeat.
    const popBefore = (S.population||0);
    const extraPopLoss = Math.min(popBefore, 1 + Math.round(popBefore * 0.05));
    S.population = Math.max(0, popBefore - extraPopLoss);

    // A portion of your denarii is stripped away in the chaos.
    const goldBefore = (S.gold||0);
    const extraGoldLoss = Math.round(goldBefore * 0.1);
    S.gold = Math.max(0, goldBefore - extraGoldLoss);
  }

  // Keep pop-used in sync with milites
  if((S.population||0) < (S.warriors||0)){
    // Safety clamp (shouldn't happen, but protects old saves)
    S.warriors = S.population;
  }
  S.populationUsed = S.warriors;

  recalcLegionStrength();

  // Loot / penalties
  let loot = 0;
  let landGain = 0;
  let capturedNames = [];
  let landSlotsGain = 0;

  if(sim.win){
    // Retire this enemy context so a new named foe can appear next time at this slot.
    if (S.battleContexts && sim && typeof sim.tier === "number") {
      const key = sim.tier + ":" + slot;
      delete S.battleContexts[key];
    }
    S.battlesWon = (S.battlesWon||0) + 1;

    const tier = sim.tier;
    const enemies = sim.enemies;
    const winP = sim.winP;

    // Base loot scales strongly with enemy count and tier
    const basePerEnemy = 4 + tier * 1.4; // 5.4‚Äì12.4 denarii per enemy
    let baseLoot = enemies * basePerEnemy;

    // Risk bonus: riskier fights (lower winP) pay more
    const riskBonus = 0.9 + (1 - winP) * 1.6; // 0.9x at 100% win, up to ~2.5x at very risky

    // Slight extra for higher tiers so late-game fights feel chunky
    const tierBonus = 1 + Math.max(0, tier - 1) * 0.18;

    loot = Math.round(baseLoot * riskBonus * tierBonus);

    if(isDefence){
      // --- DEFENSIVE BATTLE REWARD (no land, safer fantasy) ---
      loot = Math.max(5, Math.round(loot * 0.55));
      S.gold += loot;
      S.lifetimeGold += loot;
      bumpEarnedDenarii(loot);

      // Moderate renown for holding the line
      let renGain = Math.max(1, Math.round(enemies / 18) + tier * 2);
      renGain = Math.round(renGain * landAllocRenownMult());
      S.renown += renGain;
      S.lifetimeRenown += renGain;

      bumpObjective("winBattle", 1);
      maybeBurst("battle");

      toast("Village defended!");

      const yourLossPct = Math.round(100 * losses / Math.max(1, beforeWarriors || 1));
      let winTag;
      if(yourLossPct <= 6)       winTag = "Clean defence";
      else if(yourLossPct <= 18) winTag = "Hard defence";
      else                       winTag = "Pyrrhic defence";

      const lines = [];
      lines.push("Defence Successful!");
      lines.push(`‚Ä¢ ${b.label}`);
      lines.push("");
      lines.push(`+${fmt(renGain)} Renown`);
      lines.push(`+${fmt(loot)} Denarii`);
      lines.push(`Milites lost: ${fmt(losses)} (${winTag})`);

      logLine(lines.join("\\n"), "good");
    } else {
      // --- OFFENSIVE CAMPAIGN REWARD (normal land-granting battles) ---
      S.gold += loot;
      S.lifetimeGold += loot;
      bumpEarnedDenarii(loot);

      // Land gain: only from territorial battles (field actions, sieges, and some high-tier feuds)
      let baseLand = enemies / (42 - tier * 3); // generous at high tiers
      if(winP < 0.45) baseLand *= 1.35; // reward gutsy wins

      // Raw land from fight size (may be zeroed by archetype rules)
      let rawLand = Math.floor(Math.max(0, baseLand));
      rawLand = clamp(rawLand, 0, 10 + tier * 2);

      let territorial = 0;

      // Archetype-based land rules
      const arch = battleArchetypeFor(tier, slot);
      const kind = arch && arch.kind ? arch.kind : "";

      if(kind === "skirmish"){
        // Slot 1 / pressure: never land, just momentum and loot
        territorial = 0;
      }else if(kind === "feud"){
        // Feuds sometimes displace rivals at higher tiers
        if(tier >= 3 && Math.random() < 0.45){
          territorial = Math.max(1, rawLand || 1);
        }else{
          territorial = 0;
        }
      }else if(kind === "field"){
        // Territorial field actions: always at least 1 land on win
        territorial = Math.max(1, rawLand || 1);
      }else if(kind === "siege"){
        // Sieges / major control changes: heavier land swing
        territorial = Math.max(2, rawLand || 2);
      }else{
        // Fallback: behave like a cautious territorial battle
        territorial = Math.max(1, rawLand || 1);
      }

      landGain = territorial;

      if(landGain > 0){
        S.land = (S.land||0) + landGain;

        // capture named territories (1 per land gained)
        const newTerritories = [];
        for(let i=0;i<landGain;i++){
          const t = captureTerritory(tier);
          if(t) newTerritories.push(t);
        }
        capturedNames = newTerritories.map(t=>t.name);

        // Compute land-effect "slots" from land type system (pop contribution)
        landSlotsGain = 0;
        for(const terr of newTerritories){
          const eff = LAND_TYPE_EFFECTS && LAND_TYPE_EFFECTS[terr.name];
          if(eff && eff.pop) landSlotsGain += eff.pop;
        }
      } else {
        landSlotsGain = 0;
        capturedNames = [];
      }

      // Renown from big wins
      let renGain = Math.max(1, Math.round(loot/130) + Math.round(landGain*2) + tier*3);
      renGain = Math.round(renGain * landAllocRenownMult());
      S.renown += renGain;
      S.lifetimeRenown += renGain;

      bumpObjective("winBattle", 1);
      bumpObjective("gainLand", landGain);

      maybeBurst("battle");

      // Political capital: victories generate influence with your realm.
      const infGain = Math.max(1, Math.round(1 + sim.tier * 0.8 + landGain * 0.4));
      
      toast("Victory!");

      const yourLossPct = Math.round(100 * losses / Math.max(1, beforeWarriors || 1));
      let winTag;
      if(yourLossPct <= 6)       winTag = "Clean win";
      else if(yourLossPct <= 18) winTag = "Hard win";
      else                       winTag = "Pyrrhic win";

      const lines = [];
      lines.push("Battle Victory!");

      if(landGain > 0 && capturedNames.length){
        lines.push("Captured:");
        const counts = {};
        for(const name of capturedNames){
          counts[name] = (counts[name]||0) + 1;
        }
        Object.entries(counts).sort((a,b)=>a[0].localeCompare(b[0])).forEach(([name,count])=>{
          lines.push(`‚Ä¢ ${name} √ó${fmt(count)}`);
        });
      }else{
        lines.push("Captured: No new land");
      }

      lines.push(`+${fmt(S.renown - startRenown)} Renown`);
      lines.push(`+${fmt(loot)} Denarii`);
      lines.push(`Milites lost: ${fmt(losses)} (${winTag})`);

      logLine(lines.join("\\n"), "good");
    }
  }else{
    // Defeat path (same for both defence & offence ‚Äì flavour already good)
    const tier = sim.tier;
    const enemies = sim.enemies;

    // You lose some denarii and power, proportional to fight size.
    const lost = Math.round((enemies * (3 + tier*1.1)) * 0.4);
    S.gold = Math.max(0, (S.gold||0) - lost);
    S.power = Math.max(0, S.power - (3 + Math.floor(tier/2)));

    toast(isDefence ? "Defence lost" : "Defeat");

    const yourLossPct = Math.round(100 * losses / Math.max(1, beforeWarriors || 1));
    let lossTag;
    if(yourLossPct <= 12)      lossTag = isDefence ? "Breach at the edge" : "Setback";
    else if(yourLossPct <= 28) lossTag = "Bloody loss";
    else                       lossTag = "Crushing loss";

    logLine(
      `‚ò† ${b.label} ‚Äî ${lossTag}. -${fmt(lost)}d ‚Ä¢ -${fmt(losses)} milites`,
      "bad"
    );
  }

  // --- Legion morale & veterancy (hidden) ---
  const baseBefore = beforeWarriors || 0;
  const lossFracForMorale = baseBefore > 0 ? losses / baseBefore : 0;
  const fightSize = sim.enemies || 0;

  // Veterancy: bigger / harder fights teach more, even on losses
  let xpGain = 0;
  if(fightSize > 0){
    xpGain = Math.round(fightSize * (sim.win ? 0.7 : 0.45) * (1 + (sim.tier||1) * 0.22));
    if(lossFracForMorale > 0.6) xpGain = Math.round(xpGain * 1.15);
    if(xpGain < 1) xpGain = 1;
  }
  if(xpGain > 0){
    S.legionXp = (S.legionXp || 0) + xpGain;
  }

  let moraleVal = typeof S.legionMorale === "number" ? S.legionMorale : 1;
  if(sim.win){
    const gain = 0.10 + (1 - lossFracForMorale) * 0.25;
    moraleVal += gain;
  }else{
    const drop = 0.18 + lossFracForMorale * 0.5;
    moraleVal -= drop;
  }
  // Gentle pull back toward neutral over time
  moraleVal += (1 - moraleVal) * 0.08;
  S.legionMorale = clamp(moraleVal, 0.4, 2.2);

  // Soft flavour log so battles feel like they change the warband
  if(fightSize > 0 && xpGain > 0){
    if(sim.win){
      logLine("Your milites return more seasoned from the fighting.", "good");
    }else{
      logLine("Survivors carry hard lessons back to the village.", "warn");
    }
  }


  const rep = {
    label: b.label,
    enemies: sim.enemies,
    winP: sim.winP,
    win: sim.win,
    beforeWarriors,
    afterWarriors: S.warriors||0,
    losses,
    denDelta: Math.round(S.gold - startGold),
    landDelta: Math.round((S.land||0) - startLand),
    renDelta: Math.round((S.renown||0) - startRenown),
    landSlots: sim.win ? landSlotsGain : 0,
    territoryNames: sim.win ? (capturedNames || []) : [],
    note: sim.win
      ? (isDefence ? "You hold the fields around your village." : "You held the field and counted the fallen.")
      : "You retreat to lick your wounds."
  };

  // Show cinematic sim, then report
  showBattleSimulation(rep, sim.tier);
  render();
}
// Battle buttons
$("#btnBattleBandits1").addEventListener("click", ()=> doBattle(0));
$("#btnBattleLevy").addEventListener("click", ()=> doBattle(1));
$("#btnBattleVillageRaid").addEventListener("click", ()=> doBattle(2));
$("#btnBattleSiege").addEventListener("click", ()=> doBattle(3));


// Skirmish: optional combat later (tiny screen footprint)

  $("#btnOffer").addEventListener("click", ()=>{
    const c = offerCost();
    if(S.gold < c){ toast("Not enough denarii"); return; }
    S.gold -= c;
    const f = offerFaithGain();
    S.faith += f;
    // Renown is now battle-only; offerings no longer grant renown.

    // Temple objective
    bumpObjective("offerFaith", 1);

    toast("Blessed");
    render();
  });

  $("#btnBless").addEventListener("click", ()=>{
    const now = Date.now();
    if(now < S.blessReadyAt){ toast("Cooling down"); return; }
    S.blessReadyAt = now + blessCooldownMs();
    S.buffUntil = now + blessDurationMs();
    toast("Blessing!");
    render();
  });

  $("#btnAscend").addEventListener("click", ()=>{
    const gain = ascendCrownGain();
    if(gain <= 0){ toast("Need 25,000 renown"); return; }
    if(!confirm(`Ascend for +${gain} crowns? (Resets most progress)`)) return;

    const keepCrowns = (S.crowns || 0) + gain;
    const keepLifetimeGold = S.lifetimeGold || 0;
    const keepLifetimeRenown = S.lifetimeRenown || 0;
    const nextAscends = (S.ascends || 0) + 1;

    S = defaultState();
    S.crowns = keepCrowns;
    S.lifetimeGold = keepLifetimeGold;
    S.lifetimeRenown = keepLifetimeRenown;
    S.ascends = nextAscends;

    $("#log").innerHTML = "";
    logLine(`You ascend. Crowns: ${fmt(S.crowns)}. (Ascensions: ${S.ascends})`, "warn");
    toast("Ascended");
    save(true);
    setView("village");
  });

    $("#btnCashout").addEventListener("click", (e)=>{
    if(!cashoutReady()){ toast("Not ready"); return; }

    const payout = cashoutPotential();
    if(payout <= 0){ toast("No bonus"); return; }

    S.gold += payout;
    S.lifetimeGold += payout;
    bumpEarnedDenarii(payout);

    // Track biggest single cashout across all runs
    if(!S.biggestCashout || payout > S.biggestCashout){
      S.biggestCashout = payout;
    }

    // Cashing out resets streak: this is the decision point.
    S.streak = 1;
    S.lastTap = Date.now();

    // Short cooldown so players can't spam-cash at low streaks.
    S.cashoutCooldownUntil = Date.now() + CASHOUT_COOLDOWN_MS;

    const rect = e.currentTarget.getBoundingClientRect();
    sparkAt(rect.left + rect.width*0.55, rect.top + rect.height*0.55);

    // Cashout burst chance
    maybeBurst("cashout");

    toast("Cashed out!");
    logLine(`Cashed out for +${fmt(payout)} denarii`, "good");
    bumpObjective("cashout", 1);

    render();
  });

$("#btnExport").addEventListener("click", async ()=>{
    try{
      await navigator.clipboard.writeText(JSON.stringify(S));
      toast("Copied");
    }catch(e){
      toast("Clipboard blocked");
    }
  });

  $("#btnReset").addEventListener("click", ()=>{
    // Flavour confirm for New Game
    const msg = "Abandon your realm and begin anew?\nYour lands, wealth, and renown will be lost.";
    if(!confirm(msg)) return;

    // Wipe local save (best-effort)
    try{
      localStorage.removeItem(STORAGE_KEY);
    }catch(e){}

    // Fresh state: back to the very beginning
    S = defaultState();

    // Make absolutely sure intro is considered not done
    S.playerName = "";
    S.introBattleDone = 0;

    // Clear recent events log
    const logEl = $("#log");
    if(logEl) logEl.innerHTML = "";

    // Re-render base UI
    render();

    // Show the intro name screen again
    if(typeof maybeShowIntro === "function"){
      maybeShowIntro();
    }

    // Nice little flavour toast
    toast("A new story begins.");
  });

  // Tabs click
  $$(".tab").forEach(btn=>{
    btn.addEventListener("click", ()=> setView(btn.dataset.go));
  });

  // Passive tick (keeps progression going)
  let last = Date.now();
  setInterval(()=>{
    const now = Date.now();
    const dt = (now - last)/1000;
    last = now;

    // Passive income
    const inc = incomePerSec() * dt;
    if(inc > 0){
      S.gold += inc;
      S.lifetimeGold += inc;
    }

    // Objectives: passive income counts toward "Earn denarii"
    if(inc > 0) bumpEarnedDenarii(inc);


    // --- Milites upkeep: ties legion to village economy ---
    const upkeep = warriorUpkeepPerSec() * dt;
    if(upkeep > 0){
      const nowMs = Date.now();

      if(S.gold >= upkeep){
        // You can afford your forces: just pay.
        S.gold -= upkeep;

        // Gentle warning if upkeep is eating most of your income.
        const incomeNow = incomePerSec();
        if(
          incomeNow > 0 &&
          upkeep > incomeNow * 0.65 &&
          nowMs - (S.lastUpkeepWarnAt || 0) > 10000
        ){
          toast("Your milites are expensive ‚Äî build more farms and villas.");
          S.lastUpkeepWarnAt = nowMs;
        }
      }else{
        // Can't fully pay upkeep: you go broke and desertions start.
        const paid = S.gold;
        S.gold = 0;

        S.unpaidUpkeepSeconds = (S.unpaidUpkeepSeconds || 0) + dt;

        // Every few seconds of unpaid wages, some milites desert.
        if(S.unpaidUpkeepSeconds >= 6 && (S.warriors || 0) > 0){
          S.unpaidUpkeepSeconds -= 6;

          const before = S.warriors || 0;
          const lose = Math.max(1, Math.round(before * 0.06)); // ~6% desert
          S.warriors = Math.max(0, before - lose);

          // They leave the population as well (either gone or dead).
          S.population = Math.max(0, (S.population || 0) - lose);
          S.populationUsed = S.warriors;

          recalcLegionStrength();

          logLine(`${lose} milites deserted ‚Äî you could not pay them.`, "bad");

          if(nowMs - (S.lastUpkeepWarnAt || 0) > 6000){
            toast("Unpaid milites deserted your banner.");
            S.lastUpkeepWarnAt = nowMs;
          }
        }
      }
    }else{
      // No army ‚Üí no unpaid timer.
      S.unpaidUpkeepSeconds = 0;
    }


    // --- Settlers: population slowly fills up to your housing cap ---
    const cap = populationCap();
    if(typeof S.population !== "number") S.population = Math.max(0, S.populationUsed||0, S.warriors||0);
    if(typeof S.settlerProg !== "number") S.settlerProg = 0;

    // "Doing well" = better income + bigger settlement attracts more people.
    // Use the same helper the HUD uses so numbers stay in sync.
    const settleRatePerSec = migrationPerSec();


    if((S.population||0) < cap){
      S.settlerProg += settleRatePerSec * dt;
      const add = Math.floor(S.settlerProg);
      if(add > 0){
        S.settlerProg -= add;
        const before = S.population||0;
        S.population = Math.min(cap, before + add);
        const gained = S.population - before;
        if(gained > 0){
          logLine(`${gained} settler${gained===1?"":"s"} joined your village.`, "good");
          const now = Date.now();
          if(now - (S.lastSettlerToastAt||0) > 4000){
            toast(`üë• +${gained} settler${gained===1?"":"s"}`);
            S.lastSettlerToastAt = now;
          }
        }
      }
    }else{
      // bleed off progress so you don't "bank" settlers while capped
      S.settlerProg = Math.max(0, S.settlerProg - 0.25*dt);
    }

    // Keep pop-used synced with milites, and clamp old saves
    if((S.population||0) < (S.warriors||0)) S.warriors = S.population;
    S.populationUsed = S.warriors;


    render();
  }, 650);

  // First paint
  $("#log").innerHTML = "";
  logLine("A small village. A few denarii. A long road to the crown.", "warn");
  render();
  maybeShowIntro();
})();

  // Land tier unlock popup helpers
  function showLandTierUnlockPopup(tier, names){
    const overlay = document.getElementById('landTierOverlay');
    const listEl  = document.getElementById('landTierList');
    const textEl  = document.getElementById('landTierText');
    const btn     = document.getElementById('landTierOkBtn');
    if(!overlay || !listEl || !textEl || !btn) return;

    listEl.innerHTML = '';
    names.forEach(n => {
      const li = document.createElement('li');
      li.textContent = n;
      listEl.appendChild(li);
    });

    textEl.textContent = `Your new rank lets you claim:`;
    overlay.style.display = 'flex';

    btn.onclick = function(){
      overlay.style.display = 'none';
    };
  }

</script>

  
  <!-- Land Tier Unlock Overlay -->
  <div id="landTierOverlay" style="position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:1900;">
    <div style="position:absolute;inset:0;background:rgba(0,0,0,.55);"></div>
    <div class="card" style="position:relative;max-width:420px;width:92%;max-height:80vh;overflow:auto;z-index:10;">
      <div class="sectionTitle"><span>New Lands Unlocked</span><span></span></div>
      <div class="cardBody">
        <p id="landTierText" style="font-size:.85rem;margin:0 0 8px;">
          Your growing renown lets you claim new kinds of territory.
        </p>
        <ul id="landTierList" style="margin:4px 0 10px;padding-left:18px;font-size:.82rem;"></ul>
        <button class="primaryBtn" id="landTierOkBtn" type="button">Continue</button>
      </div>
    </div>
  </div>

<!-- Loot Chest Overlay -->
  <div id="chestOverlay" style="position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:2000;">
    <div id="chestBackdrop" style="position:absolute;inset:0;background:rgba(0,0,0,.55);backdrop-filter:blur(6px);"></div>
    <div id="chestCard" class="card" style="position:relative;width:min(520px, calc(100vw - 26px));border-radius:26px;overflow:hidden;">
      <div class="sectionTitle" style="justify-content:center;">
        <span id="chestTitle" style="color:var(--accent);font-weight:900;">Chest</span>
      </div>
      <div class="cardBody" style="text-align:center; padding:16px 14px 14px;">
        <div id="chestIcon" style="font-size:56px;line-height:1.0;filter:drop-shadow(0 12px 18px rgba(0,0,0,.25));">üß∞</div>
        <div id="chestHint" style="margin-top:10px;font-family:var(--mono);color:var(--muted);font-size:.80rem;">Tap to open</div>

        <div id="revealRow" style="margin-top:14px;display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px;">
          <div class="card" style="box-shadow:none;border-radius:18px;border-color:rgba(31,58,42,.75);">
            <div class="cardBody" style="padding:14px 10px;">
              <div class="pill" id="rev1" style="display:inline-block;">?</div>
            </div>
          </div>
          <div class="card" style="box-shadow:none;border-radius:18px;border-color:rgba(31,58,42,.75);">
            <div class="cardBody" style="padding:14px 10px;">
              <div class="pill" id="rev2" style="display:inline-block;">?</div>
            </div>
          </div>
          <div class="card" style="box-shadow:none;border-radius:18px;border-color:rgba(31,58,42,.75);">
            <div class="cardBody" style="padding:14px 10px;">
              <div class="pill" id="rev3" style="display:inline-block;">?</div>
            </div>
          </div>
        </div>

        <div id="chestSub" style="margin-top:12px;font-family:var(--sans);color:var(--muted);font-size:.78rem;line-height:1.25;">
          Tap each reward, then continue.
        </div>
        <button id="chestContinue" class="tab" style="margin-top:10px;width:100%;justify-content:center;display:none;">
          <span class="dot"></span>Continue
        </button>
      </div>
    </div>
  </div>


  <!-- Battle Report Overlay -->
  <div id="battleOverlay" style="position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:2100;">
    <div style="position:absolute;inset:0;background:rgba(0,0,0,.55);backdrop-filter:blur(6px);" onclick="closeBattleReport()"></div>
    <div id="battleCard" class="card" style="position:relative;width:min(560px, calc(100vw - 26px));border-radius:26px;overflow:hidden;">
      <div class="sectionTitle" style="justify-content:space-between;">
        <span id="battleTitle" style="color:var(--accent);font-weight:900;">Battle Report</span>
        <button class="tab" style="padding:8px 12px;" onclick="closeBattleReport()">Close</button>
      </div>
      <div class="cardBody" style="padding:14px;">
        <div id="battleBody"></div>
      </div>
    </div>
  </div>


  <!-- Battle Simulation Overlay -->
  <div id="battleSimOverlay" style="position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:2050;">
    <div style="position:absolute;inset:0;background:rgba(0,0,0,.55);backdrop-filter:blur(6px);"></div>
    <div id="battleSimCard" class="card" style="position:relative;width:min(560px, calc(100vw - 26px));border-radius:26px;overflow:hidden;">
      <div class="sectionTitle" style="justify-content:space-between;">
        <span id="battleSimTitle" style="color:var(--accent);font-weight:900;">Engagement</span>
        <div style="display:flex;gap:8px;align-items:center;">
          <button class="tab" style="padding:8px 12px;" id="battleSimSkip">Auto resolve</button>
        </div>
      </div>
      <div class="cardBody" style="padding:14px;">

        <div class="simMetaRow">
          <div class="simMetaLeft">
            <div class="simMetaLabel">ENEMY FORCE</div>
            <div class="simMetaText" id="battleSimEnemyName">0 enemies</div>
          </div>
        </div>
<div class="simBlock"> <div class="simLabel">Enemy</div> <div class="simBar"> <div class="battleBar"> <img id="battleSimEnemyBarImg" class="battleBarSprite" src="Sprites/player and enemy bars/enemy bar full.png" alt="Enemy bar"> <div class="battleBarCount battleBarCount--enemy" id="enemyBarCount"></div> </div> </div> <div class="simStats" id="battleSimEnemyStats"></div> </div> <div class="simBlock"> <div class="simLabel">Your force</div> <div class="simBar"> <div class="battleBar"> <img id="battleSimYourBarImg" class="battleBarSprite" src="Sprites/player and enemy bars/Player bar full.png" alt="Your bar"> <div class="battleBarCount battleBarCount--ally" id="yourBarCount"></div> </div> </div> <div class="simStats" id="battleSimYourStats"></div> </div>


        <div class="simEvents" id="battleSimEvents"></div>

        <button id="battleSimContinue" class="tab active" style="margin-top:10px;width:100%;justify-content:center;">
          <span class="dot"></span>View Report
        </button>
      </div>
    </div>
  </div>



<!-- === Battle Variety & Land Plausibility Patch (appended) === -->
