<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />



  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-title" content="ElderToKing">



  <link rel="apple-touch-icon" sizes="180x180" href="icons/icon-180.png">
  <link rel="apple-touch-icon" href="apple-touch-icon.png">



  <title>ElderToKing</title>
  <style>
    :root{
      --bg:#0b0f0c;
      --panel:#101a14;
      --panel2:#0d1511;
      --text:#e9f6ea;
      --muted:#a6d4ac;
      --accent:#f4d06f;
      --ok:#6be675;
      --warn:#ffcc66;
      --danger:#ff6b6b;
      --line:#1f3a2a;
      --shadow: 0 14px 36px rgba(0,0,0,.38);
      --radius:22px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    *{box-sizing:border-box;}
    html{font-size:19px;-webkit-text-size-adjust:100%;text-size-adjust:100%;}
    body{
      margin:0;
      min-height:100vh;
      padding: calc(6px + env(safe-area-inset-top)) 14px calc(92px + env(safe-area-inset-bottom));
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(900px 700px at 18% 0%, rgba(244,208,111,.13), transparent 55%),
        radial-gradient(900px 650px at 92% 25%, rgba(192,108,59,.10), transparent 55%),
        linear-gradient(180deg, #070a08, var(--bg));
      -webkit-tap-highlight-color: transparent;
    }
    .wrap{max-width:760px;margin:0 auto;display:flex;flex-direction:column;gap:12px;}
    header{
      position:relative; z-index:10;
      padding-bottom:10px;
      background: linear-gradient(180deg, rgba(11,15,12,.94), rgba(11,15,12,.55));
      backdrop-filter: blur(6px);
      border-bottom:1px solid rgba(31,58,42,.65);
    }
    .top{display:flex;align-items:flex-end;justify-content:space-between;gap:10px;padding:10px 2px 10px;}
    h1{margin:0;font-family:var(--mono);font-size:.85rem;letter-spacing:.5px;color:var(--accent);text-shadow: 0 0 14px rgba(244,208,111,.16);}
    .sub{margin:4px 0 0;color:var(--muted);font-size:.78rem;line-height:1.3;max-width:52ch;}
    .hud{display:flex;gap:8px;align-items:center;justify-content:flex-end;overflow:auto;scrollbar-width:none;}
    .hud::-webkit-scrollbar{display:none;}
    .pill{
      border:1px solid rgba(31,58,42,.9);
      background: linear-gradient(180deg, rgba(16,26,20,.92), rgba(13,21,17,.92));
      border-radius:999px;
      padding:10px 12px;
      box-shadow: var(--shadow);
      font-family:var(--mono);
      font-size:.78rem;
      white-space:nowrap;
      user-select:none;
    }
    .pill b{color:var(--accent);font-weight:900;}
    .card{
      background: linear-gradient(180deg, rgba(16,26,20,.92), rgba(13,21,17,.92));
      border:1px solid rgba(31,58,42,.9);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .cardBody{padding:14px;}
    .sectionTitle{
      display:flex;align-items:center;justify-content:space-between;gap:12px;
      font-family:var(--mono);
      color:var(--muted);
      font-size:.78rem;
      padding: 12px 14px;
      border-bottom:1px solid rgba(31,58,42,.55);
      background: linear-gradient(180deg, rgba(10,16,13,.45), rgba(10,16,13,.10));
    }
    .sectionTitle b{color:var(--text);}
    .bigBtn{
      width:100%;
      border:1px solid rgba(244,208,111,.30);
      background: linear-gradient(180deg, rgba(244,208,111,.18), rgba(244,208,111,.06));
      color:var(--text);
      border-radius: 22px;
      padding:18px 16px;
      font-family:var(--mono);
      cursor:pointer;
      box-shadow: 0 14px 30px rgba(0,0,0,.22);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      min-height:86px;
      transition: transform .08s ease, border-color .2s ease, filter .2s ease;
      touch-action: manipulation;
      user-select:none;
    }
    .bigBtn:active{transform: translateY(1px) scale(.99);}
    .bigBtn[disabled]{opacity:.55;cursor:not-allowed;transform:none;filter:saturate(.7);}
    .bigBtn:hover{border-color: rgba(244,208,111,.60);}
    .bigLeft{display:flex;flex-direction:column;gap:4px;min-width:0;}
    .bigName{font-size:1.06rem;color:var(--accent);font-weight:1000;letter-spacing:.3px;}
    .bigDesc{font-family:var(--sans);font-size:.88rem;line-height:1.25;color:var(--text);opacity:.93;}
    .bigRight{font-family:var(--mono);text-align:right;}
    .bigRight .gain{font-size:.90rem;}
    .bigRight .hint{font-size:.72rem;color:var(--muted);margin-top:2px;}
    .row2{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px;}
    .smallBtn{
      border:1px solid rgba(31,58,42,.95);
      background: linear-gradient(180deg, rgba(13,21,17,.95), rgba(10,16,13,.95));
      color:var(--text);
      border-radius: 18px;
      padding:14px 14px;
      cursor:pointer;
      font-family:var(--mono);
      min-height:64px;
      display:flex;flex-direction:column;justify-content:center;gap:4px;
      transition: transform .08s ease, border-color .2s ease, opacity .2s ease, filter .2s ease;
      touch-action: manipulation;
      user-select:none;
    }
    .smallBtn:active{transform: translateY(1px) scale(.99);}
    .smallBtn[disabled]{opacity:.55;cursor:not-allowed;transform:none;filter:saturate(.75);}
    .smallBtn:hover{border-color: rgba(244,208,111,.38);}
    .smallBtn .t{font-weight:900;color:var(--accent);font-size:.92rem;}
    .smallBtn .d{font-family:var(--sans);color:var(--muted);font-size:.76rem;line-height:1.2;}
    .bar{margin-top:12px;border:1px solid rgba(31,58,42,.85);border-radius: 999px;overflow:hidden;background: rgba(0,0,0,.16);}
    .bar > div{height:12px;width:10%;background: linear-gradient(90deg, rgba(244,208,111,.92), rgba(107,230,117,.80));transition: width .22s ease;}
    .meta{display:flex;justify-content:space-between;gap:10px;font-family:var(--mono);font-size:.74rem;color:var(--muted);margin-top:10px;}
    .meta b{color:var(--text);}
    details{margin-top:12px;border-top:1px solid rgba(31,58,42,.55);padding-top:10px;}
    summary{cursor:pointer;font-family:var(--mono);color:var(--muted);user-select:none;}
    .log{
      margin-top:10px;
      max-height: 28vh;
      overflow:auto;
      border-radius:18px;
      border:1px solid rgba(31,58,42,.85);
      background: linear-gradient(180deg, rgba(10,16,13,.78), rgba(7,10,8,.78));
      padding:12px;
      font-family:var(--mono);
      font-size:.76rem;
      line-height:1.45;
      -webkit-overflow-scrolling: touch;
    }
    .log p{margin:0 0 10px;}
    .log p span{color:var(--muted);}
    .good{color:var(--ok);font-weight:900;}
    .bad{color:var(--danger);font-weight:900;}
    .warn{color:var(--warn);font-weight:900;}

    /* Bottom tabs */
    .tabbar{
      position:fixed; left:0; right:0; bottom:0;
      padding: 10px 12px calc(10px + env(safe-area-inset-bottom));
      background: linear-gradient(180deg, rgba(11,15,12,.0), rgba(11,15,12,.92) 40%, rgba(11,15,12,.985));
      border-top:1px solid rgba(31,58,42,.75);
      display:flex; gap:10px; justify-content:center;
      overflow-x:auto; overflow-y:hidden;
      -webkit-overflow-scrolling: touch;
      backdrop-filter: blur(6px);
      z-index: 999;
    }
    .tabbar::-webkit-scrollbar{display:none;}
    .tab{
      border:1px solid rgba(31,58,42,.9);
      background: linear-gradient(180deg, rgba(16,26,20,.86), rgba(13,21,17,.86));
      color: var(--muted);
      border-radius: 999px;
      padding: 10px 12px;
      font-family: var(--mono);
      font-size: .76rem;
      cursor:pointer;
      white-space:nowrap;
      user-select:none;
      transition: transform .08s ease, border-color .2s ease, color .2s ease, opacity .2s ease;
      touch-action: manipulation;
    }
    .tab:active{transform: translateY(1px) scale(.99);}
    .tab.active{color:var(--text); border-color: rgba(244,208,111,.45);}
    .tab[disabled]{opacity:.45;cursor:not-allowed;filter:saturate(.75);}
    .dot{display:inline-block;width:8px;height:8px;border-radius:999px;background: rgba(244,208,111,.25);margin-right:8px;vertical-align:middle;}
    .tab.active .dot{background: rgba(244,208,111,.92); box-shadow: 0 0 12px rgba(244,208,111,.25);}

    .toast{
      position: fixed;
      left:50%; transform: translateX(-50%);
      bottom: calc(84px + env(safe-area-inset-bottom));
      background: rgba(16,26,20,.96);
      border: 1px solid rgba(244,208,111,.35);
      border-radius: 999px;
      padding: 10px 14px;
      font-family: var(--mono);
      font-size: 0.78rem;
      color: var(--text);
      box-shadow: var(--shadow);
      z-index: 1200;
      display:none;
      max-width: calc(100vw - 24px);
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }
    .toast.show{display:block;animation: pop .18s ease-out;}
    @keyframes pop{from{transform:translateX(-50%) scale(.98);opacity:.25;}to{transform:translateX(-50%) scale(1);opacity:1;}}

    /* tiny dopamine confetti */
    .spark{
      position: fixed;
      width: 10px; height: 10px;
      border-radius: 999px;
      pointer-events:none;
      opacity:.95;
      transform: translate(-50%,-50%);
      animation: fly 650ms ease-out forwards;
      filter: drop-shadow(0 10px 18px rgba(0,0,0,.25));
      z-index: 1300;
    }
    @keyframes fly{to{ transform: translate(calc(-50% + var(--dx)), calc(-50% + var(--dy))) scale(.65); opacity:0; }}

    .table{
      width:100%;
      border-collapse:separate;
      border-spacing:0 8px;
      font-family:var(--mono);
      font-size:.78rem;
      color:var(--text);
    }
    .table td{
      padding:10px 12px;
      border:1px solid rgba(31,58,42,.85);
      background: linear-gradient(180deg, rgba(10,16,13,.62), rgba(7,10,8,.62));
    }
    .table td:first-child{border-radius:14px 0 0 14px;color:var(--muted);width:46%;}
    .table td:last-child{border-radius:0 14px 14px 0;text-align:right;}
    .danger{border-color: rgba(255,107,107,.35) !important;}
  

    /* Chest overlay transitions */
    #chestOverlay{
      opacity: 0;
      pointer-events: none;
      transition: opacity .22s ease-out;
    }
    #chestOverlay.visible{
      opacity: 1;
      pointer-events: auto;
    }
    #chestCard{
      transform: translateY(18px) scale(.94);
      opacity: 0;
      transition: transform .26s ease-out, opacity .26s ease-out;
    }
    #chestOverlay.visible #chestCard{
      transform: translateY(0) scale(1);
      opacity: 1;
    }

    /* Battle report overlay transitions */
    #battleOverlay{
      opacity: 0;
      pointer-events: none;
      transition: opacity .22s ease-out;
    }
    #battleOverlay.visible{
      opacity: 1;
      pointer-events: auto;
    }
    #battleCard{
      transform: translateY(18px) scale(.94);
      opacity: 0;
      transition: transform .26s ease-out, opacity .26s ease-out;
    }
    #battleOverlay.visible #battleCard{
      transform: translateY(0) scale(1);
      opacity: 1;
    }


    /* --- Mobile header compact mode (keeps HUD, removes banner text) --- */
    @media (max-width: 520px){
      .top{padding:6px 0 6px; align-items:center;}
      .top > div:first-child{display:none;} /* hides title + description */
      .hud{gap:6px; justify-content:flex-start;}
      .pill{padding:8px 10px; font-size:.72rem; box-shadow: 0 10px 24px rgba(0,0,0,.30);}
      header{padding-bottom:6px;}
    }
    /* If description exists anywhere, don't show it */
    .sub{display:none !important;}


    /* Battle simulation overlay transitions */
    #battleSimOverlay{ opacity:0; pointer-events:none; transition: opacity .22s ease-out; }
    #battleSimOverlay.visible{ opacity:1; pointer-events:auto; }
    #battleSimCard{ transform: translateY(18px) scale(.94); opacity:0; transition: transform .26s ease-out, opacity .26s ease-out; }
    #battleSimOverlay.visible #battleSimCard{ transform: translateY(0) scale(1); opacity:1; }
    .simLine{ margin:0 0 10px; }

</style>
</head>
<body>
  <header>
    <div class="wrap">
      <div class="top">
        <div>
          <h1>ElderToKing</h1>
          <p class="sub" id="subline">One main action per tab. Everything else is optional.</p>
        </div>
        <div class="hud">
          <div class="pill">Denarii <b id="gold">0</b></div>
          <div class="pill">Renown <b id="renown">0</b></div>
          <div class="pill">Power <b id="power">0</b></div>
          <div class="pill">Land <b id="landHud">0</b></div>
        </div>
      </div>
    </div>
  </header>

  <main class="wrap" id="views">

    <!-- VILLAGE -->
    <section class="card view" data-view="village">
      <div class="sectionTitle"><span>Village</span><span style="display:flex;gap:10px;align-items:center;"><span>Income <b id="incomeRate">0</b>/s</span><span class="pill" style="padding:8px 10px;">Pop <b id="popUsed">0</b>/<b id="popCap">0</b></span></span></div>
      <div class="cardBody">
        <div class="card" style="box-shadow:none; border-radius:18px; overflow:hidden; margin-bottom:12px;">
          <div class="sectionTitle" style="border-bottom:1px solid rgba(31,58,42,.55);">
            <span>Objectives</span><span><b id="objStreak">0</b> streak</span>
          </div>
          <div class="cardBody" style="padding:10px 12px;">
            <div id="objList" style="display:flex;flex-direction:column;gap:8px;"></div>
          </div>
        </div>

        <button class="bigBtn" id="btnTribute">
          <div class="bigLeft">
            <div class="bigName" id="tributeTitle">Collect Tribute</div>
            <div class="bigDesc">Tap for denarii. Keep your streak for extra.</div>
          </div>
          <div class="bigRight">
            <div class="gain" id="tributeGain">+0 denarii</div>
            <div class="hint" id="tributeHint">Streak x1</div>
          </div>
        </button>

        <button class="smallBtn" id="btnCashout" style="margin-top:10px; display:none;">
          <div class="t">Cash Out</div>
          <div class="d" id="cashoutDesc">Bank your streak bonus.</div>
        </button>


        <div class="row2">
          <button class="smallBtn" id="btnFarm">
            <div class="t">Build Farm</div>
            <div class="d" id="farmDesc">Passive income. Small but forever.</div>
          </button>
          <button class="smallBtn" id="btnVilla">
            <div class="t">Build Villa</div>
            <div class="d" id="villaDesc">Bigger income. Costs more.</div>
          </button>
        </div>

        <div class="bar"><div id="progressFill"></div></div>
        <div class="meta">
          <div>Title: <b id="title">Villager</b></div>
          <div>Next: <b id="nextTitle">Elder</b></div>
        </div>

        <details>
          <summary>Chronicle (optional)</summary>
          <div class="log" id="log"></div>
        </details>
      </div>
    </section>

    <!-- LEGION -->
    <section class="card view" data-view="legion" hidden>
      <div class="sectionTitle"><span>Legion</span><span>Warriors <b id="warriors">0</b></span></div>
      <div class="cardBody">
        <button class="bigBtn" id="btnRecruit">
          <div class="bigLeft">
            <div class="bigName">Recruit Warrior</div>
            <div class="bigDesc">Spend denarii to raise your first fighters.</div>
          </div>
          <div class="bigRight">
            <div class="gain" id="recruitCost">Cost 0</div>
            <div class="hint" id="recruitGain">+6 strength</div>
          </div>
        </button>

        
        <div class="row2">
          <button class="smallBtn" id="btnBattleBandits1">
            <div class="t">Crush bandits</div>
            <div class="d" id="battleBandits1Desc">10â€“50 enemies â€¢ quick skirmish</div>
          </button>
          <button class="smallBtn" id="btnBattleLevy">
            <div class="t">Muster your levy (local lord)</div>
            <div class="d" id="battleLevyDesc">250â€“500 enemies â€¢ moderate risk</div>
          </button>
          <button class="smallBtn" id="btnBattleVillageRaid">
            <div class="t">Take nearby village</div>
            <div class="d" id="battleVillageRaidDesc">500â€“1,000 enemies â€¢ high risk</div>
          </button>
          <button class="smallBtn" id="btnBattleSiege">
            <div class="t">Siege town</div>
            <div class="d" id="battleSiegeDesc">1,000â€“5,000 enemies â€¢ deadly</div>
          </button>
        </div>

        <div class="meta">
          <div>Strength: <b id="legionStr">0</b></div>
          <div>Land: <b id="landLegion">0</b></div>
        </div>
      </div>
    </section>

    <!-- TEMPLE -->
<section class="card view" data-view="temple" hidden>
      <div class="sectionTitle"><span>Temple</span><span>Crowns <b id="crowns">0</b></span></div>
      <div class="cardBody">
        <button class="bigBtn" id="btnOffer">
          <div class="bigLeft">
            <div class="bigName">Offer to the Gods</div>
            <div class="bigDesc">Spend denarii for faith. Faith boosts crits.</div>
          </div>
          <div class="bigRight">
            <div class="gain" id="offerCost">Cost 0</div>
            <div class="hint" id="faithNow">Faith 0</div>
          </div>
        </button>

        <div class="row2">
          <button class="smallBtn" id="btnBless">
            <div class="t">Blessing</div>
            <div class="d" id="blessDesc">Short buff window. Cooldown.</div>
          </button>
          <button class="smallBtn" id="btnAscend">
            <div class="t">Ascend (Prestige)</div>
            <div class="d" id="ascendDesc">Reset for crowns (permanent boosts).</div>
          </button>
        </div>

        <div class="meta">
          <div>Crit: <b id="critRate">0%</b></div>
          <div>Buff: <b id="buffLeft">0s</b></div>
        </div>
      </div>
    </section>

    <!-- COURT -->
    <section class="card view" data-view="court" hidden>
      <div class="sectionTitle"><span>Court</span><span>Influence <b id="inf2">0</b></span></div>
      <div class="cardBody">
        <button class="bigBtn" id="btnCourt">
          <div class="bigLeft">
            <div class="bigName">Hold Court</div>
            <div class="bigDesc">Spend influence to gain renown fast.</div>
          </div>
          <div class="bigRight">
            <div class="gain" id="courtCost">Cost 0</div>
            <div class="hint" id="courtGain">+0 renown</div>
          </div>
        </button>

        <div class="row2">
          <button class="smallBtn" id="btnDecree">
            <div class="t">Issue Decree</div>
            <div class="d" id="decreeDesc">Permanent boosts (expensive).</div>
          </button>
          <button class="smallBtn" id="btnFeast">
            <div class="t">Host Feast</div>
            <div class="d" id="feastDesc">Cooldown renown burst.</div>
          </button>
        </div>

        <div class="meta">
          <div>Decrees: <b id="decrees">0</b></div>
          <div>Feast CD: <b id="feastCd">0s</b></div>
        </div>
      </div>
    </section>

    <!-- STATS -->
    <section class="card view" data-view="stats" hidden>
      <div class="sectionTitle"><span>Stats</span><span><b>Geek mode</b></span></div>
      <div class="cardBody">
        <table class="table" aria-label="All stats">
          <tbody id="statsTable"></tbody>
        </table>
        <div class="row2">
          <button class="smallBtn" id="btnExport">
            <div class="t">Copy Save</div>
            <div class="d">Copies JSON save to clipboard.</div>
          </button>
          <button class="smallBtn" id="btnReset">
            <div class="t" style="color:var(--danger);">Reset Save</div>
            <div class="d">Erase local save on this device.</div>
          </button>
        </div>
      </div>
    </section>

    <div class="toast" id="toast">Saved.</div>
  </main>

  <nav class="tabbar" aria-label="Sections">
    <button class="tab active" data-go="village"><span class="dot"></span>Village</button>
    <button class="tab" data-go="legion"><span class="dot"></span>Legion</button>
<button class="tab" data-go="temple"><span class="dot"></span>Temple</button>
    <button class="tab" data-go="court"><span class="dot"></span>Court</button>
    <button class="tab" data-go="stats"><span class="dot"></span>Stats</button>
  </nav>

<script>
(() => {
  "use strict";

  const $ = (q, el=document)=> el.querySelector(q);
  const $$ = (q, el=document)=> Array.from(el.querySelectorAll(q));
  const clamp = (n,min,max)=> Math.max(min, Math.min(max,n));
  const rnd = (a,b)=> Math.floor(Math.random()*(b-a+1))+a;
  const chance = (p)=> Math.random() < p;

  const STORAGE_KEY = "roman_denarii_land_loop_villagecap_v14_save";

  const unlock = {
    legion: 450,
temple: 5200,
    court: 8200,
    stats: 0
  };

  const titles = [
    { name:"Villager", need: 0 },
    { name:"Elder", need: 600 },
    { name:"Chief", need: 2200 },
    { name:"Prefect", need: 6000 },
    { name:"Senator", need: 15000 },
    { name:"Consul", need: 36000 },
    { name:"King", need: 90000 },
    { name:"Legend", need: 220000 }
  ];

  const defaultState = () => ({
    created: Date.now(),
    gold: 18,
    renown: 0,
    power: 6,

    // village economy
    tribute: 1,
    farmCount: 0,
    villaCount: 0,

    // legion
    warriors: 0,    legion: 0,  // derived strength (kept for compatibility)
    battlesWon: 0,
    battleReadyAt: 0,

    // land & politics
    land: 0,
    influence: 0,

    // village capacity
    populationUsed: 0,

    // temple / prestige
    faith: 0,
    crowns: 0,
    buffUntil: 0,
    blessReadyAt: 0,

    // court
    decrees: 0,
    feastReadyAt: 0,

    // streak + lifetime
    streak: 1,
    lastTap: 0,
    lifetimeGold: 0,
    lifetimeRenown: 0,
    rankIdx: 0,

    tapsSinceCashout: 0,
    cashoutReadyAt: 0,
    cashoutBanked: 0,

    // objectives
    objectives: null,
    objStreak: 0,

    // burst events
    feverUntil: 0,
    objDoubleUntil: 0,
    lastGoldStormAt: 0,

    // temp buffs
    prosperUntil: 0,

    // prestige meta
    ascends: 0,
    bestStreak: 0,
    biggestCashout: 0,
  });

  function normalizeState(state){
    const d = defaultState();
    if(!state || typeof state !== "object") return d;

    // Merge with defaults and coerce numbers safely
    for(const k of Object.keys(d)){
      if(!(k in state)) state[k] = d[k];
      if(typeof d[k] === "number"){
        state[k] = Number(state[k]);
        if(!Number.isFinite(state[k])) state[k] = d[k];
      }
    }
    return state;
  }

  let S = normalizeState(load()) || defaultState();
  // If localStorage is empty/evicted, try IndexedDB recovery (especially on iPhone).
  recoverSaveFromIDB();
  let currentView = "village";

    // --- Robust saving on iPhone (localStorage + IndexedDB fallback) ---
  // iOS Safari can evict localStorage (especially for file:// or low-storage situations).
  // We write to BOTH localStorage and IndexedDB, and we can recover from IndexedDB if localStorage is empty.
  const SAVE_DB_NAME = "roman_kingdom_save_db_v1";
  const SAVE_STORE = "kv";

  function isStandalone(){
    try{
      return (window.matchMedia && window.matchMedia("(display-mode: standalone)").matches) || (window.navigator && window.navigator.standalone);
    }catch(e){ return false; }
  }

  function openSaveDB(){
    return new Promise((resolve, reject)=>{
      try{
        const req = indexedDB.open(SAVE_DB_NAME, 1);
        req.onupgradeneeded = ()=>{ req.result.createObjectStore(SAVE_STORE); };
        req.onsuccess = ()=> resolve(req.result);
        req.onerror = ()=> reject(req.error);
      }catch(e){ reject(e); }
    });
  }

  async function idbSet(key, value){
    try{
      const db = await openSaveDB();
      await new Promise((resolve, reject)=>{
        const tx = db.transaction(SAVE_STORE, "readwrite");
        tx.objectStore(SAVE_STORE).put(value, key);
        tx.oncomplete = ()=> resolve(true);
        tx.onerror = ()=> reject(tx.error);
      });
      db.close();
    }catch(e){}
  }

  async function idbGet(key){
    try{
      const db = await openSaveDB();
      const val = await new Promise((resolve, reject)=>{
        const tx = db.transaction(SAVE_STORE, "readonly");
        const req = tx.objectStore(SAVE_STORE).get(key);
        req.onsuccess = ()=> resolve(req.result ?? null);
        req.onerror = ()=> reject(req.error);
      });
      db.close();
      return val;
    }catch(e){
      return null;
    }
  }

  function save(silent=false){
    const payload = JSON.stringify(S);
    try{ localStorage.setItem(STORAGE_KEY, payload); }catch(e){}
    // IndexedDB write (best-effort, async)
    idbSet(STORAGE_KEY, payload);
    if(!silent) toast("Saved");
  }

  function load(){
    // Fast path: localStorage
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      if(raw){
        try{ return JSON.parse(raw); }catch(e){}
      }
    }catch(e){}
    // Slow path: handled asynchronously after first render
    return null;
  }

  async function recoverSaveFromIDB(){
    const raw = await idbGet(STORAGE_KEY);
    if(!raw) return false;
    try{
      const parsed = JSON.parse(raw);
      S = normalizeState(parsed);
      try{ localStorage.setItem(STORAGE_KEY, raw); }catch(e){}
      toast("Save recovered");
      render();
      return true;
    }catch(e){
      return false;
    }
  }

// --- iPhone/iOS reliability: persistent storage + autosave + lifecycle saves ---
// iOS Safari can aggressively discard tabs; we save often and also on page hide.
(function setupReliableSaves(){
  // Ask for "persistent" storage when available (reduces eviction on some browsers)
  try{
    if(navigator.storage && navigator.storage.persist){
      navigator.storage.persist().then(()=>{}).catch(()=>{});
    }
  }catch(e){}

  // Detect whether localStorage is actually usable (Private Browsing / restrictions can break it)
  function storageWritable(){
    try{
      const k = STORAGE_KEY + "__probe";
      localStorage.setItem(k, "1");
      localStorage.removeItem(k);
      return true;
    }catch(e){
      return false;
    }
  }

  // iPhone tip: if you're running from file:// and NOT installed to Home Screen,
  // iOS can reset storage when you leave the tab. Warn once.
  try{
    const fromFile = (location && location.protocol === "file:");
    if(fromFile && !isStandalone()){
      setTimeout(()=>toast("ðŸ“Œ iPhone tip: install to Home Screen (Share â†’ Add to Home Screen) and launch from the icon for reliable saving."), 650);
    }
  }catch(e){}

  // If storage isn't writable, warn once so the user knows why resets happen.
  try{
    if(!storageWritable()){
      // Keep it subtle; also avoid blocking the game.
      setTimeout(()=>toast("âš ï¸ Saving is blocked in this mode (iPhone Private Browsing / restrictions). Open in Safari normally or add to Home Screen."), 400);
    }
  }catch(e){}

  // Debounced save helper (avoids spamming writes during rapid taps)
  let _svT = 0;
  window.scheduleSave = function scheduleSave(){
    clearTimeout(_svT);
    _svT = setTimeout(()=>{ try{ save(true); }catch(e){} }, 500);
  };

  // Autosave: iOS may kill the page without firing beforeunload reliably.
  // Keep it lightweight and frequent.
  setInterval(()=>{ try{ save(true); }catch(e){} }, 5000);

  // Save when the page is being backgrounded / suspended.
  function flushSave(){
    try{ save(true); }catch(e){}
  }
  document.addEventListener("visibilitychange", ()=>{
    if(document.visibilityState === "hidden") flushSave();
  });
  window.addEventListener("pagehide", flushSave, {capture:true});
  window.addEventListener("beforeunload", flushSave, {capture:true});
})();


  function toast(text){
    const t = $("#toast");
    t.textContent = text;
    t.classList.add("show");
    clearTimeout(toast._tm);
    toast._tm = setTimeout(()=>t.classList.remove("show"), 900);
  }

  function logLine(text, tone=""){
    const log = $("#log");
    if(!log) return;
    const p = document.createElement("p");
    const ts = new Date();
    const stamp = `${ts.getHours().toString().padStart(2,"0")}:${ts.getMinutes().toString().padStart(2,"0")}`;
    const span = document.createElement("span");
    span.textContent = `[${stamp}] `;
    p.appendChild(span);
    if(tone){
      const s = document.createElement("span");
      s.className = tone;
      s.textContent = text;
      p.appendChild(s);
    }else{
      p.appendChild(document.createTextNode(text));
    }
    log.appendChild(p);
    log.scrollTop = log.scrollHeight;
  }

  function sparkAt(x,y){
    const n = 6;
    for(let i=0;i<n;i++){
      const s = document.createElement("div");
      s.className = "spark";
      s.style.left = x+"px";
      s.style.top  = y+"px";
      s.style.background = `hsla(${rnd(35,95)}, 90%, ${rnd(55,70)}%, 0.95)`;
      s.style.setProperty("--dx", `${rnd(-90,90)}px`);
      s.style.setProperty("--dy", `${rnd(-140,-40)}px`);
      document.body.appendChild(s);
      setTimeout(()=>s.remove(), 700);
    }
  }

  // ---- Scalind + rates (make it LAST longer) ----
  function crownMult(){
    // very strong long-term scaling, but gradual
    return 1 + (S.crowns * 0.12);
  }
  function landMult(){
    return 1 + (S.land * 0.05);
  }
  function marketMult(){ return 1; }
  function decreeMult(){
    return 1 + (S.decrees * 0.07);
  }
  function incomePerSec(){
    let farm = S.farmCount * 0.75;
    // Soft cap: without land, extra farms become less effective (nudges you into the land loop)
    const softCap = 6 + (S.land * 2);
    if(S.farmCount > softCap){
      farm *= Math.max(0.60, 1 - (S.farmCount - softCap) * 0.04);
    }
    const villa = S.villaCount * 3.0;
    const base = farm + villa;
    const prosper = (Date.now() < (S.prosperUntil||0)) ? 1.5 : 1.0;
    return base * landMult() * decreeMult() * crownMult() * prosper;
  }

  // ---- Village Economy Loop ----
  function populationCap(){
    // Farms provide housing; villas attract families; land improves efficiency.
    // Simple + readable:
    // - Each farm supports 4 warriors
    // - Each villa supports 10 more warriors (bigger settlements)
    // - Land boosts overall capacity a bit
    const base = (S.farmCount * 4) + (S.villaCount * 10);
    return Math.floor(base * (1 + S.land * 0.08));
  }
  function hasVillageCapacity(){
    return (S.populationUsed || 0) < populationCap();
  }

  function applyStreak(){
    const now = Date.now();
    const prev = S.streak || 0;
    if(now - (S.lastTap || 0) <= 2600){
      // Infinite streak: no upper cap, just timing-based
      S.streak = prev + 1;
    }else{
      S.streak = 1;
    }
    S.lastTap = now;

    // Objective: reach a streak threshold (counts when you hit/hold it)
    bumpObjective("streak", Math.max(0, S.streak - (prev||0)));

    // Track best streak across all runs
    if(!S.bestStreak || S.streak > S.bestStreak){
      S.bestStreak = S.streak;
    }

    // Streak milestone bursts every 25 taps
    if(S.streak > 0 && S.streak % 25 === 0){
      maybeBurst("streak");
    }
  }

  function critChance(){
    // faith boosts crit chance; buff doubles it
    const base = 0.08 + clamp(S.faith / 12000, 0, 0.18);
    const boosted = isBuffed() ? base * 1.9 : base;
    return clamp(boosted, 0.06, 0.30);
  }

  function isBuffed(){ return Date.now() < S.buffUntil; }

  function tapGain(){
    const base = S.tribute + rankTributeBonus(titleInfo().idx) + rushBonus();
    const streakBonus = 1 + Math.min(0.35, (S.streak-1)*0.018);
    const pMult = landMult() * decreeMult() * crownMult();
    const feverMult = (Date.now() < (S.feverUntil || 0)) ? 2.5 : 1;
    const crit = chance(critChance());
    const gain = Math.round(base * streakBonus * pMult * feverMult * (crit ? 2 : 1));
    return { gain, crit };
  }


  // ---- Streak timer + Gold Rush ----
  const STREAK_WINDOW_MS = 3000;

  function streakTimeLeftMs(){
    if(!S.lastTap) return STREAK_WINDOW_MS;
    return Math.max(0, STREAK_WINDOW_MS - (Date.now() - S.lastTap));
  }

  function expireStreakIfNeeded(){
    if(S.streak > 1 && S.lastTap && (Date.now() - S.lastTap) > STREAK_WINDOW_MS){
      S.streak = 1;
    }
  }

  function rushBonus(){
    // Infinite "gold rush" growth: every 10 streak adds a small flat bonus to tap base.
    // Slow enough to not break balance, but feels endless.
    const milestones = Math.max(0, Math.floor((S.streak - 1) / 10));
    return Math.round(milestones * 0.15 * 10) / 10; // +0.15 per milestone, rounded to 0.1
  }


  // ---- Costs (ramp hard so it isn't beaten in 2 mins) ----
  function costFarm(){
    // Keep early game sane: farms stay roughly the same price (tiny scaling only)
    return Math.round(140 * Math.pow(1.06, S.farmCount));
  }
  function costVilla(){
    // Villas are pricier but still not runaway
    return Math.round(420 * Math.pow(1.07, S.villaCount));
  }


  function recruitCost(){
    // Scale like farms: gentle growth so armies stay affordable
    // (tiny land factor so conquering still matters)
    return Math.round(260 * Math.pow(1.06, S.warriors) * Math.pow(1.01, S.land));
  }

  function recruitStrengthGain(){
    return 6;
  }

    function recalcLegionStrength(){
    // Strength derived from warriors only (simple + readable)
    const per = 6;
    S.legion = Math.round(S.warriors * per);
  }


  
  // --- Battles (enemy-count based) ---
  const BATTLES = {
    bandits: { label:"Crush bandits", enemyMin:10, enemyMax:50,  landMin:0, landMax:1, lootBase:90,  lootScale:35, cdMs:22_000 },
    levy:    { label:"Muster your levy", enemyMin:250, enemyMax:500, landMin:1, landMax:2, lootBase:260, lootScale:55, cdMs:32_000 },
    village: { label:"Take nearby village", enemyMin:500, enemyMax:1000, landMin:2, landMax:4, lootBase:520, lootScale:80, cdMs:44_000 },
    siege:   { label:"Siege town", enemyMin:1000, enemyMax:5000, landMin:4, landMax:10, lootBase:1100, lootScale:140, cdMs:70_000 },
  };

  function battleCooldownMs(key){
    return (BATTLES[key] ? BATTLES[key].cdMs : 35_000);
  }

  function battleSim(key){
    const b = BATTLES[key];
    const enemies = rnd(b.enemyMin, b.enemyMax);

    // --- Power model ---
    // Bandits should remain easy forever; harder tiers scale slightly with your campaign success.
    const wins = (S.battlesWon||0);

    const tierMult =
      (key==="bandits") ? 0.75 :
      (key==="levy")    ? 1.00 :
      (key==="village") ? 1.15 :
      (key==="siege")   ? 1.35 : 1.0;

    // How much enemies "learn" over time (very small for bandits)
    const learnDiv =
      (key==="bandits") ? 1000 :
      (key==="levy")    ? 260  :
      (key==="village") ? 190  :
      (key==="siege")   ? 140  : 250;

    const learn = 1 + clamp(wins / learnDiv, 0, 0.18);

    // Your side: warriors are the main factor; power and land give small, readable boosts.
    const yourTroops = Math.max(0, S.warriors||0);
    const perWarrior = 6;

    const org = 1 + clamp((S.power||0)/1800, 0, 0.28);   // organization/gear
    const terrain = 1 + clamp((S.land||0)/90, 0, 0.18);  // better supply lines
    const yourPower = (yourTroops * perWarrior) * org * terrain;

    // Enemy power: count * tier difficulty * slight learning
    const enemyPower = enemies * tierMult * learn;

    // --- Win chance ---
    // Use a sigmoid on relative advantage so big leads feel *very* safe.
    // advantage > 0 => you're stronger
    const denom = Math.max(12, 0.25*(yourPower + enemyPower));
    const advantage = (yourPower - enemyPower) / denom; // roughly -? .. +?
    const winP = clamp(1/(1+Math.exp(-advantage)) , 0.03, 0.985);

    const win = chance(winP);

    // --- Casualties ---
    // Losses scale with pressure; overwhelming wins can be clean (0 losses).
    const pressure = clamp(enemyPower / Math.max(1, yourPower + enemyPower), 0.05, 0.95);
    const outcomeMult = win ? 0.55 : 1.05; // defeats hurt more
    const noise = 0.80 + Math.random()*0.45;

    let losses = Math.round(yourTroops * pressure * outcomeMult * noise);

    const cap = win ? Math.max(0, Math.floor(yourTroops*0.30)) : Math.max(1, Math.floor(yourTroops*0.70));
    losses = clamp(losses, 0, cap);

    // Only enforce a minimum loss when the fight was actually close.
    if(yourTroops > 0){
      const closeFight = yourPower < enemyPower * 1.35;
      if(!win){
        losses = Math.max(1, losses);
      }else if(closeFight){
        losses = Math.max(1, losses);
      }
    }

    return { enemies, winP, win, losses };
  }


  function offerCost(){
    return Math.round(600 * Math.pow(1.34, Math.floor((S.faith||0)/120)));
  }

  function offerFaithGain(){
    return Math.round(22 + (S.land*2));
  }

  function blessCooldownMs(){ return 60_000; }
  function blessDurationMs(){ return 22_000; }

  function ascendCrownGain(){
    // you need renown to ascend; crowns scale gently to keep long-term
    const r = S.renown;
    if(r < 25000) return 0;
    return Math.floor(Math.sqrt(r/650)); // e.g. 5000=>2, 20k=>5, 80k=>11
  }

  function courtCost(){ return Math.round(12 + S.decrees*3 + Math.floor(S.renown/900)); }
  function courtRenownGain(){ return Math.round(28 + (S.decrees*6) + (S.land*4)); }

  function decreeCostGold(){ return Math.round(2200 * Math.pow(1.52, S.decrees)); }
  function decreeCostInf(){ return Math.round(30 * Math.pow(1.22, S.decrees)); }

  function feastCooldownMs(){ return 75_000; }
  function feastRenown(){
    return Math.round(260 + S.decrees*120);
  }
  function feastCostGold(){ return Math.round(900 + S.decrees*250); }

  // ---- Titles + unlocks ----
  function titleInfo(){
    const r = S.renown;
    let idx = 0;
    for(let i=0;i<titles.length;i++) if(r >= titles[i].need) idx = i;
    const cur = titles[idx];
    const next = titles[Math.min(idx+1, titles.length-1)];
    return { cur, next, idx };
  }

  function rankTributeBonus(idx){
    // Slight per-rank boost. Early ranks are small to keep the start tough.
    // Villager=0 â†’ +0.0, Elder=1 â†’ +0.2, Chief=2 â†’ +0.5, etc.
    return Math.round((0.10*idx + 0.08*idx*idx) * 10) / 10; // to nearest 0.1
  }

  function handleRankUps(){
    const { idx } = titleInfo();
    if(typeof S.rankIdx !== "number") S.rankIdx = 0;
    if(idx <= S.rankIdx) return;

    const gained = idx - S.rankIdx;
    // Award a small permanent tap increase each rank-up
    // (this stacks with multipliers like Provinces/Decrees/Crowns and crit/streak).
    const before = S.tribute;
    S.tribute = Math.max(1, Math.round((S.tribute + gained * 0.25) * 10) / 10);
    S.rankIdx = idx;

    logLine(`Rank up! Your tribute grows. (+${(S.tribute - before).toFixed(1)} tap base)`, "warn");
    toast("Rank up!");
  }


  // ---- Dopamine layers: Jackpots + Cash Out ----
  const CASHOUT_EVERY_TAPS = 10;        // becomes available every N taps
  const CASHOUT_WINDOW_MS = 6500;       // time to cash out once ready
  function cashoutMultiplier(){
    // Scales with prestige + progression systems
    return landMult() * decreeMult() * crownMult();
  }

  function rollJackpot(){
    // Returns {type, mult} or null
    // Lucky: common-ish; Imperial: rare but huge.
    const pMult = cashoutMultiplier();
    const luckyP = clamp(0.010 + (S.faith/200000), 0.010, 0.020);     // 1.0% â†’ 2.0%
    const impP   = clamp(0.0020 + (S.crowns*0.00015), 0.0020, 0.0060); // 0.20% â†’ 0.60%
    if(chance(impP))   return { type:"Imperial Tribute", mult: rnd(220, 650) * pMult };
    if(chance(luckyP)) return { type:"Lucky Denarius",  mult: rnd(40, 140) * pMult };
    return null;
  }

  function bankCashout(amount){
    // Bank grows with streak so players feel momentum.
    const streakBoost = 1 + Math.min(0.85, (S.streak-1)*0.02);
    S.cashoutBanked += Math.round(amount * 0.35 * streakBoost);
    S.cashoutBanked = clamp(S.cashoutBanked, 0, 9_999_999_999);
  }
  function cashoutAvailable(){ return cashoutReady(); }

  function expireCashoutIfNeeded(){ /* handled by cooldown + streak timer */ }

// ---- Cash Out Rework (streak-driven, timing & milestones) ----
  // Goal: tempt players to *cash* their streak at milestones instead of mindlessly holding it.
  const CASHOUT_MIN_STREAK = 6;       // when cashing becomes available
  const CASHOUT_COOLDOWN_MS = 2500;   // after cashing out

  function cashoutPotential(){
    const s = Math.max(1, S.streak || 1);
    if(s < CASHOUT_MIN_STREAK) return 0;

    const milestones = Math.floor(s / 10); // every 10 feels special
    const within = streakTimeLeftMs() / STREAK_WINDOW_MS; // 0..1
    const timing = 0.70 + 0.30 * within; // more if you're actively tapping

    // This grows fast enough to feel exciting, but not runaway:
    // - streak curve (power-ish)
    // - extra kicker at milestones
    // - a little rush synergy
    const curve = Math.pow(s, 1.22);
    const kicker = 1 + milestones * 0.18;
    const rush = 1 + (rushBonus() * 0.06);

    const raw = (6 + curve) * kicker * timing * rush;
    return Math.round(raw * cashoutMultiplier());
  }

  function cashoutReady(){
    const now = Date.now();
    return (now >= (S.cashoutCooldownUntil || 0)) && cashoutPotential() > 0;
  }
// ---- Micro objectives (state-driven, procedural, always something to do) ----
  const OBJ_SLOTS = 3;

  function ensureObjectives(){
    if(!Array.isArray(S.objectives) || S.objectives.length !== OBJ_SLOTS){
      S.objectives = [];
      for(let i=0;i<OBJ_SLOTS;i++) S.objectives.push(makeObjective());
      S.objStreak = Number(S.objStreak) || 0;
    }
  }

  function makeObjective(){
    // Procedural objectives: scale off current progress + unlocks.
    const r      = Number(S.renown)   || 0;
    const land   = Number(S.land)     || 0;
    const w      = Number(S.warriors) || 0;
    const crowns = Number(S.crowns)   || 0;
    const income = Math.max(0, incomePerSec());

    // Rough progression tier: renown + crowns pushes things up.
    const progTier = Math.max(
      1,
      1 + Math.floor(r / 1400) + Math.floor(crowns / 3)
    );

    // Slightly discourage giving the same type in every slot.
    const existingTypes = (Array.isArray(S.objectives) ? S.objectives : [])
      .filter(Boolean)
      .map(o => o.type);
    const existingSet = new Set(existingTypes);

    const pool = [];
    const pushObj = (spec)=>{
      if(!spec || spec.weight <= 0) return;
      let weight = spec.weight;
      if(existingSet.has(spec.type)){
        // still allowed, but less likely so you see variety
        weight *= 0.45;
      }
      if(weight <= 0) return;
      pool.push({ ...spec, weight });
    };

    // --- Core tap loop (always relevant) ---
    // Easy, always-present tap objective
    pushObj({ type:"tap", min: 10, max: 24, weight: 5 });

    // Streak objective: encourages timing skill; always achievable
    pushObj({ type:"streak", min: 6, max: 18 + progTier*3, weight: 3 });

    // Harder tap chains that scale with progTier
    if(progTier >= 2){
      const baseTap = 25 + (progTier-1)*10;
      pushObj({ type:"tap", min: baseTap, max: baseTap + 20 + progTier*10, weight: 4 });
    }

    // --- Village build ---
    // Farms stay small but step up a bit later
    const farmTarget = (progTier <= 2) ? 1 : (progTier <= 4 ? 2 : 3);
    pushObj({ type:"buildFarm", min: farmTarget, max: farmTarget, weight: 4 });

    // Villas mid/late game
    if(r >= 900){
      pushObj({ type:"buildVilla", min: 1, max: Math.min(2, 1 + Math.floor(progTier/2)), weight: 3 });
    }
    if(r >= 4000){
      pushObj({ type:"buildVilla", min: 2, max: 3, weight: 2 });
    }

    // --- Earn denarii (scales off income / tier) ---
    const earnBase = Math.max(150, Math.round(income * (18 + progTier*4)));
    pushObj({
      type: "earnDen",
      min: earnBase,
      max: Math.round(earnBase * 1.7),
      weight: 5
    });

    if(progTier >= 3){
      const big = earnBase * (1.8 + progTier*0.25);
      pushObj({
        type: "earnDen",
        min: Math.round(big),
        max: Math.round(big * 1.5),
        weight: 3
      });
    }

    // --- Legion / land objectives ---
    if(r >= unlock.legion){
      // Gain land
      pushObj({
        type:"gainLand",
        min: 1,
        max: Math.min(6, 1 + progTier*2),
        weight: 3
      });
    }

    // --- Temple objectives ---
    if(r >= unlock.temple){
      pushObj({
        type:"offerFaith",
        min: 1,
        max: Math.min(3, 1 + progTier),
        weight: 2
      });
    }

    // --- Court objectives ---
    if(r >= unlock.court){
      pushObj({
        type:"holdCourt",
        min: 1,
        max: Math.min(2, 1 + Math.floor(progTier/3)),
        weight: 2
      });
      pushObj({
        type:"feast",
        min: 1,
        max: 1,
        weight: 1
      });
    }

    // --- Recruit / cashout ---
    if(r >= 450 && w >= 0){
      pushObj({
        type:"recruit",
        min: 1,
        max: Math.min(3, 1 + progTier),
        weight: 3
      });
    }

    // Fallback if somehow pool is empty
    if(pool.length === 0){
      pushObj({ type:"tap", min: 10, max: 20, weight: 1 });
    }

    // Weighted pick
    const totalW = pool.reduce((a,p)=>a+p.weight,0);
    let roll = Math.random() * totalW;
    let pick = pool[0];
    for(const p of pool){
      roll -= p.weight;
      if(roll <= 0){ pick = p; break; }
    }

    const target = rnd(pick.min, pick.max);
    const id = `${pick.type}_${Date.now()}_${rnd(100,999)}`;

    // Reward design:
    // - scales with renown, land, crowns, income and target
    const baseDen   = 22 + Math.floor(r/110) + (crowns*16) + Math.floor(land*3.5);
    const incomeDen = income * (12 + progTier*4);
    const targetFactor = 0.85 + target*0.08 + progTier*0.25;

    let rewardDen = Math.round((baseDen + incomeDen) * targetFactor);

    // soft caps just to keep early game sane
    const softCap =
      (r < 1500)   ?  900 :
      (r < 8000)   ? 5000 :
      (r < 25000)  ? 30000 :
                     1e12;
    rewardDen = Math.min(rewardDen, softCap);

    // Power reward: small but scales with target + tier
    let rewardPower = Math.max(1, Math.round(1 + target*0.05 + progTier*0.4));
    rewardPower = clamp(rewardPower, 1, 45);

    return {
      id,
      type: pick.type,
      target,
      progress: 0,
      rewardDen,
      rewardPower,
      claimed: false
    };
  }

  function objText(o){
    const left = Math.max(0, o.target - o.progress);

    if(o.type==="tap")
      return `Tap ${o.target} times (${left} left)`;


    if(o.type==="streak")
      return `Reach streak x${o.target} (best this run: x${Math.max(1, S.streak||1)})`;

    if(o.type==="winBandits")
      return `Win ${o.target} bandit skirmish${o.target>1?"es":""} (${left} left)`;

    if(o.type==="winLevy")
      return `Win ${o.target} levy battle${o.target>1?"s":""} (${left} left)`;

    if(o.type==="winVillage")
      return `Win ${o.target} village assault${o.target>1?"s":""} (${left} left)`;

    if(o.type==="winSiege")
      return `Win ${o.target} siege${o.target>1?"s":""} (${left} left)`;


    if(o.type==="buildFarm")
      return `Build ${o.target} farm${o.target>1?"s":""} (${left} left)`;

    if(o.type==="buildVilla")
      return `Build ${o.target} villa${o.target>1?"s":""} (${left} left)`;

    if(o.type==="earnDen")
      return `Earn ${fmt(o.target)} denarii (${fmt(left)} left)`;

    if(o.type==="recruit")
      return `Recruit ${o.target} warrior${o.target>1?"s":""} (${left} left)`;

    if(o.type==="winBattle")
      return `Win ${o.target} battle${o.target>1?"s":""} (${left} left)`;

    if(o.type==="gainLand")
      return `Gain ${o.target} land (${left} left)`;
      return `Run ${o.target} caravan${o.target>1?"s":""} (${left} left)`;

    if(o.type==="offerFaith")
      return `Make ${o.target} temple offering${o.target>1?"s":""} (${left} left)`;

    if(o.type==="holdCourt")
      return `Hold court ${o.target} time${o.target>1?"s":""} (${left} left)`;

    if(o.type==="feast")
      return `Host ${o.target} feast${o.target>1?"s":""} (${left} left)`;

    return `Do something (${left} left)`;
  }

  function objComplete(o){ return o.progress >= o.target; }

  function bumpObjective(type, amount=1){
    ensureObjectives();
    for(const o of S.objectives){
      if(o.claimed) continue;
      if(o.type !== type) continue;
      o.progress = clamp(o.progress + amount, 0, o.target);
    }
  }

  function bumpEarnedDenarii(amount){
    ensureObjectives();
    for(const o of S.objectives){
      if(o.claimed) continue;
      if(o.type !== "earnDen") continue;
      o.progress = clamp(o.progress + amount, 0, o.target);
    }
  }

  function claimObjective(idx){
    ensureObjectives();
    const o = S.objectives[idx];
    if(!o || o.claimed || !objComplete(o)) return;

    o.claimed = true;
    S.objStreak = (Number(S.objStreak)||0) + 1;

    const now = Date.now();
    const objMult = now < (S.objDoubleUntil || 0) ? 2 : 1;
    const rewardDen = o.rewardDen * objMult;
    const rewardPower = o.rewardPower * objMult;

    // payout
    S.gold += rewardDen;
    S.lifetimeGold += rewardDen;
    S.power += rewardPower;

    const ren = Math.max(1, Math.round(rewardDen/110));
    S.renown += ren;
    S.lifetimeRenown += ren;

    const doubledText = objMult > 1 ? " (doubled)" : "";
    logLine(`Objective complete! (+${fmt(rewardDen)} denarii${doubledText})`, "good");
    toast("Objective claimed");

    // replace with a new one
    S.objectives[idx] = makeObjective();
  }

  function renderObjectives(){
    const list = $("#objList");
    if(!list) return;
    ensureObjectives();

    $("#objStreak").textContent = fmt(S.objStreak || 0);

    list.innerHTML = "";
    S.objectives.forEach((o, i) => {
      const row = document.createElement("div");
      row.style.display = "flex";
      row.style.alignItems = "center";
      row.style.justifyContent = "space-between";
      row.style.gap = "10px";

      const left = document.createElement("div");
      left.style.display = "flex";
      left.style.flexDirection = "column";
      left.style.gap = "2px";

      const title = document.createElement("div");
      title.style.fontFamily = "var(--mono)";
      title.style.fontSize = ".78rem";
      title.style.color = "var(--text)";
      title.textContent = objText(o);

      const small = document.createElement("div");
      small.style.fontFamily = "var(--sans)";
      small.style.fontSize = ".74rem";
      small.style.color = "var(--muted)";
      small.textContent = `Reward: +${fmt(o.rewardDen)} denarii â€¢ +${fmt(o.rewardPower)} power`;

      left.appendChild(title);
      left.appendChild(small);

      const btn = document.createElement("button");
      btn.className = "tab"; // reuse pill button style
      btn.style.padding = "10px 12px";
      btn.style.fontSize = ".74rem";
      btn.textContent = objComplete(o) ? "Claim" : `${Math.floor((o.progress/Math.max(1,o.target))*100)}%`;
      btn.disabled = !objComplete(o);
      if(objComplete(o)) btn.classList.add("active");
      btn.addEventListener("click", () => { claimObjective(i); render(); });

      row.appendChild(left);
      row.appendChild(btn);
      list.appendChild(row);
    });
  }


  // ---- Burst Events (RNG micro-spikes) ----
  function triggerTributeFever(){
    const now = Date.now();
    const dur = 6000; // 6s
    S.feverUntil = Math.max(S.feverUntil || 0, now) + dur;
    toast("Tribute Fever! +250% taps for 6s");
    logLine("Tribute Fever surges through the village!", "good");
  }

  function triggerDoubleObjectives(){
    const now = Date.now();
    const dur = 20000; // 20s
    S.objDoubleUntil = Math.max(S.objDoubleUntil || 0, now) + dur;
    toast("Double Objectives! Rewards boosted");
    logLine("For a short time, objectives are doubled.", "warn");
  }

  function triggerCommanderVisit(){
    S.warriors = (S.warriors || 0) + 1;
    recalcLegionStrength();
    toast("Commander visits: +1 free warrior");
    logLine("A seasoned commander grants you a free warrior.", "good");
  }

  function triggerGoldStorm(){
    const now = Date.now();
    S.lastGoldStormAt = now;

    // Small burst of gold
    const base = 18 + Math.floor((S.renown||0)/160) + (S.crowns||0)*4;
    const gain = Math.max(10, Math.round(base * (1 + Math.random()*3)));
    S.gold += gain;
    S.lifetimeGold += gain;
    bumpEarnedDenarii(gain);

    toast("Gold storm!");

    // Visual coins: reuse sparkAt across random positions
    try{
      const vw = window.innerWidth || 400;
      const vh = window.innerHeight || 700;
      for(let i=0;i<10;i++){
        const x = rnd(Math.floor(vw*0.1), Math.floor(vw*0.9));
        const y = rnd(Math.floor(vh*0.15), Math.floor(vh*0.7));
        sparkAt(x,y);
      }
    }catch(e){}
    logLine(`Gold storm! (+${fmt(gain)} denarii)`, "good");
  }

  function maybeBurst(source){
    // Base chance per trigger source
    let base;
    if(source === "streak") base = 0.18;
    else if(source === "cashout") base = 0.15;
    else if(source === "battle") base = 0.16;
    else if(source === "caravan") base = 0.16;
    else base = 0.10;

    if(Math.random() > base) return;

    const roll = Math.random();
    if(roll < 0.35){
      triggerTributeFever();
    }else if(roll < 0.60){
      triggerDoubleObjectives();
    }else if(roll < 0.80){
      triggerCommanderVisit();
    }else{
      triggerGoldStorm();
    }
  }

// ---- Loot Chests (2-second dopamine overlay) ----
  function chestRarityFrom(source){
    // source: "skirmish" | "caravan" | "feast"
    // For skirmishes, we bias rarity by total battles won so early fights feel juicy:
    // e.g. after 5 wins, guaranteed Common; after 8+, Rare+; after 12+, Epic chance.
    if(source === "skirmish"){
      const wins = S.battlesWon || 0;
      if(wins >= 12){
        const roll = Math.random();
        if(roll < 0.45) return "Epic";
        if(roll < 0.85) return "Rare";
        return "Common";
      }else if(wins >= 8){
        const roll = Math.random();
        if(roll < 0.30) return "Epic";
        if(roll < 0.80) return "Rare";
        return "Common";
      }else if(wins >= 5){
        // first few chests are almost always common, to teach the loop
        const roll = Math.random();
        if(roll < 0.15) return "Rare";
        return "Common";
      }else{
        // before 5 wins, very small chance from skirmish
        if(Math.random() < 0.30) return "Common";
        // no chest; caller shouldn't have asked for rarity
        return "Common";
      }
    }

    // Feast / caravan still mostly RNG, but feasts skew better.
    const roll = Math.random();
    const epicP = source==="feast" ? 0.14 : (source==="caravan" ? 0.08 : 0.05);
    const rareP = source==="feast" ? 0.40 : (source==="caravan" ? 0.34 : 0.28);
    if(roll < epicP) return "Epic";
    if(roll < epicP + rareP) return "Rare";
    return "Common";
  }

  function chestPalette(rarity){
    if(rarity==="Epic") return { title:"Epic Chest", icon:"ðŸ‘‘", border:"rgba(244,208,111,.55)" };
    if(rarity==="Rare") return { title:"Rare Chest", icon:"ðŸº", border:"rgba(166,212,172,.55)" };
    return { title:"Common Chest", icon:"ðŸ§°", border:"rgba(31,58,42,.85)" };
  }

  function makeChestLoot(rarity){
    // Build 3 rewards. Keep it simple: denarii / power / renown OR a temp buff.
    const mult = cashoutMultiplier();
    const base = 35 + Math.floor(S.renown/160) + (S.crowns*7);

    const rarityMult = (rarity==="Epic") ? 2.6 : (rarity==="Rare" ? 1.65 : 1.0);

    const options = [
      () => ({ kind:"den",  text:`+${fmt(Math.round((base*10) * rarityMult * mult))} denarii`, apply:()=>{
        const amt = Math.round((base*10) * rarityMult * mult);
        S.gold += amt; S.lifetimeGold += amt; bumpEarnedDenarii(amt);
        const r = Math.max(1, Math.round(amt/130)); S.renown += r; S.lifetimeRenown += r;
      }}),
      () => ({ kind:"pow",  text:`+${fmt(Math.round((2 + base*0.03) * rarityMult))} power`, apply:()=>{
        S.power += Math.round((2 + base*0.03) * rarityMult);
      }}),
      () => ({ kind:"ren",  text:`+${fmt(Math.round((6 + base*0.06) * rarityMult))} renown`, apply:()=>{
        const amt = Math.round((6 + base*0.06) * rarityMult);
        S.renown += amt; S.lifetimeRenown += amt;
      }}),
      () => ({ kind:"buf",  text:`Prosperity (20s)`, apply:()=>{
        // income multiplier via prosperUntil (stacks by extending)
        const now = Date.now();
        const add = 20_000 + (rarity==="Epic" ? 12_000 : (rarity==="Rare" ? 6_000 : 0));
        S.prosperUntil = Math.max(S.prosperUntil||0, now) + add;
        toast("Prosperity!");
      }}),
    ];

    // Rarity influences chance of buff appearing
    const buffChance = (rarity==="Epic") ? 0.45 : (rarity==="Rare" ? 0.25 : 0.12);

    const picks = [];
    for(let i=0;i<3;i++){
      let item;
      if(chance(buffChance) && picks.filter(p=>p.kind==="buf").length===0){
        item = options[3]();
      }else{
        // pick among den/pow/ren biased towards denarii
        const r = Math.random();
        item = (r < 0.55) ? options[0]() : (r < 0.78 ? options[1]() : options[2]());
      }
      picks.push(item);
    }
    return picks;
  }


  function showChest(source="caravan"){
    const rarity = chestRarityFrom(source);
    const loot = makeChestLoot(rarity);

    const overlay = $("#chestOverlay");
    const card = $("#chestCard");
    const title = $("#chestTitle");
    const icon = $("#chestIcon");
    const hint = $("#chestHint");
    const rev = [$("#rev1"), $("#rev2"), $("#rev3")];
    const btnContinue = $("#chestContinue");

    const pal = chestPalette(rarity);
    title.textContent = pal.title;
    icon.textContent = pal.icon;
    card.style.borderColor = pal.border;

    // reset reveal
    rev.forEach(r=>r.textContent = "?");
    hint.textContent = "Tap to reveal rewards";
    if(btnContinue){
      btnContinue.style.display = "none";
      btnContinue.disabled = true;
    }

    overlay.style.display = "flex";
    // small fade/scale-in via CSS class
    overlay.classList.add("visible");

    let opened = false;
    let step = 0;

    const finish = ()=>{
      overlay.classList.remove("visible");
      overlay.onclick = null;
      if(btnContinue){
        btnContinue.onclick = null;
        btnContinue.disabled = true;
      }
      // wait for transition then hide
      setTimeout(()=>{
        overlay.style.display = "none";
      }, 230);

      // tiny burst
      try{
        const rect = card.getBoundingClientRect();
        sparkAt(rect.left + rect.width*0.50, rect.top + rect.height*0.22);
      }catch(e){}
      render();
    };

    const revealNext = ()=>{
      if(step >= 3) return;
      const item = loot[step];
      rev[step].textContent = item.text;
      // apply immediately so the HUD updates after close
      item.apply();
      step += 1;
      if(step >= 3){
        hint.textContent = "All rewards claimed.";
        if(btnContinue){
          btnContinue.style.display = "inline-flex";
          btnContinue.disabled = false;
          btnContinue.onclick = finish;
        }else{
          // fallback: tap backdrop closes
          overlay.onclick = finish;
        }
      }
    };

    const open = ()=>{
      if(step >= 3){
        // if already done, do nothing here (continue handled by button)
        return;
      }
      if(opened){
        revealNext();
        return;
      }
      opened = true;
      hint.textContent = "Openingâ€¦";
      // fast 3 reveals
      revealNext();
      setTimeout(revealNext, 220);
      setTimeout(revealNext, 440);
    };

    // Tap anywhere on the card/backdrop to open/advance
    overlay.onclick = open;
  }


  function canAccess(view){
    return (S.renown >= (unlock[view] ?? 0));
  }

  function setView(view){
    if(!canAccess(view)){
      const need = unlock[view] ?? 0;
      toast(`Locked â€” need ${need} renown`);
      return;
    }
    currentView = view;
    $$(".view").forEach(v => v.hidden = v.dataset.view !== view);
    $$(".tab").forEach(b => b.classList.toggle("active", b.dataset.go === view));
    render();
  }

  // ---- UI render ----
  function fmt(n){
    n = Math.floor(n);
    if(n < 10000) return String(n);
    if(n < 1_000_000) return (n/1000).toFixed(1).replace(".0","") + "k";
    if(n < 1_000_000_000) return (n/1_000_000).toFixed(1).replace(".0","") + "m";
    return (n/1_000_000_000).toFixed(1).replace(".0","") + "b";
  }

  function renderTabs(){
    $$(".tab").forEach(btn => {
      const v = btn.dataset.go;
      const ok = canAccess(v);
      btn.disabled = !ok;
      btn.title = ok ? "" : `Unlock at ${unlock[v]} renown`;
    });
  }

  function updateTitleProgress(){
    const r = S.renown;
    const {cur, next} = titleInfo();
    $("#title").textContent = cur.name;
    $("#nextTitle").textContent = next.name;

    const span = Math.max(1, next.need - cur.need);
    const t = clamp((r - cur.need) / span, 0, 1);
    $("#progressFill").style.width = (t*100).toFixed(1) + "%";
  }

  function statsRows(){
    const rows = [
      ["Gold", S.gold],
      ["Renown", S.renown],
      ["Power", S.power],
      ["Income / sec", incomePerSec().toFixed(1)],
      ["Tap base (tribute)", S.tribute],
      ["Rank tap bonus", rankTributeBonus(titleInfo().idx)],
      ["Streak", "x"+S.streak],
      ["Crit chance", Math.round(critChance()*100)+"%"],
      ["Farms", S.farmCount],
      ["Villas", S.villaCount],
      ["Warriors", S.warriors],
            ["Legion strength", S.legion],
      ["Raids won", S.battlesWon],
      ["Land", S.land],
      ["Influence", S.influence],
      ["Population Used", S.populationUsed],
      ["Population Cap", populationCap()],
            ["Faith", S.faith],
      ["Crowns (prestige)", S.crowns],
      ["Ascensions", S.ascends || 0],
      ["Best streak (all time)", S.bestStreak || 0],
      ["Biggest cashout", S.biggestCashout || 0],
      ["Decrees", S.decrees],
      ["Multipliers", `Land x${landMult().toFixed(2)} â€¢ Decree x${decreeMult().toFixed(2)} â€¢ Crown x${crownMult().toFixed(2)}`],
      ["Lifetime denarii", S.lifetimeGold],
      ["Lifetime renown", S.lifetimeRenown],
    ];
    return rows;
  }

  function render(){
    handleRankUps();
    expireCashoutIfNeeded();
    expireStreakIfNeeded();

    $("#gold").textContent = fmt(S.gold);
    $("#renown").textContent = fmt(S.renown);
    $("#power").textContent = fmt(S.power);
    $("#landHud").textContent = fmt(S.land || 0);

    $("#incomeRate").textContent = incomePerSec().toFixed(1);

    // Population display (village capacity)
    const cap = populationCap();
    const used = (S.populationUsed||0);
    const pu = $("#popUsed"); const pc = $("#popCap");
    if(pu && pc){ pu.textContent = fmt(used); pc.textContent = fmt(cap); }


    // Village
    const t = tapGain();
    $("#tributeGain").textContent = `+${fmt(t.gain)} denarii`;
    $("#tributeHint").textContent = `Streak x${S.streak} â€¢ ${Math.ceil(streakTimeLeftMs()/100)/10}s${rushBonus()>0 ? ` â€¢ RUSH +${rushBonus()}` : ""}${isBuffed() ? " â€¢ BLESSED" : ""}${Date.now() < (S.feverUntil||0) ? " â€¢ FEVER" : ""}${Date.now() < (S.objDoubleUntil||0) ? " â€¢ DOUBLE OBJ" : ""}`;


    // Cash Out UI
    const cbtn = $("#btnCashout");
    if(cbtn){
      const pot = cashoutPotential();
      const ready = cashoutReady();
      cbtn.style.display = "flex";
      cbtn.disabled = !ready;
      const cd = Math.max(0, Math.ceil(((S.cashoutCooldownUntil||0) - Date.now())/1000));
      if(pot <= 0){
        $("#cashoutDesc").textContent = `Unlock at streak x${CASHOUT_MIN_STREAK}`;
      }else if(cd>0){
        $("#cashoutDesc").textContent = `Cooling down (${cd}s)`;
      }else{
        const ms = Math.floor((S.streak||1)/10);
        $("#cashoutDesc").textContent = `Cash out +${fmt(pot)} denarii${ms>0 ? ` â€¢ Milestones ${ms}` : ""}`;
      }
    }


    $("#farmDesc").textContent  = `${fmt(S.farmCount)} farms â€¢ Cost ${fmt(costFarm())} â€¢ +0.75/s each`;
    $("#villaDesc").textContent = `${fmt(S.villaCount)} villas â€¢ Cost ${fmt(costVilla())} â€¢ +3.0/s each â€¢ +10 cap`;

    updateTitleProgress();

    // Legion
    recalcLegionStrength();
    $("#warriors").textContent = fmt(S.warriors);
    $("#legionStr").textContent = fmt(S.legion);
    $("#landLegion").textContent = fmt(S.land);
    $("#landHud").textContent = fmt(S.land);

    $("#recruitCost").textContent = `Cost ${fmt(recruitCost())}`;
    $("#recruitGain").textContent = `+${fmt(recruitStrengthGain())} strength`;

    
    // Battles (enemy-count based)
    const cd = Math.max(0, Math.ceil(((S.battleReadyAt||0) - Date.now())/1000));

    const canBandits1 = (S.warriors||0) >= 1;
    const canLevy     = (S.warriors||0) >= 10;
    const canVillageR = (S.warriors||0) >= 25;
    const canSiege    = (S.warriors||0) >= 60;

    $("#btnBattleBandits1").disabled   = !canBandits1 || cd>0;
    $("#btnBattleLevy").disabled       = !canLevy     || cd>0;
    $("#btnBattleVillageRaid").disabled= !canVillageR || cd>0;
    $("#btnBattleSiege").disabled      = !canSiege    || cd>0;

    $("#battleBandits1Desc").textContent    = canBandits1 ? (cd>0 ? `Cooling down (${cd}s)` : `10â€“50 enemies â€¢ quick skirmish`) : `Need 1 warrior`;
    $("#battleLevyDesc").textContent        = canLevy     ? (cd>0 ? `Cooling down (${cd}s)` : `250â€“500 enemies â€¢ moderate risk`) : `Need 10 warriors`;
    $("#battleVillageRaidDesc").textContent = canVillageR ? (cd>0 ? `Cooling down (${cd}s)` : `500â€“1,000 enemies â€¢ high risk`) : `Need 25 warriors`;
    $("#battleSiegeDesc").textContent       = canSiege    ? (cd>0 ? `Cooling down (${cd}s)` : `1,000â€“5,000 enemies â€¢ deadly`) : `Need 60 warriors`;

    // Village capacity hint: recruiting uses capacity, but battles are allowed regardless.
    if(!hasVillageCapacity()){
      $("#battleBandits1Desc").textContent = "Village at capacity â€” build farms or take land";
    }

    // Temple
    $("#crowns").textContent = fmt(S.crowns);
    $("#offerCost").textContent = `Cost ${fmt(offerCost())}`;
    $("#faithNow").textContent = `Faith ${fmt(S.faith)}`;
    $("#critRate").textContent = Math.round(critChance()*100) + "%";
    const buffLeft = Math.max(0, Math.ceil((S.buffUntil - Date.now())/1000));
    $("#buffLeft").textContent = buffLeft + "s";
    const blessCd = Math.max(0, Math.ceil((S.blessReadyAt - Date.now())/1000));
    $("#blessDesc").textContent = blessCd>0 ? `CD ${blessCd}s â€¢ doubles crits` : `Ready â€¢ doubles crits`;
    $("#btnBless").disabled = blessCd>0;
    const crownsGain = ascendCrownGain();
    $("#ascendDesc").textContent = crownsGain>0 ? `Reset for +${crownsGain} crowns` : `Need 25,000 renown`;

    // Court
    $("#inf2").textContent = fmt(S.influence);
    $("#decrees").textContent = fmt(S.decrees);
    $("#courtCost").textContent = `Cost ${fmt(courtCost())} influence`;
    $("#courtGain").textContent = `+${fmt(courtRenownGain())} renown`;
    $("#decreeDesc").textContent = `Cost ${fmt(decreeCostGold())}d +${fmt(decreeCostInf())} inf â€¢ perm boosts`;
    const feastCd = Math.max(0, Math.ceil((S.feastReadyAt - Date.now())/1000));
    $("#feastCd").textContent = feastCd + "s";
    $("#feastDesc").textContent = feastCd>0 ? `CD ${feastCd}s` : `Cost ${fmt(feastCostGold())} denarii â€¢ +${fmt(feastRenown())} renown`;
    $("#btnFeast").disabled = feastCd>0;

    // Stats
    const body = $("#statsTable");
    if(body){
      body.innerHTML = "";
      for(const [k,v] of statsRows()){
        const tr = document.createElement("tr");
        const td1 = document.createElement("td");
        const td2 = document.createElement("td");
        td1.textContent = k;
        td2.textContent = (typeof v === "number") ? fmt(v) : String(v);
        tr.appendChild(td1); tr.appendChild(td2);
        body.appendChild(tr);
      }
    }

    // global
    renderTabs();
    renderObjectives();
    $("#subline").textContent = (Date.now() < (S.prosperUntil||0))
      ? "Prosperity active â€” income is boosted."
      : (isBuffed()
          ? "Blessing active â€” crits are juiced."
          : "Unlock tabs by earning renown. Prestige later for crowns.");
    save(true);
  }

  // ---- Actions ----
  $("#btnTribute").addEventListener("click", (e)=>{
    applyStreak();
    const {gain, crit} = tapGain();

    // Jackpots: rare huge spikes layered on top of small taps
    const jp = rollJackpot();
    let jackpotGain = 0;
    if(jp){
      // Jackpot scales with your effective tap gain (already includes multipliers)
      jackpotGain = Math.round(gain * jp.mult);
      toast(jp.type + "!");
      logLine(`${jp.type}! (+${fmt(jackpotGain)} denarii)`, "good");
    }

    S.gold += (gain + jackpotGain);
    S.lifetimeGold += (gain + jackpotGain);

    bumpObjective("tap", 1);
    bumpEarnedDenarii(gain + jackpotGain);
    const ren = Math.max(1, Math.round(gain/14) + Math.round(jackpotGain/70));
    S.renown += ren;
    S.lifetimeRenown += ren;
    S.power += 1 + (crit ? 1 : 0);

    const rect = e.currentTarget.getBoundingClientRect();
    sparkAt(rect.left + rect.width*0.78, rect.top + rect.height*0.42);

    if(jp){ for(let i=0;i<3;i++) sparkAt(rect.left + rect.width*(0.55 + i*0.12), rect.top + rect.height*0.30); }

    if(crit){ toast("CRIT!"); logLine(`CRIT tribute! (+${fmt(gain)} denarii)`, "good"); }
    else if(S.streak % 7 === 0) logLine(`Tribute collected. (+${fmt(gain)} denarii)`, "good");

    // gentle soft cap
    S.power = clamp(S.power, 0, 99999);
    
    // Cash Out: bank some value as you tap; becomes claimable every few taps.
    S.tapsSinceCashout += 1;
    bankCashout(gain + Math.round(jackpotGain*0.08));
    
render();
  });

  $("#btnFarm").addEventListener("click", ()=>{
    const c = costFarm();
    if(S.gold < c){ toast("Not enough denarii"); return; }
    S.gold -= c;
    S.farmCount += 1;
    bumpObjective("buildFarm", 1);
    S.renown += 6;
    logLine("A farm feeds your people. (+income)", "good");
    toast("Village capacity grows");
    render();
  });

  $("#btnVilla").addEventListener("click", ()=>{
    const c = costVilla();
    if(S.gold < c){ toast("Not enough denarii"); return; }
    S.gold -= c;
    S.villaCount += 1;
    bumpObjective("buildVilla", 1);
    S.renown += 10;
    logLine("A villa rises. The taxes flow.", "good");
    toast("Village capacity grows");
    render();
  });
  $("#btnRecruit").addEventListener("click", (e)=>{
    const c = recruitCost();
    if(S.gold < c){ toast("Not enough denarii"); return; }
    if(!hasVillageCapacity()){ toast("Need more farms to support warriors"); return; }
    S.gold -= c;
    S.warriors += 1;
    S.populationUsed = (S.populationUsed || 0) + 1;
    recalcLegionStrength();

    // Recruiting gives power and renown (feels like progress)
    S.power += 2;
    S.renown += 18;
    bumpObjective("recruit", 1);

    const rect = e.currentTarget.getBoundingClientRect();
    sparkAt(rect.left + rect.width*0.80, rect.top + rect.height*0.45);

    toast("Recruited");
    logLine(`A warrior joins your banner. (Warriors: ${fmt(S.warriors)})`, "good");
    render();
  });
  
    // --- Battle Report overlay (after every battle) ---
  function showBattleReport(rep){
    const overlay = document.getElementById("battleOverlay");
    const body = document.getElementById("battleBody");
    const title = document.getElementById("battleTitle");
    if(!overlay || !body || !title) return;

    title.textContent = rep.win ? "Victory Report" : "Defeat Report";

    body.innerHTML = `
      <table class="table" style="margin:0;">
        <tbody>
          <tr><td>Engagement</td><td>${rep.label}</td></tr>
          <tr><td>Enemies</td><td>${fmt(rep.enemies)}</td></tr>
          <tr><td>Win chance</td><td>${Math.round(rep.winP*100)}%</td></tr>
          <tr><td>Your warriors</td><td>${fmt(rep.beforeWarriors)} â†’ ${fmt(rep.afterWarriors)}</td></tr>
          <tr><td>Warriors lost</td><td>${fmt(rep.losses)}</td></tr>
          <tr><td>Denarii change</td><td>${rep.denDelta>=0?"+":""}${fmt(Math.abs(rep.denDelta))}</td></tr>
          <tr><td>Land change</td><td>${rep.landDelta>=0?"+":""}${fmt(Math.abs(rep.landDelta))}</td></tr>
        </tbody>
      </table>
      <div style="margin-top:10px;font-family:var(--sans);color:var(--muted);font-size:.82rem;line-height:1.25;">
        ${rep.note || ""}
      </div>
    `;

    overlay.style.display = "flex";
    overlay.classList.add("visible");
  }

  function closeBattleReport(){
    const overlay = document.getElementById("battleOverlay");
    if(!overlay) return;
    overlay.classList.remove("visible");
    setTimeout(()=>{ overlay.style.display = "none"; }, 220);
  }
  // expose for overlay inline buttons
  window.closeBattleReport = closeBattleReport;
  window.showBattleReport = showBattleReport;
  // --- Battle Simulation (cinematic log before the report) ---
  function battleFlavor(key){
    if(key==="bandits") return { place:["dusty ravine","cracked road","olive grove","dry creekbed"], foe:["bandits","raiders","cutthroats","brigands"] };
    if(key==="levy")    return { place:["lord's fields","river ford","stone bridge","low hills"], foe:["levy militia","local host","armed retainers","spearmen"] };
    if(key==="village") return { place:["outskirts of the village","walled hamlet","grain stores","market square"], foe:["village defenders","militia line","watchmen","shield wall"] };
    if(key==="siege")   return { place:["town gates","outer palisade","city walls","battered breach"], foe:["garrison","town guard","veterans","bowmen"] };
    return { place:["battlefield"], foe:["enemy"] };
  }

  function generateBattleLines(rep, key){
    const f = battleFlavor(key);
    const place = f.place[rnd(0, f.place.length-1)];
    const foe = f.foe[rnd(0, f.foe.length-1)];

    // Derived "tempo"
    const before = Math.max(1, rep.beforeWarriors||1);
    const lossPct = (rep.losses||0) / before;
    const cleanWin = rep.win && lossPct <= 0.03;
    const costlyWin = rep.win && lossPct >= 0.18;
    const close = rep.winP < 0.62;
    const stomp = rep.winP > 0.93;

    const lines = [];
    lines.push(`The battle commences at the ${place}.`);
    lines.push(`Scouts report ${fmt(rep.enemies)} ${foe} ahead.`);

    if(stomp) lines.push("Your warriors advance in tight order. Confidence runs through the ranks.");
    else if(close) lines.push("The omens are uncertain. Your line steadies as the enemy surges forward.");
    else lines.push("Steel flashes as both sides collide. Standards rise above the dust.");

    // Mid-fight variation
    if(rep.win){
      if(cleanWin){
        lines.push("Your forces flank the enemy and break their will.");
        lines.push("Momentum buildsâ€”shields slam, spears drive, and the foe scatters.");
      }else if(costlyWin){
        lines.push("The enemy fights savagely. Your front buckles, then holds.");
        lines.push("A desperate push turns the tide. The line reforms and presses on.");
      }else{
        lines.push("Your warriors find an opening and press it hard.");
        lines.push("The enemy line wavers under sustained pressure.");
      }

      lines.push("The foe collapsesâ€”routs begin, and your banner remains standing.");

      // Loss flavor
      if(rep.losses <= 2) lines.push("Few fall. The men cheer and regroup.");
      else if(rep.losses <= 8) lines.push("You count the fallen. Veterans drag the wounded from the field.");
      else lines.push("The victory is paid in blood. Names are spoken over the dead.");
    }else{
      lines.push("The enemy holds firm and answers every charge.");
      lines.push("Your formation frays. A gap opensâ€”then widens.");
      lines.push("A horn sounds retreat. Survivors pull back under a hail of stones and arrows.");
      if(rep.losses <= 4) lines.push("You escape with minor losses, but the shame stings.");
      else if(rep.losses <= 12) lines.push("The retreat is costly. You vow to return stronger.");
      else lines.push("It is a rout. You regroup with what remains of your warriors.");
    }

    return lines;
  }

  function showBattleSimulation(rep, key){
    const overlay = document.getElementById("battleSimOverlay");
    const title = document.getElementById("battleSimTitle");
    const log = document.getElementById("battleSimLog");
    const enemies = document.getElementById("battleSimEnemies");
    const odds = document.getElementById("battleSimOdds");
    const btnSkip = document.getElementById("battleSimSkip");
    const btnContinue = document.getElementById("battleSimContinue");

    if(!overlay || !log || !title || !enemies || !odds) return false;

    title.textContent = rep.label;
    enemies.textContent = fmt(rep.enemies);
    odds.textContent = `${Math.round(rep.winP*100)}%`;

    log.innerHTML = "";
    btnContinue.style.display = "none";
    btnContinue.onclick = null;

    overlay.style.display = "flex";
    overlay.classList.add("visible");

    const lines = generateBattleLines(rep, key);
    let i = 0;
    let done = false;

    function appendLine(text, tone=""){
      const p = document.createElement("p");
      p.className = "simLine";
      if(tone) p.innerHTML = `<span class="${tone}">${text}</span>`;
      else p.textContent = text;
      log.appendChild(p);
      log.scrollTop = log.scrollHeight;
    }

    function finish(){
      if(done) return;
      done = true;
      btnContinue.style.display = "inline-flex";
      btnContinue.onclick = ()=>{
        overlay.classList.remove("visible");
        setTimeout(()=>{ overlay.style.display = "none"; }, 220);
    showBattleSimulation(rep, key);
      };
    }

    function step(){
      if(done) return;
      if(i >= lines.length){
        finish();
        return;
      }
      const text = lines[i++];
      const tone = (i === lines.length) ? (rep.win ? "good" : "bad") : "";
      appendLine(text, tone);
      setTimeout(step, 520 + rnd(-120, 160));
    }

    btnSkip.onclick = ()=>{
      if(done) return;
      // dump remaining lines quickly then finish
      while(i < lines.length){
        const text = lines[i++];
        appendLine(text);
      }
      finish();
    };

    // Start with a small dramatic pause
    setTimeout(step, 280);
    return true;
  }



function doBattle(key){
    const now = Date.now();
    const startGold = S.gold;
    const startLand = S.land;
    const beforeWarriors = S.warriors || 0;

    // 3-second streak window
    if(now - (S.lastTap||0) <= STREAK_WINDOW_MS){ S.streak += 1; } else { S.streak = 1; }
    S.lastTap = now;

    if(now < (S.battleReadyAt||0)){ toast("Cooling down"); return; }

    const b = BATTLES[key];
    if(!b){ toast("No such battle"); return; }

    const sim = battleSim(key);

    // Apply casualties (warriors can die)
    const before = S.warriors || 0;
    let losses = clamp(sim.losses, 0, before);
    if(before > 0 && losses === 0) losses = 1;
    S.warriors = before - losses;

    // Free up population slots when warriors die
    S.populationUsed = Math.max(0, (S.populationUsed || 0) - losses);

    recalcLegionStrength();

    S.battleReadyAt = now + battleCooldownMs(key);

    if(sim.win){
      const landGain = rnd(b.landMin, b.landMax);
      S.land += landGain;

      const loot = Math.round((b.lootBase + (S.battlesWon||0)*b.lootScale) * landMult() * crownMult());
      S.gold += loot; S.lifetimeGold += loot; bumpEarnedDenarii(loot);

      const ren = Math.max(1, Math.round((loot/180) + landGain*2));
      S.renown += ren; S.lifetimeRenown += ren;

      const inf = Math.max(1, Math.round(1 + landGain));
      S.influence += inf;

      S.battlesWon = (S.battlesWon||0) + 1;

      if(key==="bandits") bumpObjective("winBandits", 1);
      else if(key==="levy") bumpObjective("winLevy", 1);
      else if(key==="village") bumpObjective("winVillage", 1);
      else if(key==="siege") bumpObjective("winSiege", 1);
      bumpObjective("gainLand", landGain);

      maybeBurst("battle");

      toast("Victory!");
      logLine(`Victory vs ${fmt(sim.enemies)} enemies! (+${fmt(loot)} denarii, +${fmt(landGain)} land, -${fmt(losses)} warriors)`, "good");
    }else{
      const lost = Math.min(S.gold, Math.round(b.lootBase*0.35));
      S.gold -= lost;
      S.power = Math.max(0, S.power - 2);

      toast("Defeat");
      logLine(`Defeat vs ${fmt(sim.enemies)} enemies. (-${fmt(lost)} denarii, -${fmt(losses)} warriors)`, "bad");
    }

    // Chance for a loot chest after a win (more likely as you prove yourself)
    if(sim.win){
      const wins = S.battlesWon || 0;
      const chestChance = clamp(0.18 + wins*0.03, 0.18, 0.70);
      if(Math.random() < chestChance){
        showChest("skirmish");
      }
    }

    const rep = {
      label: b.label,
      enemies: sim.enemies,
      winP: sim.winP,
      win: sim.win,
      beforeWarriors,
      afterWarriors: S.warriors || 0,
      losses,
      denDelta: Math.round(S.gold - startGold),
      landDelta: Math.round(S.land - startLand),
      note: sim.win ? "You held the field and counted the fallen." : "You retreat to lick your wounds."
    };
    showBattleReport(rep);

    render();
  }

  $("#btnBattleBandits1").addEventListener("click", ()=> doBattle("bandits"));
  $("#btnBattleLevy").addEventListener("click", ()=> doBattle("levy"));
  $("#btnBattleVillageRaid").addEventListener("click", ()=> doBattle("village"));
  $("#btnBattleSiege").addEventListener("click", ()=> doBattle("siege"));


    // Skirmish: optional combat later (tiny screen footprint)

  $("#btnOffer").addEventListener("click", ()=>{
    const c = offerCost();
    if(S.gold < c){ toast("Not enough denarii"); return; }
    S.gold -= c;
    const f = offerFaithGain();
    S.faith += f;
    S.renown += 12;

    // Temple objective
    bumpObjective("offerFaith", 1);

    toast("Blessed");
    render();
  });

  $("#btnBless").addEventListener("click", ()=>{
    const now = Date.now();
    if(now < S.blessReadyAt){ toast("Cooling down"); return; }
    S.blessReadyAt = now + blessCooldownMs();
    S.buffUntil = now + blessDurationMs();
    toast("Blessing!");
    render();
  });

  $("#btnAscend").addEventListener("click", ()=>{
    const gain = ascendCrownGain();
    if(gain <= 0){ toast("Need 25,000 renown"); return; }
    if(!confirm(`Ascend for +${gain} crowns? (Resets most progress)`)) return;

    const keepCrowns = (S.crowns || 0) + gain;
    const keepLifetimeGold = S.lifetimeGold || 0;
    const keepLifetimeRenown = S.lifetimeRenown || 0;
    const nextAscends = (S.ascends || 0) + 1;

    S = defaultState();
    S.crowns = keepCrowns;
    S.lifetimeGold = keepLifetimeGold;
    S.lifetimeRenown = keepLifetimeRenown;
    S.ascends = nextAscends;

    $("#log").innerHTML = "";
    logLine(`You ascend. Crowns: ${fmt(S.crowns)}. (Ascensions: ${S.ascends})`, "warn");
    toast("Ascended");
    save(true);
    setView("village");
  });

  $("#btnCourt").addEventListener("click", (e)=>{
    const c = courtCost();
    if(S.influence < c){ toast("Need more influence"); return; }
    S.influence -= c;
    const g = courtRenownGain();
    S.renown += g;
    S.lifetimeRenown += g;

    // Court objective
    bumpObjective("holdCourt", 1);

    const rect = e.currentTarget.getBoundingClientRect();
    sparkAt(rect.left + rect.width*0.70, rect.top + rect.height*0.52);

    toast("Applauded");
    render();
  });

  $("#btnDecree").addEventListener("click", ()=>{
    const g = decreeCostGold();
    const i = decreeCostInf();
    if(S.gold < g){ toast("Not enough denarii"); return; }
    if(S.influence < i){ toast("Need more influence"); return; }
    S.gold -= g; S.influence -= i;
    S.decrees += 1;
    S.renown += 60;
    toast("Decreed");
    render();
  });

  $("#btnFeast").addEventListener("click", ()=>{
    const now = Date.now();
    if(now < S.feastReadyAt){ toast("Cooling down"); return; }
    const c = feastCostGold();
    if(S.gold < c){ toast("Not enough denarii"); return; }
    S.gold -= c;
    S.feastReadyAt = now + feastCooldownMs();

    const r = feastRenown();
    S.renown += r;
    S.lifetimeRenown += r;

    // Feast objective
    bumpObjective("feast", 1);

    toast("Feast!");
    showChest("feast");
    render();
  });

  
  $("#btnCashout").addEventListener("click", (e)=>{
    if(!cashoutReady()){ toast("Not ready"); return; }

    const payout = cashoutPotential();
    if(payout <= 0){ toast("No bonus"); return; }

    S.gold += payout;
    S.lifetimeGold += payout;
    bumpEarnedDenarii(payout);

    // Small renown kicker (keeps it meaningful)
    const r = Math.max(1, Math.round(payout/160));
    S.renown += r;
    S.lifetimeRenown += r;

    // Track biggest single cashout across all runs
    if(!S.biggestCashout || payout > S.biggestCashout){
      S.biggestCashout = payout;
    }

    // Cashing out resets streak: this is the decision point.
    S.streak = 1;
    S.lastTap = Date.now();

    // Short cooldown so players can't spam-cash at low streaks.
    S.cashoutCooldownUntil = Date.now() + CASHOUT_COOLDOWN_MS;

    const rect = e.currentTarget.getBoundingClientRect();
    sparkAt(rect.left + rect.width*0.55, rect.top + rect.height*0.55);

    // Cashout burst chance
    maybeBurst("cashout");

    toast("Cashed out!");
    logLine(`Cashed out for +${fmt(payout)} denarii`, "good");
    bumpObjective("cashout", 1);

    render();
  });

$("#btnExport").addEventListener("click", async ()=>{
    try{
      await navigator.clipboard.writeText(JSON.stringify(S));
      toast("Copied");
    }catch(e){
      toast("Clipboard blocked");
    }
  });

  $("#btnReset").addEventListener("click", ()=>{
    if(!confirm("Erase save on this device?")) return;
    localStorage.removeItem(STORAGE_KEY);
    S = defaultState();
    $("#log").innerHTML = "";
    toast("Reset");
    setView("village");
  });

  // Tabs click
  $$(".tab").forEach(btn=>{
    btn.addEventListener("click", ()=> setView(btn.dataset.go));
  });

  // Passive tick (keeps progression going)
  let last = Date.now();
  setInterval(()=>{
    const now = Date.now();
    const dt = (now - last)/1000;
    last = now;

    // Passive income
    const inc = incomePerSec() * dt;
    if(inc > 0){
      S.gold += inc;
      S.lifetimeGold += inc;
    }

    // Objectives: passive income counts toward "Earn denarii"
    if(inc > 0) bumpEarnedDenarii(inc);


    // Power slowly decays a tiny bit if huge (keeps choices meaningful)
    if(S.power > 500) S.power -= (S.power-500) * 0.0006 * dt;

    render();
  }, 650);

  // First paint
  $("#log").innerHTML = "";
  logLine("A small village. A few denarii. A long road to the crown.", "warn");
  render();
})();
</script>

  <!-- Loot Chest Overlay -->
  <div id="chestOverlay" style="position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:2000;">
    <div id="chestBackdrop" style="position:absolute;inset:0;background:rgba(0,0,0,.55);backdrop-filter:blur(6px);"></div>
    <div id="chestCard" class="card" style="position:relative;width:min(520px, calc(100vw - 26px));border-radius:26px;overflow:hidden;">
      <div class="sectionTitle" style="justify-content:center;">
        <span id="chestTitle" style="color:var(--accent);font-weight:900;">Chest</span>
      </div>
      <div class="cardBody" style="text-align:center; padding:16px 14px 14px;">
        <div id="chestIcon" style="font-size:56px;line-height:1.0;filter:drop-shadow(0 12px 18px rgba(0,0,0,.25));">ðŸ§°</div>
        <div id="chestHint" style="margin-top:10px;font-family:var(--mono);color:var(--muted);font-size:.80rem;">Tap to open</div>

        <div id="revealRow" style="margin-top:14px;display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px;">
          <div class="card" style="box-shadow:none;border-radius:18px;border-color:rgba(31,58,42,.75);">
            <div class="cardBody" style="padding:14px 10px;">
              <div class="pill" id="rev1" style="display:inline-block;">?</div>
            </div>
          </div>
          <div class="card" style="box-shadow:none;border-radius:18px;border-color:rgba(31,58,42,.75);">
            <div class="cardBody" style="padding:14px 10px;">
              <div class="pill" id="rev2" style="display:inline-block;">?</div>
            </div>
          </div>
          <div class="card" style="box-shadow:none;border-radius:18px;border-color:rgba(31,58,42,.75);">
            <div class="cardBody" style="padding:14px 10px;">
              <div class="pill" id="rev3" style="display:inline-block;">?</div>
            </div>
          </div>
        </div>

        <div id="chestSub" style="margin-top:12px;font-family:var(--sans);color:var(--muted);font-size:.78rem;line-height:1.25;">
          Tap each reward, then continue.
        </div>
        <button id="chestContinue" class="tab" style="margin-top:10px;width:100%;justify-content:center;display:none;">
          <span class="dot"></span>Continue
        </button>
      </div>
    </div>
  </div>


  <!-- Battle Report Overlay -->
  <div id="battleOverlay" style="position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:2100;">
    <div style="position:absolute;inset:0;background:rgba(0,0,0,.55);backdrop-filter:blur(6px);" onclick="closeBattleReport()"></div>
    <div id="battleCard" class="card" style="position:relative;width:min(560px, calc(100vw - 26px));border-radius:26px;overflow:hidden;">
      <div class="sectionTitle" style="justify-content:space-between;">
        <span id="battleTitle" style="color:var(--accent);font-weight:900;">Battle Report</span>
        <button class="tab" style="padding:8px 12px;" onclick="closeBattleReport()">Close</button>
      </div>
      <div class="cardBody" style="padding:14px;">
        <div id="battleBody"></div>
      </div>
    </div>
  </div>


  <!-- Battle Simulation Overlay -->
  <div id="battleSimOverlay" style="position:fixed;inset:0;display:none;align-items:center;justify-content:center;z-index:2050;">
    <div style="position:absolute;inset:0;background:rgba(0,0,0,.55);backdrop-filter:blur(6px);"></div>
    <div id="battleSimCard" class="card" style="position:relative;width:min(560px, calc(100vw - 26px));border-radius:26px;overflow:hidden;">
      <div class="sectionTitle" style="justify-content:space-between;">
        <span id="battleSimTitle" style="color:var(--accent);font-weight:900;">Engagement</span>
        <div style="display:flex;gap:8px;align-items:center;">
          <button class="tab" style="padding:8px 12px;" id="battleSimSkip">Skip</button>
        </div>
      </div>
      <div class="cardBody" style="padding:14px;">
        <div style="font-family:var(--mono);color:var(--muted);font-size:.78rem;margin-bottom:10px;">
          Enemies: <b id="battleSimEnemies">0</b> â€¢ Estimated odds: <b id="battleSimOdds">0%</b>
        </div>
        <div id="battleSimLog" class="log" style="max-height:34vh;"></div>
        <button id="battleSimContinue" class="tab active" style="margin-top:10px;width:100%;justify-content:center;display:none;">
          <span class="dot"></span>View Report
        </button>
      </div>
    </div>
  </div>

</body>
</html>
